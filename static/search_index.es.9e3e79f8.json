[{"id":50,"title":"@gez/rspack-vue","content":"#\n\nEl paquete Rspack Vue proporciona un conjunto de API para crear y configurar\naplicaciones Rspack basadas en el marco Vue, con soporte para el desarrollo de\ncomponentes Vue, construcción y renderizado del lado del servidor.\n\n\nInstalación#\n\nInstale @gez/rspack-vue como dependencia de desarrollo utilizando un gestor de\npaquetes:\n\n\nExportación de tipos#\n\n\nBuildTarget#\n\n\n\nTipo de entorno de destino de construcción, que define el entorno de destino de\nla aplicación, utilizado para configurar optimizaciones y funciones específicas\ndurante el proceso de construcción:\n\n * node: Construye código para ejecutarse en un entorno Node.js\n * client: Construye código para ejecutarse en un entorno de navegador\n * server: Construye código para ejecutarse en un entorno del lado del servidor\n\n\nRspackAppConfigContext#\n\n\n\nInterfaz de contexto de configuración de la aplicación Rspack, que proporciona\ninformación de contexto accesible en las funciones de gancho de configuración:\n\n * gez: Instancia del marco Gez\n * buildTarget: Objetivo de construcción actual (client/server/node)\n * config: Objeto de configuración de Rspack\n * options: Opciones de configuración de la aplicación\n\n\nRspackAppOptions#\n\n\n\nInterfaz de opciones de configuración de la aplicación Rspack:\n\n * css: Método de salida CSS, opciones 'css' (archivo independiente) o 'style'\n   (estilos en línea)\n * loaders: Configuración personalizada de loaders\n * styleLoader: Opciones de configuración de style-loader\n * cssLoader: Opciones de configuración de css-loader\n * target: Configuración de compatibilidad del objetivo de construcción\n * definePlugin: Definición de constantes globales\n * config: Función de gancho de configuración\n\n\nRspackHtmlAppOptions#\n\nHereda de RspackAppOptions, utilizado para configurar opciones específicas de\naplicaciones HTML.\n\n\nExportación de funciones#\n\n\ncreateRspackApp#\n\n\n\nCrea una instancia estándar de aplicación Rspack.\n\nParámetros:\n\n * gez: Instancia del marco Gez\n * options: Opciones de configuración de la aplicación Rspack\n\nValor de retorno:\n\n * Devuelve una Promise que se resuelve en la instancia de la aplicación creada\n\n\ncreateRspackHtmlApp#\n\n\n\nCrea una instancia de aplicación Rspack de tipo HTML.\n\nParámetros:\n\n * gez: Instancia del marco Gez\n * options: Opciones de configuración de la aplicación HTML\n\nValor de retorno:\n\n * Devuelve una Promise que se resuelve en la instancia de la aplicación HTML\n   creada\n\n\nExportación de constantes#\n\n\nRSPACK_LOADER#\n\n\n\nObjeto de mapeo de identificadores de loaders integrados en Rspack, que\nproporciona constantes de nombres de loaders comunes:\n\n * builtinSwcLoader: SWC loader integrado en Rspack, utilizado para procesar\n   archivos TypeScript/JavaScript\n * lightningcssLoader: Lightningcss loader integrado en Rspack, utilizado para\n   compilar archivos CSS de alto rendimiento\n * styleLoader: Loader utilizado para inyectar CSS en el DOM\n * cssLoader: Loader utilizado para analizar archivos CSS y manejar la\n   modularización de CSS\n * lessLoader: Loader utilizado para compilar archivos Less a CSS\n * styleResourcesLoader: Loader utilizado para importar automáticamente recursos\n   de estilo globales (como variables, mixins)\n * workerRspackLoader: Loader utilizado para procesar archivos de Web Worker\n\nEstas constantes se pueden utilizar en la configuración para hacer referencia a\nlos loaders integrados, evitando la entrada manual de cadenas:\n\n\n\nNotas:\n\n * Estos loaders ya están integrados en Rspack y no requieren instalación\n   adicional\n * Al configurar loaders personalizados, se pueden usar estas constantes para\n   reemplazar la implementación predeterminada del loader\n * Algunos loaders (como builtinSwcLoader) tienen opciones de configuración\n   específicas, consulte la documentación de configuración correspondiente\n\n\nExportación de módulos#\n\n\nrspack#\n\nReexporta todo el contenido del paquete @rspack/core, proporcionando la\nfuncionalidad completa del núcleo de Rspack.","routePath":"/es/api/app/rspack-vue","lang":"es","toc":[{"text":"Instalación","id":"instalación","depth":2,"charIndex":227},{"text":"Exportación de tipos","id":"exportación-de-tipos","depth":2,"charIndex":332},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":356},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":786},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1175},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1695},{"text":"Exportación de funciones","id":"exportación-de-funciones","depth":2,"charIndex":1817},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1845},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":2125},{"text":"Exportación de constantes","id":"exportación-de-constantes","depth":2,"charIndex":2419},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2448},{"text":"Exportación de módulos","id":"exportación-de-módulos","depth":2,"charIndex":3787},{"text":"rspack","id":"rspack","depth":3,"charIndex":3813}],"domain":"","frontmatter":{"titleSuffix":"Herramienta de construcción Vue para el marco Gez","description":"Herramienta de construcción especializada en Vue para el marco Gez, que ofrece soporte completo para la construcción de aplicaciones Vue 2/3, incluyendo desarrollo de componentes, renderizado SSR y optimización de rendimiento.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, herramienta de construcción, desarrollo de componentes, renderizado del lado del servidor, optimización de rendimiento"}]]},"version":""},{"id":51,"title":"@gez/rspack","content":"#\n\nEl paquete Rspack proporciona un conjunto de API para crear y configurar\naplicaciones Rspack, soportando la construcción y desarrollo de aplicaciones\nestándar y aplicaciones HTML.\n\n\nInstalación#\n\nInstala @gez/rspack como dependencia de desarrollo utilizando un gestor de\npaquetes:\n\n\nExportación de Tipos#\n\n\nBuildTarget#\n\n\n\nTipo de entorno de construcción, define el entorno objetivo de la aplicación,\nutilizado para configurar optimizaciones y funcionalidades específicas durante\nel proceso de construcción:\n\n * node: Construye código para ejecutarse en un entorno Node.js\n * client: Construye código para ejecutarse en un entorno de navegador\n * server: Construye código para ejecutarse en un entorno de servidor\n\n\nRspackAppConfigContext#\n\n\n\nInterfaz de contexto de configuración de aplicación Rspack, proporciona\ninformación de contexto accesible en las funciones de enlace de configuración:\n\n * gez: Instancia del framework Gez\n * buildTarget: Objetivo de construcción actual (client/server/node)\n * config: Objeto de configuración Rspack\n * options: Opciones de configuración de la aplicación\n\n\nRspackAppOptions#\n\n\n\nInterfaz de opciones de configuración de aplicación Rspack:\n\n * css: Método de salida CSS, opciones 'css' (archivo independiente) o 'style'\n   (estilos en línea)\n * loaders: Configuración personalizada de loaders\n * styleLoader: Opciones de configuración de style-loader\n * cssLoader: Opciones de configuración de css-loader\n * target: Configuración de compatibilidad del objetivo de construcción\n * definePlugin: Definición de constantes globales\n * config: Función de enlace de configuración\n\n\nRspackHtmlAppOptions#\n\nHereda de RspackAppOptions, utilizado para configurar opciones específicas de\naplicaciones HTML.\n\n\nExportación de Funciones#\n\n\ncreateRspackApp#\n\n\n\nCrea una instancia de aplicación Rspack estándar.\n\nParámetros:\n\n * gez: Instancia del framework Gez\n * options: Opciones de configuración de aplicación Rspack\n\nValor de retorno:\n\n * Devuelve una Promise que se resuelve en la instancia de aplicación creada\n\n\ncreateRspackHtmlApp#\n\n\n\nCrea una instancia de aplicación Rspack de tipo HTML.\n\nParámetros:\n\n * gez: Instancia del framework Gez\n * options: Opciones de configuración de aplicación HTML\n\nValor de retorno:\n\n * Devuelve una Promise que se resuelve en la instancia de aplicación HTML\n   creada\n\n\nExportación de Constantes#\n\n\nRSPACK_LOADER#\n\n\n\nObjeto de mapeo de identificadores de loaders integrados en Rspack, proporciona\nconstantes de nombres de loaders comunes:\n\n * builtinSwcLoader: SWC loader integrado en Rspack, utilizado para procesar\n   archivos TypeScript/JavaScript\n * lightningcssLoader: lightningcss loader integrado en Rspack, utilizado para\n   compilar archivos CSS de alto rendimiento\n * styleLoader: Loader utilizado para inyectar CSS en el DOM\n * cssLoader: Loader utilizado para analizar archivos CSS y manejar la\n   modularización de CSS\n * lessLoader: Loader utilizado para compilar archivos Less a CSS\n * styleResourcesLoader: Loader utilizado para importar automáticamente recursos\n   de estilo globales (como variables, mixins)\n * workerRspackLoader: Loader utilizado para procesar archivos de Web Worker\n\nUtilizar estas constantes permite referenciar loaders integrados en la\nconfiguración, evitando la entrada manual de cadenas:\n\n\n\nNotas:\n\n * Estos loaders ya están integrados en Rspack, no es necesario instalarlos\n   adicionalmente\n * Al configurar loaders personalizados, se pueden usar estas constantes para\n   reemplazar la implementación predeterminada del loader\n * Algunos loaders (como builtinSwcLoader) tienen opciones de configuración\n   específicas, consulta la documentación correspondiente\n\n\nExportación de Módulos#\n\n\nrspack#\n\nReexporta todo el contenido del paquete @rspack/core, proporcionando la\nfuncionalidad completa del núcleo de Rspack.","routePath":"/es/api/app/rspack","lang":"es","toc":[{"text":"Instalación","id":"instalación","depth":2,"charIndex":184},{"text":"Exportación de Tipos","id":"exportación-de-tipos","depth":2,"charIndex":285},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":309},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":718},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1101},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1618},{"text":"Exportación de Funciones","id":"exportación-de-funciones","depth":2,"charIndex":1740},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1768},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":2046},{"text":"Exportación de Constantes","id":"exportación-de-constantes","depth":2,"charIndex":2338},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2367},{"text":"Exportación de Módulos","id":"exportación-de-módulos","depth":2,"charIndex":3674},{"text":"rspack","id":"rspack","depth":3,"charIndex":3700}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rspack Build Tool","description":"La herramienta de construcción Rspack del framework Gez ofrece capacidades de construcción de aplicaciones de alto rendimiento, soportando el desarrollo y construcción de aplicaciones estándar y aplicaciones HTML, con múltiples procesadores de recursos y configuraciones de optimización integradas.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, herramienta de construcción, construcción de aplicaciones, aplicación HTML, TypeScript, CSS, procesamiento de recursos, optimización de rendimiento"}]]},"version":""},{"id":52,"title":"App","content":"#\n\nApp es la abstracción de la aplicación en el framework Gez, que proporciona una\ninterfaz unificada para gestionar el ciclo de vida de la aplicación, los\nrecursos estáticos y la renderización del lado del servidor.\n\n\n\n\nDefinición de tipos#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Tipo: Middleware\n\nMiddleware para el manejo de recursos estáticos.\n\nEntorno de desarrollo:\n\n * Maneja las solicitudes de recursos estáticos del código fuente\n * Soporta compilación en tiempo real y actualización en caliente\n * Utiliza una política de caché no-cache\n\nEntorno de producción:\n\n * Maneja los recursos estáticos después de la construcción\n * Soporta caché a largo plazo para archivos inmutables (.final.xxx)\n * Estrategia optimizada para la carga de recursos\n\n\n\nrender#\n\n * Tipo: (options?: RenderContextOptions) => Promise\n\nFunción de renderización del lado del servidor. Proporciona diferentes\nimplementaciones según el entorno:\n\n * Entorno de producción (start): Carga el archivo de entrada del servidor\n   construido (entry.server) y ejecuta la renderización\n * Entorno de desarrollo (dev): Carga el archivo de entrada del servidor desde\n   el código fuente y ejecuta la renderización\n\n\n\nbuild#\n\n * Tipo: () => Promise\n\nFunción de construcción para el entorno de producción. Se utiliza para\nempaquetar y optimizar recursos. Devuelve true si la construcción es exitosa,\nfalse en caso de fallo.\n\ndestroy#\n\n * Tipo: () => Promise\n\nFunción de limpieza de recursos. Se utiliza para cerrar servidores, desconectar\nconexiones, etc. Devuelve true si la limpieza es exitosa, false en caso de\nfallo.\n\n","routePath":"/es/api/core/app","lang":"es","toc":[{"text":"Definición de tipos","id":"definición-de-tipos","depth":2,"charIndex":220},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":251},{"text":"render","id":"render","depth":4,"charIndex":741},{"text":"build","id":"build","depth":4,"charIndex":1171},{"text":"destroy","id":"destroy","depth":4,"charIndex":1377}],"domain":"","frontmatter":{"titleSuffix":"Interfaz de abstracción de aplicaciones del framework Gez","description":"Detalles sobre la interfaz App del framework Gez, incluyendo la gestión del ciclo de vida de la aplicación, el manejo de recursos estáticos y la renderización del lado del servidor, para ayudar a los desarrolladores a comprender y utilizar las funciones principales de la aplicación.","head":[["meta",{"property":"keywords","content":"Gez, App, abstracción de aplicación, ciclo de vida, recursos estáticos, renderización del lado del servidor, API"}]]},"version":""},{"id":53,"title":"Gez","content":"#\n\n\nIntroducción#\n\nGez es un framework de aplicaciones web de alto rendimiento basado en Rspack,\nque ofrece una gestión completa del ciclo de vida de la aplicación, manejo de\nrecursos estáticos y capacidades de renderizado en el servidor.\n\n\nDefiniciones de tipos#\n\n\nRuntimeTarget#\n\n * Definición de tipo:\n\n\n\nTipos de entorno de ejecución de la aplicación:\n\n * client: Se ejecuta en el entorno del navegador, compatible con operaciones\n   DOM y API del navegador.\n * server: Se ejecuta en el entorno de Node.js, compatible con sistemas de\n   archivos y funcionalidades del servidor.\n\n\nImportMap#\n\n * Definición de tipo:\n\n\n\nTipo de mapeo de importación de módulos ES.\n\nSpecifierMap#\n\n * Definición de tipo:\n\n\n\nTipo de mapeo de identificadores de módulos, utilizado para definir las\nrelaciones de mapeo de rutas de importación de módulos.\n\nScopesMap#\n\n * Definición de tipo:\n\n\n\nTipo de mapeo de alcance, utilizado para definir las relaciones de mapeo de\nimportación de módulos en un alcance específico.\n\n\nCOMMAND#\n\n * Definición de tipo:\n\n\n\nEnumeración de tipos de comandos:\n\n * dev: Comando de entorno de desarrollo, inicia el servidor de desarrollo con\n   soporte para actualización en caliente.\n * build: Comando de construcción, genera los artefactos de construcción para el\n   entorno de producción.\n * preview: Comando de vista previa, inicia un servidor local de vista previa.\n * start: Comando de inicio, ejecuta el servidor de producción.\n\n\nOpciones de instancia#\n\nDefine las opciones de configuración centrales del framework Gez.\n\n\n\nroot#\n\n * Tipo: string\n * Valor predeterminado: process.cwd()\n\nRuta del directorio raíz del proyecto. Puede ser una ruta absoluta o relativa,\nlas rutas relativas se resuelven basándose en el directorio de trabajo actual.\n\nisProd#\n\n * Tipo: boolean\n * Valor predeterminado: process.env.NODE_ENV === 'production'\n\nIdentificador de entorno.\n\n * true: Entorno de producción.\n * false: Entorno de desarrollo.\n\nbasePathPlaceholder#\n\n * Tipo: string | false\n * Valor predeterminado: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nConfiguración del marcador de posición de la ruta base. Se utiliza para\nreemplazar dinámicamente la ruta base de los recursos en tiempo de ejecución.\nEstablecerlo en false desactiva esta funcionalidad.\n\nmodules#\n\n * Tipo: ModuleConfig\n\nOpciones de configuración de módulos. Se utiliza para configurar las reglas de\nresolución de módulos del proyecto, incluyendo alias de módulos, dependencias\nexternas, etc.\n\npacks#\n\n * Tipo: PackConfig\n\nOpciones de configuración de empaquetado. Se utiliza para empaquetar los\nartefactos de construcción en paquetes de software estándar en formato .tgz de\nnpm.\n\ndevApp#\n\n * Tipo: (gez: Gez) => Promise\n\nFunción de creación de la aplicación en el entorno de desarrollo. Solo se\nutiliza en el entorno de desarrollo, para crear instancias de la aplicación del\nservidor de desarrollo.\n\n\n\nserver#\n\n * Tipo: (gez: Gez) => Promise\n\nFunción de configuración del servidor. Se utiliza para configurar e iniciar el\nservidor HTTP, tanto en el entorno de desarrollo como en el de producción.\n\n\n\npostBuild#\n\n * Tipo: (gez: Gez) => Promise\n\nFunción de procesamiento posterior a la construcción. Se ejecuta después de\ncompletar la construcción del proyecto, y se puede utilizar para:\n\n * Ejecutar procesamiento adicional de recursos.\n * Operaciones de despliegue.\n * Generar archivos estáticos.\n * Enviar notificaciones de construcción.\n\n\nPropiedades de instancia#\n\n\nname#\n\n * Tipo: string\n * Solo lectura: true\n\nNombre del módulo actual, derivado de la configuración del módulo.\n\n\nvarName#\n\n * Tipo: string\n * Solo lectura: true\n\nNombre de variable JavaScript válido generado a partir del nombre del módulo.\n\n\nroot#\n\n * Tipo: string\n * Solo lectura: true\n\nRuta absoluta del directorio raíz del proyecto. Si la configuración de root es\nuna ruta relativa, se resuelve basándose en el directorio de trabajo actual.\n\n\nisProd#\n\n * Tipo: boolean\n * Solo lectura: true\n\nDetermina si el entorno actual es de producción. Prioriza el uso de la opción de\nconfiguración isProd, si no está configurado, se determina según\nprocess.env.NODE_ENV.\n\n\nbasePath#\n\n * Tipo: string\n * Solo lectura: true\n * Lanza: NotReadyError - Cuando el framework no está inicializado.\n\nObtiene la ruta base del módulo que comienza y termina con una barra diagonal.\nEl formato de retorno es /${name}/, donde name proviene de la configuración del\nmódulo.\n\n\nbasePathPlaceholder#\n\n * Tipo: string\n * Solo lectura: true\n\nObtiene el marcador de posición de la ruta base utilizado para el reemplazo\ndinámico en tiempo de ejecución. Se puede desactivar mediante configuración.\n\n\nmiddleware#\n\n * Tipo: Middleware\n * Solo lectura: true\n\nObtiene el middleware de manejo de recursos estáticos. Proporciona diferentes\nimplementaciones según el entorno:\n\n * Entorno de desarrollo: Soporta compilación en tiempo real y actualización en\n   caliente.\n * Entorno de producción: Soporta caché a largo plazo de recursos estáticos.\n\n\n\n\nrender#\n\n * Tipo: (options?: RenderContextOptions) => Promise\n * Solo lectura: true\n\nObtiene la función de renderizado en el servidor. Proporciona diferentes\nimplementaciones según el entorno:\n\n * Entorno de desarrollo: Soporta actualización en caliente y vista previa en\n   tiempo real.\n * Entorno de producción: Proporciona un rendimiento de renderizado optimizado.\n\n\n\n\nCOMMAND#\n\n * Tipo: typeof COMMAND\n * Solo lectura: true\n\nObtiene la definición del tipo de enumeración de comandos.\n\n\nmoduleConfig#\n\n * Tipo: ParsedModuleConfig\n * Solo lectura: true\n * Lanza: NotReadyError - Cuando el framework no está inicializado.\n\nObtiene la información completa de configuración del módulo actual, incluyendo\nreglas de resolución de módulos, configuración de alias, etc.\n\n\npackConfig#\n\n * Tipo: ParsedPackConfig\n * Solo lectura: true\n * Lanza: NotReadyError - Cuando el framework no está inicializado.\n\nObtiene la configuración relacionada con el empaquetado del módulo actual,\nincluyendo rutas de salida, procesamiento de package.json, etc.\n\n\nMétodos de instancia#\n\n\nconstructor()#\n\n * Parámetros:\n   * options?: GezOptions - Opciones de configuración del framework.\n * Retorna: Gez\n\nCrea una instancia del framework Gez.\n\n\n\n\ninit()#\n\n * Parámetros: command: COMMAND\n * Retorna: Promise\n * Lanza:\n   * Error: Cuando se intenta inicializar repetidamente.\n   * NotReadyError: Cuando se accede a una instancia no inicializada.\n\nInicializa la instancia del framework Gez. Ejecuta los siguientes procesos\ncentrales de inicialización:\n\n 1. Analiza la configuración del proyecto (package.json, configuración de\n    módulos, configuración de empaquetado, etc.).\n 2. Crea la instancia de la aplicación (entorno de desarrollo o producción).\n 3. Ejecuta los métodos del ciclo de vida correspondientes según el comando.\n\nNota\n * Lanza un error si se intenta inicializar repetidamente.\n * Lanza NotReadyError si se accede a una instancia no inicializada.\n\n\n\n\ndestroy()#\n\n * Retorna: Promise\n\nDestruye la instancia del framework Gez, ejecuta la limpieza de recursos y el\ncierre de conexiones. Principalmente utilizado para:\n\n * Cerrar el servidor de desarrollo.\n * Limpiar archivos temporales y caché.\n * Liberar recursos del sistema.\n\n\n\n\nbuild()#\n\n * Retorna: Promise\n\nEjecuta el proceso de construcción de la aplicación, incluyendo:\n\n * Compilación del código fuente.\n * Generación de artefactos de construcción para el entorno de producción.\n * Optimización y compresión del código.\n * Generación del manifiesto de recursos.\n\nNota\n\nLanza NotReadyError si se llama antes de inicializar la instancia del framework.\n\n\n\n\nserver()#\n\n * Retorna: Promise\n * Lanza: NotReadyError - Cuando el framework no está inicializado.\n\nInicia el servidor HTTP y configura la instancia del servidor. Se llama en los\nsiguientes ciclos de vida:\n\n * Entorno de desarrollo (dev): Inicia el servidor de desarrollo con\n   actualización en caliente.\n * Entorno de producción (start): Inicia el servidor de producción con\n   rendimiento de nivel de producción.\n\n\n\n\npostBuild()#\n\n * Retorna: Promise\n\nEjecuta la lógica de procesamiento posterior a la construcción, utilizada para:\n\n * Generar archivos HTML estáticos.\n * Procesar los artefactos de construcción.\n * Ejecutar tareas de despliegue.\n * Enviar notificaciones de construcción.\n\n\n\n\nresolvePath#\n\nResuelve las rutas del proyecto, convierte rutas relativas en absolutas.\n\n * Parámetros:\n   \n   * projectPath: ProjectPath - Tipo de ruta del proyecto.\n   * ...args: string[] - Fragmentos de ruta.\n\n * Retorna: string - Ruta absoluta resuelta.\n\n * Ejemplo:\n\n\n\n\nwriteSync()#\n\nEscribe sincrónicamente el contenido de un archivo.\n\n * Parámetros:\n   \n   * filepath: string - Ruta absoluta del archivo.\n   * data: any - Datos a escribir, pueden ser cadenas, Buffer u objetos.\n\n * Retorna: boolean - Indica si la escritura fue exitosa.\n\n * Ejemplo:\n\n\n\n\nreadJsonSync()#\n\nLee y analiza sincrónicamente un archivo JSON.\n\n * Parámetros:\n   \n   * filename: string - Ruta absoluta del archivo JSON.\n\n * Retorna: any - Objeto JSON analizado.\n\n * Excepciones: Lanza una excepción si el archivo no existe o si el formato JSON\n   es incorrecto.\n\n * Ejemplo:\n\n\n\n\nreadJson()#\n\nLee y analiza asincrónicamente un archivo JSON.\n\n * Parámetros:\n   \n   * filename: string - Ruta absoluta del archivo JSON.\n\n * Retorna: Promise - Objeto JSON analizado.\n\n * Excepciones: Lanza una excepción si el archivo no existe o si el formato JSON\n   es incorrecto.\n\n * Ejemplo:\n\n\n\n\ngetManifestList()#\n\nObtiene la lista de manifiestos de construcción.\n\n * Parámetros:\n   \n   * target: RuntimeTarget - Tipo de entorno objetivo.\n     * 'client': Entorno del cliente.\n     * 'server': Entorno del servidor.\n\n * Retorna: Promise - Lista de manifiestos de construcción de solo lectura.\n\n * Excepciones: Lanza NotReadyError si la instancia del framework no está\n   inicializada.\n\nEste método se utiliza para obtener la lista de manifiestos de construcción para\nel entorno objetivo especificado, incluyendo las siguientes funcionalidades:\n\n 1. Gestión de caché\n    \n    * Utiliza un mecanismo de caché interno para evitar cargas repetidas.\n    * Retorna una lista de manifiestos inmutable.\n\n 2. Adaptación al entorno\n    \n    * Soporta entornos de cliente y servidor.\n    * Retorna la información de manifiesto correspondiente según el entorno\n      objetivo.\n\n 3. Mapeo de módulos\n    \n    * Incluye información","routePath":"/es/api/core/gez","lang":"es","toc":[{"text":"Introducción","id":"introducción","depth":2,"charIndex":3},{"text":"Definiciones de tipos","id":"definiciones-de-tipos","depth":2,"charIndex":240},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":265},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":583},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":666},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":836},{"text":"COMMAND","id":"command","depth":3,"charIndex":1001},{"text":"Opciones de instancia","id":"opciones-de-instancia","depth":2,"charIndex":1446},{"text":"root","id":"root","depth":4,"charIndex":1539},{"text":"isProd","id":"isprod","depth":4,"charIndex":1761},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1944},{"text":"modules","id":"modules","depth":4,"charIndex":2250},{"text":"packs","id":"packs","depth":4,"charIndex":2456},{"text":"devApp","id":"devapp","depth":4,"charIndex":2643},{"text":"server","id":"server","depth":4,"charIndex":2865},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":3063},{"text":"Propiedades de instancia","id":"propiedades-de-instancia","depth":2,"charIndex":3404},{"text":"name","id":"name","depth":3,"charIndex":3432},{"text":"varName","id":"varname","depth":3,"charIndex":3547},{"text":"root","id":"root-1","depth":3,"charIndex":3676},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3880},{"text":"basePath","id":"basepath","depth":3,"charIndex":4099},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":4386},{"text":"middleware","id":"middleware","depth":3,"charIndex":4602},{"text":"render","id":"render","depth":3,"charIndex":4946},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":5318},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":5436},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":5713},{"text":"Métodos de instancia","id":"métodos-de-instancia","depth":2,"charIndex":5984},{"text":"constructor()","id":"constructor","depth":3,"charIndex":6008},{"text":"init()","id":"init","depth":3,"charIndex":6167},{"text":"destroy()","id":"destroy","depth":3,"charIndex":6887},{"text":"build()","id":"build","depth":3,"charIndex":7166},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":8243},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":8517},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":8803},{"text":"readJson()","id":"readjson","depth":3,"charIndex":9102},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":9402}],"domain":"","frontmatter":{"titleSuffix":"Referencia de API de las clases principales del framework","description":"Documentación detallada de las API de las clases principales del framework Gez, incluyendo la gestión del ciclo de vida de la aplicación, el manejo de recursos estáticos y la capacidad de renderizado en el servidor, para ayudar a los desarrolladores a comprender en profundidad las funcionalidades centrales del framework.","head":[["meta",{"property":"keywords","content":"Gez, API, Gestión del ciclo de vida, Recursos estáticos, Renderizado en el servidor, Rspack, Framework de aplicaciones web"}]]},"version":""},{"id":54,"title":"ManifestJson","content":"#\n\nmanifest.json es un archivo de manifiesto generado por el framework Gez durante\nel proceso de construcción, utilizado para registrar la información de los\nartefactos generados en la construcción del servicio. Proporciona una interfaz\nunificada para gestionar los artefactos de construcción, los archivos exportados\ny las estadísticas de tamaño de los recursos.\n\n\n\n\nDefinición de tipos#\n\n\nManifestJson#\n\n\n\nname#\n\n * Tipo: string\n\nNombre del servicio, proviene de la configuración GezOptions.name.\n\nexports#\n\n * Tipo: Record\n\nRelación de mapeo de archivos exportados, donde la clave es la ruta del archivo\nfuente y el valor es la ruta del archivo construido.\n\nbuildFiles#\n\n * Tipo: string[]\n\nLista completa de archivos de artefactos de construcción, incluyendo todas las\nrutas de archivos generados.\n\nchunks#\n\n * Tipo: Record\n\nRelación entre los archivos fuente y los artefactos compilados, donde la clave\nes la ruta del archivo fuente y el valor es la información de compilación.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Tipo: string\n\nRuta del archivo JS compilado a partir del archivo fuente actual.\n\ncss#\n\n * Tipo: string[]\n\nLista de rutas de archivos CSS asociados al archivo fuente actual.\n\nresources#\n\n * Tipo: string[]\n\nLista de rutas de otros archivos de recursos asociados al archivo fuente actual.\n\nsizes#\n\n * Tipo: ManifestJsonChunkSizes\n\nInformación de estadísticas de tamaño de los artefactos de construcción.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Tipo: number\n\nTamaño del archivo JS (en bytes).\n\ncss#\n\n * Tipo: number\n\nTamaño del archivo CSS (en bytes).\n\nresource#\n\n * Tipo: number\n\nTamaño del archivo de recursos (en bytes).","routePath":"/es/api/core/manifest-json","lang":"es","toc":[{"text":"Definición de tipos","id":"definición-de-tipos","depth":2,"charIndex":367},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":407},{"text":"exports","id":"exports","depth":4,"charIndex":499},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":660},{"text":"chunks","id":"chunks","depth":4,"charIndex":801},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":983},{"text":"js","id":"js","depth":4,"charIndex":1006},{"text":"css","id":"css","depth":4,"charIndex":1095},{"text":"resources","id":"resources","depth":4,"charIndex":1188},{"text":"sizes","id":"sizes","depth":4,"charIndex":1301},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1417},{"text":"js","id":"js-1","depth":4,"charIndex":1444},{"text":"css","id":"css-1","depth":4,"charIndex":1501},{"text":"resource","id":"resource","depth":4,"charIndex":1560}],"domain":"","frontmatter":{"titleSuffix":"Referencia del archivo de manifiesto de construcción del framework Gez","description":"Descripción detallada de la estructura del archivo de manifiesto de construcción (manifest.json) del framework Gez, incluyendo la gestión de artefactos de construcción, mapeo de archivos exportados y estadísticas de recursos, para ayudar a los desarrolladores a comprender y utilizar el sistema de construcción.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, Manifiesto de construcción, Gestión de recursos, Artefactos de construcción, Mapeo de archivos, API"}]]},"version":""},{"id":55,"title":"ModuleConfig","content":"#\n\nModuleConfig proporciona la funcionalidad de configuración de módulos en el\nframework Gez, utilizada para definir reglas de importación/exportación de\nmódulos, configuración de alias y dependencias externas.\n\n\nDefinición de tipos#\n\n\nPathType#\n\n * Definición de tipo:\n\n\n\nEnumeración de tipos de rutas de módulos:\n\n * npm: Representa dependencias en node_modules\n * root: Representa archivos en el directorio raíz del proyecto\n\n\nModuleConfig#\n\n * Definición de tipo:\n\n\n\nInterfaz de configuración de módulos, utilizada para definir la exportación,\nimportación y configuración de dependencias externas del servicio.\n\nexports#\n\nLista de configuración de exportaciones, expone unidades de código específicas\n(como componentes, funciones utilitarias, etc.) del servicio en formato ESM.\n\nSoporta dos tipos:\n\n * root:*: Exporta archivos de código fuente, ej.:\n   'root:src/components/button.vue'\n * npm:*: Exporta dependencias de terceros, ej.: 'npm:vue'\n\nimports#\n\nMapeo de configuración de importaciones, configura módulos remotos a importar y\nsus rutas locales.\n\nLa configuración varía según el método de instalación:\n\n * Instalación desde código fuente (Workspace, Git): debe apuntar al directorio\n   dist\n * Instalación desde paquete (Link, servidor estático, repositorio privado,\n   File): apunta directamente al directorio del paquete\n\nexternals#\n\nMapeo de dependencias externas, configura dependencias externas a utilizar,\ngeneralmente dependencias de módulos remotos.\n\nEjemplo:\n\n\n\n\nParsedModuleConfig#\n\n * Definición de tipo:\n\n\n\nConfiguración de módulos analizada, convierte la configuración original de\nmódulos a un formato interno estandarizado:\n\nname#\n\nNombre del servicio actual\n\n * Se utiliza para identificar módulos y generar rutas de importación\n\nroot#\n\nRuta del directorio raíz del servicio actual\n\n * Se utiliza para resolver rutas relativas y almacenar artefactos de\n   construcción\n\nexports#\n\nLista de configuración de exportaciones\n\n * name: Ruta de exportación original, ej.: 'npm:vue' o 'root:src/components'\n * type: Tipo de ruta (npm o root)\n * importName: Nombre de importación, formato: '${serviceName}/${type}/${path}'\n * exportName: Ruta de exportación, relativa al directorio raíz del servicio\n * exportPath: Ruta real del archivo\n * externalName: Nombre de dependencia externa, utilizado como identificador\n   cuando otros servicios importan este módulo\n\nimports#\n\nLista de configuración de importaciones\n\n * name: Nombre del servicio externo\n * localPath: Ruta de almacenamiento local, utilizada para almacenar artefactos\n   de construcción de módulos externos\n\nexternals#\n\nMapeo de dependencias externas\n\n * Mapea rutas de importación de módulos a su ubicación real\n * match: Expresión regular para coincidir con declaraciones de importación\n * import: Ruta real del módulo","routePath":"/es/api/core/module-config","lang":"es","toc":[{"text":"Definición de tipos","id":"definición-de-tipos","depth":2,"charIndex":212},{"text":"PathType","id":"pathtype","depth":3,"charIndex":235},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":615},{"text":"imports","id":"imports","depth":4,"charIndex":949},{"text":"externals","id":"externals","depth":4,"charIndex":1336},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1484},{"text":"name","id":"name","depth":4,"charIndex":1651},{"text":"root","id":"root","depth":4,"charIndex":1757},{"text":"exports","id":"exports-1","depth":4,"charIndex":1897},{"text":"imports","id":"imports-1","depth":4,"charIndex":2380},{"text":"externals","id":"externals-1","depth":4,"charIndex":2588}],"domain":"","frontmatter":{"titleSuffix":"Referencia de la API de configuración de módulos del framework Gez","description":"Documentación detallada de la interfaz de configuración ModuleConfig del framework Gez, incluyendo reglas de importación/exportación de módulos, configuración de alias y gestión de dependencias externas, para ayudar a los desarrolladores a comprender en profundidad el sistema modular del framework.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, configuración de módulos, importación/exportación de módulos, dependencias externas, configuración de alias, gestión de dependencias, framework de aplicaciones web"}]]},"version":""},{"id":56,"title":"PackConfig","content":"#\n\nPackConfig es una interfaz de configuración para empaquetar paquetes, utilizada\npara empaquetar los artefactos de construcción de un servicio en un paquete\nestándar npm en formato .tgz.\n\n * Estandarización: Utiliza el formato de empaquetado .tgz estándar de npm\n * Integridad: Incluye todos los archivos necesarios como código fuente,\n   declaraciones de tipos y archivos de configuración\n * Compatibilidad: Totalmente compatible con el ecosistema de npm, soporta\n   flujos de trabajo estándar de gestión de paquetes\n\n\nDefinición de tipos#\n\n\n\n\nPackConfig#\n\nenable#\n\nHabilita o deshabilita la función de empaquetado. Cuando está habilitado, los\nartefactos de construcción se empaquetan en un paquete npm estándar en formato\n.tgz.\n\n * Tipo: boolean\n * Valor por defecto: false\n\noutputs#\n\nEspecifica la ruta de salida del archivo del paquete. Soporta las siguientes\nconfiguraciones:\n\n * string: Una única ruta de salida, por ejemplo 'dist/versions/my-app.tgz'\n * string[]: Múltiples rutas de salida, para generar varias versiones\n   simultáneamente\n * boolean: Cuando es true, utiliza la ruta por defecto\n   'dist/client/versions/latest.tgz'\n\npackageJson#\n\nFunción de callback para personalizar el contenido de package.json. Se llama\nantes del empaquetado para personalizar el contenido de package.json.\n\n * Parámetros:\n   * gez: Gez - Instancia de Gez\n   * pkg: any - Contenido original de package.json\n * Valor de retorno: Promise - Contenido modificado de package.json\n\nUsos comunes:\n\n * Modificar el nombre y la versión del paquete\n * Agregar o actualizar dependencias\n * Agregar campos personalizados\n * Configurar información de publicación\n\nEjemplo:\n\n\n\nonBefore#\n\nFunción de callback para preparativos antes del empaquetado.\n\n * Parámetros:\n   * gez: Gez - Instancia de Gez\n   * pkg: Record - Contenido de package.json\n * Valor de retorno: Promise\n\nUsos comunes:\n\n * Agregar archivos adicionales (README, LICENSE, etc.)\n * Ejecutar pruebas o validaciones de construcción\n * Generar documentación o metadatos\n * Limpiar archivos temporales\n\nEjemplo:\n\n\n\nonAfter#\n\nFunción de callback para procesamiento posterior al empaquetado. Se llama\ndespués de generar el archivo .tgz, para manejar los artefactos empaquetados.\n\n * Parámetros:\n   * gez: Gez - Instancia de Gez\n   * pkg: Record - Contenido de package.json\n   * file: Buffer - Contenido del archivo empaquetado\n * Valor de retorno: Promise\n\nUsos comunes:\n\n * Publicar en un repositorio npm (público o privado)\n * Subir a un servidor de recursos estáticos\n * Gestionar versiones\n * Activar flujos de CI/CD\n\nEjemplo:\n\n\n\n\nEjemplo de uso#\n\n","routePath":"/es/api/core/pack-config","lang":"es","toc":[{"text":"Definición de tipos","id":"definición-de-tipos","depth":2,"charIndex":521},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":559},{"text":"outputs","id":"outputs","depth":4,"charIndex":778},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":1142},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1659},{"text":"onAfter","id":"onafter","depth":4,"charIndex":2058},{"text":"Ejemplo de uso","id":"ejemplo-de-uso","depth":2,"charIndex":2576}],"domain":"","frontmatter":{"titleSuffix":"Referencia de API de configuración de empaquetado del framework Gez","description":"Documentación detallada de la interfaz de configuración PackConfig del framework Gez, incluyendo reglas de empaquetado de paquetes, configuración de salida y hooks del ciclo de vida, para ayudar a los desarrolladores a implementar flujos de construcción estandarizados.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, empaquetado de paquetes, configuración de construcción, hooks del ciclo de vida, configuración de empaquetado, framework de aplicaciones web"}]]},"version":""},{"id":57,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/es/api/core/render-context","lang":"es","toc":[{"text":"Definiciones de tipos","id":"definiciones-de-tipos","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Opciones de instancia","id":"opciones-de-instancia","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Propiedades de instancia","id":"propiedades-de-instancia","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Métodos de instancia","id":"métodos-de-instancia","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1},{"text":"importmap()","id":"importmap","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Referencia de la API de Contexto de Renderizado del Framework Gez","description":"Detalles sobre la clase principal RenderContext del framework Gez, incluyendo control de renderizado, gestión de recursos, sincronización de estado y control de rutas, para ayudar a los desarrolladores a implementar renderizado del lado del servidor (SSR) eficiente.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, Renderizado del lado del servidor, Contexto de renderizado, Sincronización de estado, Gestión de recursos, Framework de aplicaciones web"}]]},"version":""},{"id":58,"title":"De la compartición de componentes a la modularización nativa: El camino evolutivo del framework de microfrontends Gez","content":"De la compartición de componentes a la modularización nativa: El camino\nevolutivo del framework de microfrontends Gez#\n\n\nContexto del proyecto#\n\nEn los últimos años, las arquitecturas de microfrontends han estado buscando un\ncamino correcto. Sin embargo, lo que hemos visto son diversas soluciones\ntécnicas complejas que utilizan capas de envoltura y aislamiento artificial para\nsimular un mundo ideal de microfrontends. Estas soluciones han traído una carga\npesada en términos de rendimiento, haciendo que el desarrollo simple se vuelva\ncomplejo y que los flujos estándar se vuelvan oscuros.\n\n\nLimitaciones de las soluciones tradicionales#\n\nEn la práctica de las arquitecturas de microfrontends, hemos experimentado\nprofundamente las numerosas limitaciones de las soluciones tradicionales:\n\n * Pérdida de rendimiento: Inyección de dependencias en tiempo de ejecución,\n   proxies de sandbox de JS, cada operación consume un rendimiento valioso.\n * Aislamiento frágil: Entornos de sandbox creados artificialmente, que nunca\n   pueden alcanzar las capacidades de aislamiento nativas del navegador.\n * Complejidad de construcción: Para manejar las relaciones de dependencia, se\n   tuvo que modificar las herramientas de construcción, haciendo que los\n   proyectos simples sean difíciles de mantener.\n * Reglas personalizadas: Estrategias de implementación especiales,\n   procesamiento en tiempo de ejecución, cada paso se desvía de los flujos\n   estándar de desarrollo moderno.\n * Limitaciones del ecosistema: Acoplamiento de frameworks, APIs personalizadas,\n   lo que obliga a la selección técnica a estar vinculada a un ecosistema\n   específico.\n\nEstos problemas fueron especialmente evidentes en un proyecto empresarial en\n2019. En ese momento, un gran producto se dividió en más de diez subsistemas de\nnegocio independientes, que necesitaban compartir un conjunto de componentes\nbásicos y de negocio. La solución inicial de compartición de componentes basada\nen paquetes npm reveló serios problemas de eficiencia de mantenimiento: cuando\nse actualizaban los componentes compartidos, todos los subsistemas que dependían\nde ellos tenían que pasar por un proceso completo de construcción e\nimplementación.\n\n\nEvolución técnica#\n\n\nv1.0: Exploración de componentes remotos#\n\nPara resolver el problema de eficiencia en la compartición de componentes, Gez\nv1.0 introdujo el mecanismo de componentes RemoteView basado en el protocolo\nHTTP. Esta solución implementó el ensamblaje dinámico de código entre servicios\nen tiempo de ejecución, resolviendo con éxito el problema de las largas cadenas\nde dependencias de construcción. Sin embargo, debido a la falta de un mecanismo\nestandarizado de comunicación en tiempo de ejecución, la sincronización de\nestado y la transferencia de eventos entre servicios aún presentaban cuellos de\nbotella en términos de eficiencia.\n\n\nv2.0: Intento de Federación de Módulos#\n\nEn la versión v2.0, adoptamos la tecnología de Federación de Módulos (Module\nFederation) de Webpack 5.0. Esta tecnología, a través de un mecanismo unificado\nde carga de módulos y contenedores en tiempo de ejecución, mejoró\nsignificativamente la eficiencia de colaboración entre servicios. Sin embargo,\nen la práctica a gran escala, el mecanismo cerrado de implementación de la\nFederación de Módulos presentó nuevos desafíos: era difícil lograr una gestión\nprecisa de versiones de dependencias, especialmente al unificar dependencias\ncompartidas entre múltiples servicios, donde frecuentemente se encontraban\nconflictos de versiones y excepciones en tiempo de ejecución.\n\n\nAbrazando la nueva era de ESM#\n\nAl planificar la versión v3.0, observamos profundamente las tendencias de\ndesarrollo del ecosistema frontend y descubrimos que los avances en las\ncapacidades nativas del navegador ofrecían nuevas posibilidades para las\narquitecturas de microfrontends:\n\n\nSistema de módulos estandarizado#\n\nCon el soporte completo de los principales navegadores para ES Modules y la\nmadurez de la especificación Import Maps, el desarrollo frontend ha entrado en\nuna verdadera era de modularización. Según las estadísticas de Can I Use, el\nsoporte nativo de ESM en los principales navegadores (Chrome >= 89, Edge >= 89,\nFirefox >= 108, Safari >= 16.4) ha alcanzado el 93.5%, lo que nos proporciona\nlas siguientes ventajas:\n\n * Gestión de dependencias estandarizada: Import Maps ofrece la capacidad de\n   resolver dependencias de módulos a nivel del navegador, sin necesidad de\n   inyección compleja en tiempo de ejecución.\n * Optimización de carga de recursos: El mecanismo de caché de módulos nativo\n   del navegador mejora significativamente la eficiencia de carga de recursos.\n * Simplificación del flujo de construcción: El modo de desarrollo basado en ESM\n   hace que los flujos de construcción en entornos de desarrollo y producción\n   sean más consistentes.\n\nAdemás, con el soporte de modo de compatibilidad (Chrome >= 87, Edge >= 88,\nFirefox >= 78, Safari >= 14), podemos aumentar la cobertura de navegadores al\n96.81%, lo que nos permite mantener un alto rendimiento sin sacrificar el\nsoporte para navegadores antiguos.\n\n\nAvances en rendimiento y aislamiento#\n\nEl sistema de módulos nativo no solo trae estandarización, sino también mejoras\nsignificativas en rendimiento y aislamiento:\n\n * Cero sobrecarga en tiempo de ejecución: Se eliminan los proxies de sandbox de\n   JavaScript y la inyección en tiempo de ejecución de las soluciones\n   tradicionales de microfrontends.\n * Mecanismo de aislamiento confiable: El ámbito estricto de los módulos ESM\n   proporciona naturalmente la capacidad de aislamiento más confiable.\n * Gestión precisa de dependencias: El análisis estático de importaciones hace\n   que las relaciones de dependencia sean más claras y el control de versiones\n   más preciso.\n\n\nSelección de herramientas de construcción#\n\nEn la implementación de la solución técnica, la selección de herramientas de\nconstrucción fue un punto de decisión clave. Después de casi un año de\ninvestigación y práctica técnica, nuestra elección evolucionó de la siguiente\nmanera:\n\n 1. Exploración de Vite\n    \n    * Ventaja: Servidor de desarrollo basado en ESM, proporcionando una\n      experiencia de desarrollo extrema.\n    * Desafío: Las diferencias en la construcción entre entornos de desarrollo y\n      producción introdujeron cierta incertidumbre.\n\n 2. Establecimiento de Rspack\n    \n    * Ventaja de rendimiento: Compilación de alto rendimiento basada en Rust,\n      mejorando significativamente la velocidad de construcción.\n    * Soporte del ecosistema: Alta compatibilidad con el ecosistema de Webpack,\n      reduciendo los costos de migración.\n    * Soporte de ESM: A través de la práctica del proyecto Rslib, se validó su\n      fiabilidad en la construcción basada en ESM.\n\nEsta decisión nos permitió mantener la experiencia de desarrollo mientras\nobteníamos un soporte más estable para el entorno de producción. Basándonos en\nla combinación de ESM y Rspack, finalmente construimos una solución de\nmicrofrontends de alto rendimiento y baja intrusividad.\n\n\nPerspectivas futuras#\n\nEn el plan de desarrollo futuro, el framework Gez se centrará en las siguientes\ntres direcciones:\n\n\nOptimización profunda de Import Maps#\n\n * Gestión dinámica de dependencias: Implementar la programación inteligente de\n   versiones de dependencias en tiempo de ejecución, resolviendo conflictos de\n   dependencias entre múltiples aplicaciones.\n * Estrategias de precarga: Precarga inteligente basada en análisis de rutas,\n   mejorando la eficiencia de carga de recursos.\n * Optimización de construcción: Generación automática de configuraciones\n   óptimas de Import Maps, reduciendo los costos de configuración manual para\n   los desarrolladores.\n\n\nSolución de enrutamiento independiente del framework#\n\n * Abstracción unificada de enrutamiento: Diseñar una interfaz de enrutamiento\n   independiente del framework, compatible con Vue, React y otros frameworks\n   principales.\n * Enrutamiento de microaplicaciones: Implementar la interconexión de rutas\n   entre aplicaciones, manteniendo la consistencia entre la URL y el estado de\n   la aplicación.\n * Middleware de enrutamiento: Proporcionar un mecanismo de middleware\n   extensible, soportando control de permisos, transiciones de página, etc.\n\n\nMejores prácticas de comunicación entre frameworks#\n\n * Aplicación de ejemplo: Proporcionar un ejemplo completo de comunicación entre\n   frameworks, cubriendo Vue, React, Preact y otros frameworks principales.\n * Sincronización de estado: Solución ligera de compartición de estado basada en\n   ESM.\n * Bus de eventos: Mecanismo estandarizado de comunicación de eventos,\n   soportando comunicación desacoplada entre aplicaciones.\n\nCon estas optimizaciones y extensiones, esperamos que Gez se convierta en una\nsolución de microfrontends más completa y fácil de usar, proporcionando a los\ndesarrolladores una mejor experiencia de desarrollo y una mayor eficiencia.","routePath":"/es/blog/birth-of-gez","lang":"es","toc":[{"text":"Contexto del proyecto","id":"contexto-del-proyecto","depth":2,"charIndex":120},{"text":"Limitaciones de las soluciones tradicionales","id":"limitaciones-de-las-soluciones-tradicionales","depth":3,"charIndex":594},{"text":"Evolución técnica","id":"evolución-técnica","depth":2,"charIndex":2205},{"text":"v1.0: Exploración de componentes remotos","id":"v10-exploración-de-componentes-remotos","depth":3,"charIndex":2226},{"text":"v2.0: Intento de Federación de Módulos","id":"v20-intento-de-federación-de-módulos","depth":3,"charIndex":2857},{"text":"Abrazando la nueva era de ESM","id":"abrazando-la-nueva-era-de-esm","depth":2,"charIndex":3570},{"text":"Sistema de módulos estandarizado","id":"sistema-de-módulos-estandarizado","depth":3,"charIndex":3856},{"text":"Avances en rendimiento y aislamiento","id":"avances-en-rendimiento-y-aislamiento","depth":3,"charIndex":5114},{"text":"Selección de herramientas de construcción","id":"selección-de-herramientas-de-construcción","depth":3,"charIndex":5790},{"text":"Perspectivas futuras","id":"perspectivas-futuras","depth":2,"charIndex":7058},{"text":"Optimización profunda de Import Maps","id":"optimización-profunda-de-import-maps","depth":3,"charIndex":7181},{"text":"Solución de enrutamiento independiente del framework","id":"solución-de-enrutamiento-independiente-del-framework","depth":3,"charIndex":7730},{"text":"Mejores prácticas de comunicación entre frameworks","id":"mejores-prácticas-de-comunicación-entre-frameworks","depth":3,"charIndex":8279}],"domain":"","frontmatter":{"titleSuffix":"De los desafíos de los microfrontends a la innovación con ESM: El camino evolutivo del framework Gez","description":"Explora en profundidad la evolución del framework Gez desde los desafíos de las arquitecturas tradicionales de microfrontends hasta los avances innovadores basados en ESM, compartiendo experiencias prácticas en optimización de rendimiento, gestión de dependencias y selección de herramientas de construcción.","head":[["meta",{"property":"keywords","content":"Gez, framework de microfrontends, ESM, Import Maps, Rspack, Federación de Módulos, gestión de dependencias, optimización de rendimiento, evolución técnica, renderizado en el servidor"}]],"sidebar":false},"version":""},{"id":59,"title":"Blog del equipo","content":"#\n\n¡Bienvenidos al blog técnico del equipo Gez! Aquí compartiremos experiencias,\ninnovaciones tecnológicas y mejores prácticas en el desarrollo de frameworks.\n\n\nArtículos recientes#\n\n * 2025-02-25 Del intercambio de componentes a la modularización nativa: El\n   camino evolutivo del framework de microfrontends Gez\n   \n   > Explora el recorrido evolutivo del framework Gez desde el intercambio\n   > tradicional de componentes hasta la modularización nativa basada en ESM,\n   > compartiendo experiencias prácticas en optimización de rendimiento, gestión\n   > de dependencias y selección de herramientas de construcción.","routePath":"/es/blog/","lang":"es","toc":[{"text":"Artículos recientes","id":"artículos-recientes","depth":2,"charIndex":160}],"domain":"","frontmatter":{"titleSuffix":"Blog del equipo Gez","description":"Blog técnico del equipo Gez, compartiendo experiencias en desarrollo de frameworks, mejores prácticas e innovaciones tecnológicas.","head":[["meta",{"property":"keywords","content":"Gez, Blog del equipo, Compartir conocimientos, Mejores prácticas, Experiencia de desarrollo"}]],"sidebar":false},"version":""},{"id":60,"title":"Alias de Rutas","content":"#\n\nEl alias de rutas (Path Alias) es un mecanismo de mapeo de rutas de importación\nde módulos que permite a los desarrolladores utilizar identificadores cortos y\nsemánticos en lugar de rutas completas de módulos. En Gez, el mecanismo de alias\nde rutas ofrece las siguientes ventajas:\n\n * Simplificación de rutas de importación: Uso de alias semánticos en lugar de\n   rutas relativas largas, mejorando la legibilidad del código.\n * Evitación de anidamientos profundos: Elimina las dificultades de\n   mantenimiento causadas por referencias a directorios con múltiples niveles\n   (como ../../../../).\n * Seguridad de tipos: Integración completa con el sistema de tipos de\n   TypeScript, proporcionando autocompletado y verificación de tipos.\n * Optimización de resolución de módulos: Mejora el rendimiento de la resolución\n   de módulos mediante mapeos de rutas predefinidos.\n\n\nMecanismo de Alias Predeterminado#\n\nGez utiliza un mecanismo de alias automático basado en el nombre del servicio\n(Service Name), un diseño que prioriza la convención sobre la configuración y\ntiene las siguientes características:\n\n * Configuración automática: Genera automáticamente alias basados en el campo\n   name en package.json, sin necesidad de configuración manual.\n * Normativa unificada: Asegura que todos los módulos de servicio sigan una\n   normativa consistente de nomenclatura y referencia.\n * Soporte de tipos: Junto con el comando npm run build:dts, genera\n   automáticamente archivos de declaración de tipos, permitiendo la inferencia\n   de tipos entre servicios.\n * Previsibilidad: Permite inferir la ruta de referencia de un módulo a través\n   del nombre del servicio, reduciendo los costos de mantenimiento.\n\n\nConfiguración#\n\n\nConfiguración en package.json#\n\nEn package.json, el nombre del servicio se define mediante el campo name, que\nservirá como prefijo predeterminado para los alias del servicio:\n\n\n\n\nConfiguración en tsconfig.json#\n\nPara que TypeScript pueda resolver correctamente las rutas de alias, es\nnecesario configurar el mapeo paths en tsconfig.json:\n\n\n\n\nEjemplos de Uso#\n\n\nImportación de módulos internos del servicio#\n\n\n\n\nImportación de módulos de otros servicios#\n\n\n\nMejores Prácticas\n * Priorizar el uso de rutas de alias en lugar de rutas relativas.\n * Mantener las rutas de alias semánticas y consistentes.\n * Evitar el uso excesivo de niveles de directorio en las rutas de alias.\n\n\n\n\nImportación entre servicios#\n\nCuando se configura un enlace de módulos (Module Link), se puede utilizar la\nmisma forma para importar módulos de otros servicios:\n\n\n\n\nAlias Personalizados#\n\nPara paquetes de terceros o escenarios especiales, se pueden personalizar alias\na través del archivo de configuración de Gez:\n\n\n\nConsideraciones\n 1. Para módulos de negocio, se recomienda siempre utilizar el mecanismo de\n    alias predeterminado para mantener la consistencia del proyecto.\n 2. Los alias personalizados se utilizan principalmente para manejar necesidades\n    especiales de paquetes de terceros o para optimizar la experiencia de\n    desarrollo.\n 3. El uso excesivo de alias personalizados puede afectar la mantenibilidad del\n    código y la optimización de la construcción.","routePath":"/es/guide/essentials/alias","lang":"es","toc":[{"text":"Mecanismo de Alias Predeterminado","id":"mecanismo-de-alias-predeterminado","depth":2,"charIndex":874},{"text":"Configuración","id":"configuración","depth":2,"charIndex":1703},{"text":"Configuración en package.json","id":"configuración-en-packagejson","depth":3,"charIndex":1720},{"text":"Configuración en tsconfig.json","id":"configuración-en-tsconfigjson","depth":3,"charIndex":1899},{"text":"Ejemplos de Uso","id":"ejemplos-de-uso","depth":2,"charIndex":2062},{"text":"Importación de módulos internos del servicio","id":"importación-de-módulos-internos-del-servicio","depth":3,"charIndex":2081},{"text":"Importación de módulos de otros servicios","id":"importación-de-módulos-de-otros-servicios","depth":3,"charIndex":2131},{"text":"Importación entre servicios","id":"importación-entre-servicios","depth":3,"charIndex":2398},{"text":"Alias Personalizados","id":"alias-personalizados","depth":3,"charIndex":2563}],"domain":"","frontmatter":{"titleSuffix":"Guía de mapeo de rutas de importación de módulos en el marco Gez","description":"Explicación detallada del mecanismo de alias de rutas en el marco Gez, incluyendo características como la simplificación de rutas de importación, evitación de anidamientos profundos, seguridad de tipos y optimización de resolución de módulos, para ayudar a los desarrolladores a mejorar la mantenibilidad del código.","head":[["meta",{"property":"keywords","content":"Gez, alias de rutas, Path Alias, TypeScript, importación de módulos, mapeo de rutas, mantenibilidad del código"}]]},"version":""},{"id":61,"title":"Ruta base","content":"#\n\nLa ruta base (Base Path) es el prefijo de la ruta de acceso a los recursos\nestáticos (como JavaScript, CSS, imágenes, etc.) en una aplicación. En Gez, una\nconfiguración adecuada de la ruta base es crucial para los siguientes\nescenarios:\n\n * Implementación en múltiples entornos: Soporte para el acceso a recursos en\n   diferentes entornos como desarrollo, pruebas y producción\n * Implementación en múltiples regiones: Adaptación a las necesidades de\n   implementación en clústeres de diferentes regiones o países\n * Distribución CDN: Implementación de distribución global y aceleración de\n   recursos estáticos\n\n\nMecanismo de ruta predeterminada#\n\nGez utiliza un mecanismo automático de generación de rutas basado en el nombre\ndel servicio. Por defecto, el marco leerá el campo name en el archivo\npackage.json del proyecto para generar la ruta base de los recursos estáticos:\n/your-app-name/.\n\n\n\nEste diseño de convención sobre configuración tiene las siguientes ventajas:\n\n * Consistencia: Garantiza que todos los recursos estáticos utilicen una ruta de\n   acceso unificada\n * Previsibilidad: La ruta de acceso a los recursos se puede inferir a través\n   del campo name en package.json\n * Mantenibilidad: No se requiere configuración adicional, reduciendo los costos\n   de mantenimiento\n\n\nConfiguración dinámica de rutas#\n\nEn proyectos reales, a menudo necesitamos implementar el mismo código en\ndiferentes entornos o regiones. Gez proporciona soporte para rutas base\ndinámicas, permitiendo que la aplicación se adapte a diferentes escenarios de\nimplementación.\n\n\nCasos de uso#\n\nImplementación en subdirectorios#\n\n\n\nImplementación en dominios independientes#\n\n\n\n\nMétodo de configuración#\n\nA través del parámetro base del método gez.render(), puedes establecer\ndinámicamente la ruta base según el contexto de la solicitud:\n\n","routePath":"/es/guide/essentials/base-path","lang":"es","toc":[{"text":"Mecanismo de ruta predeterminada","id":"mecanismo-de-ruta-predeterminada","depth":2,"charIndex":615},{"text":"Configuración dinámica de rutas","id":"configuración-dinámica-de-rutas","depth":2,"charIndex":1292},{"text":"Casos de uso","id":"casos-de-uso","depth":3,"charIndex":1567},{"text":"Implementación en subdirectorios","id":"implementación-en-subdirectorios","depth":4,"charIndex":1582},{"text":"Implementación en dominios independientes","id":"implementación-en-dominios-independientes","depth":4,"charIndex":1619},{"text":"Método de configuración","id":"método-de-configuración","depth":3,"charIndex":1666}],"domain":"","frontmatter":{"titleSuffix":"Guía de configuración de rutas de recursos estáticos en el marco Gez","description":"Explicación detallada de la configuración de rutas base en el marco Gez, incluyendo implementación en múltiples entornos, distribución CDN y configuración de rutas de acceso a recursos, para ayudar a los desarrolladores a lograr una gestión flexible de recursos estáticos.","head":[["meta",{"property":"keywords","content":"Gez, Ruta base, Base Path, CDN, Recursos estáticos, Implementación en múltiples entornos, Gestión de recursos"}]]},"version":""},{"id":62,"title":"Renderizado en el cliente","content":"\n${rc.importmap()} // Mapa de importación ${rc.moduleEntry()} // Módulo de\nentrada ${rc.modulePreload()} // Precarga de módulos","routePath":"/es/guide/essentials/csr","lang":"es","toc":[{"text":"Casos de uso","id":"casos-de-uso","depth":2,"charIndex":-1},{"text":"Configuración","id":"configuración","depth":2,"charIndex":-1},{"text":"Configuración de la plantilla HTML","id":"configuración-de-la-plantilla-html","depth":3,"charIndex":-1},{"text":"Generación de HTML estático","id":"generación-de-html-estático","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Guía de implementación de renderizado en el cliente del framework Gez","description":"Explicación detallada del mecanismo de renderizado en el cliente del framework Gez, incluyendo construcción estática, estrategias de despliegue y mejores prácticas, para ayudar a los desarrolladores a lograr un renderizado frontend eficiente en entornos sin servidor.","head":[["meta",{"property":"keywords","content":"Gez, Renderizado en el cliente, CSR, Construcción estática, Renderizado frontend, Despliegue sin servidor, Optimización de rendimiento"}]]},"version":""},{"id":63,"title":"Enlace de Módulos","content":"#\n\nEl marco Gez proporciona un mecanismo completo de enlace de módulos para\ngestionar la compartición de código y las dependencias entre servicios. Este\nmecanismo se basa en la especificación ESM (ECMAScript Module), soportando la\nexportación e importación de módulos a nivel de código fuente, así como\nfunciones completas de gestión de dependencias.\n\n\nConceptos Clave#\n\nExportación de Módulos#\n\nLa exportación de módulos es el proceso de exponer unidades de código\nespecíficas (como componentes, funciones de utilidad, etc.) de un servicio en\nformato ESM. Soporta dos tipos de exportación:\n\n * Exportación de código fuente: Exporta directamente archivos de código fuente\n   del proyecto\n * Exportación de dependencias: Exporta paquetes de dependencias de terceros\n   utilizados en el proyecto\n\nImportación de Módulos#\n\nLa importación de módulos es el proceso de referenciar unidades de código\nexportadas por otros servicios dentro de un servicio. Soporta múltiples métodos\nde instalación:\n\n * Instalación de código fuente: Adecuado para entornos de desarrollo, soporta\n   modificaciones en tiempo real y actualización en caliente\n * Instalación de paquetes: Adecuado para entornos de producción, utiliza\n   directamente los artefactos de construcción\n\n\nMecanismo de Precarga#\n\nPara optimizar el rendimiento de los servicios, Gez implementa un mecanismo\ninteligente de precarga de módulos:\n\n 1. Análisis de Dependencias\n    \n    * Analiza las dependencias entre componentes durante la construcción\n    * Identifica los módulos clave en la ruta crítica\n    * Determina la prioridad de carga de los módulos\n\n 2. Estrategia de Carga\n    \n    * Carga inmediata: Módulos clave en la ruta crítica\n    * Carga diferida: Módulos de funcionalidades no críticas\n    * Carga bajo demanda: Módulos que se renderizan condicionalmente\n\n 3. Optimización de Recursos\n    \n    * Estrategia inteligente de división de código\n    * Gestión de caché a nivel de módulo\n    * Compilación y empaquetado bajo demanda\n\n\nExportación de Módulos#\n\n\nConfiguración#\n\nConfigura los módulos a exportar en entry.node.ts:\n\n\n\nLa configuración de exportación soporta dos tipos:\n\n * root:*: Exporta archivos de código fuente, la ruta es relativa al directorio\n   raíz del proyecto\n * npm:*: Exporta dependencias de terceros, especifica directamente el nombre\n   del paquete\n\n\nImportación de Módulos#\n\n\nConfiguración#\n\nConfigura los módulos a importar en entry.node.ts:\n\n\n\nExplicación de las opciones de configuración:\n\n 1. imports: Configura la ruta local de los módulos remotos\n    \n    * Instalación de código fuente: apunta al directorio de artefactos de\n      construcción (dist)\n    * Instalación de paquetes: apunta directamente al directorio del paquete\n\n 2. externals: Configura dependencias externas\n    \n    * Para compartir dependencias de módulos remotos\n    * Evita empaquetar dependencias duplicadas\n    * Soporta compartir dependencias entre múltiples módulos\n\n\nMétodos de Instalación#\n\nInstalación de Código Fuente#\n\nAdecuado para entornos de desarrollo, soporta modificaciones en tiempo real y\nactualización en caliente.\n\n 1. Modo Workspace Recomendado para proyectos Monorepo:\n\n\n\n 2. Modo Link Para depuración en desarrollo local:\n\n\n\nInstalación de Paquetes#\n\nAdecuado para entornos de producción, utiliza directamente los artefactos de\nconstrucción.\n\n 1. Registro NPM Instalación a través del registro npm:\n\n\n\n 2. Servidor Estático Instalación a través del protocolo HTTP/HTTPS:\n\n\n\n\nConstrucción de Paquetes#\n\n\nConfiguración#\n\nConfigura las opciones de construcción en entry.node.ts:\n\n\n\n\nArtefactos de Construcción#\n\n\n\n\nProceso de Publicación#\n\n\n\n\nMejores Prácticas#\n\n\nConfiguración de Entorno de Desarrollo#\n\n * Gestión de Dependencias\n   \n   * Usar el modo Workspace o Link para instalar dependencias\n   * Gestionar versiones de dependencias de manera unificada\n   * Evitar instalar dependencias duplicadas\n\n * Experiencia de Desarrollo\n   \n   * Habilitar la función de actualización en caliente\n   * Configurar una estrategia de precarga adecuada\n   * Optimizar la velocidad de construcción\n\n\nConfiguración de Entorno de Producción#\n\n * Estrategia de Despliegue\n   \n   * Usar el registro NPM o un servidor estático\n   * Asegurar la integridad de los artefactos de construcción\n   * Implementar un mecanismo de publicación gradual\n\n * Optimización de Rendimiento\n   \n   * Configurar adecuadamente la precarga de recursos\n   * Optimizar el orden de carga de módulos\n   * Implementar una estrategia de caché efectiva\n\n\nGestión de Versiones#\n\n * Normativa de Versiones\n   \n   * Seguir la normativa de versionado semántico\n   * Mantener un registro detallado de cambios\n   * Realizar pruebas de compatibilidad de versiones\n\n * Actualización de Dependencias\n   \n   * Actualizar paquetes de dependencias oportunamente\n   * Realizar auditorías de seguridad periódicamente\n   * Mantener la consistencia de versiones de dependencias","routePath":"/es/guide/essentials/module-link","lang":"es","toc":[{"text":"Conceptos Clave","id":"conceptos-clave","depth":3,"charIndex":352},{"text":"Exportación de Módulos","id":"exportación-de-módulos","depth":4,"charIndex":370},{"text":"Importación de Módulos","id":"importación-de-módulos","depth":4,"charIndex":794},{"text":"Mecanismo de Precarga","id":"mecanismo-de-precarga","depth":3,"charIndex":1253},{"text":"Exportación de Módulos","id":"exportación-de-módulos-1","depth":2,"charIndex":1994},{"text":"Configuración","id":"configuración","depth":3,"charIndex":2020},{"text":"Importación de Módulos","id":"importación-de-módulos-1","depth":2,"charIndex":2338},{"text":"Configuración","id":"configuración-1","depth":3,"charIndex":2364},{"text":"Métodos de Instalación","id":"métodos-de-instalación","depth":3,"charIndex":2939},{"text":"Instalación de Código Fuente","id":"instalación-de-código-fuente","depth":4,"charIndex":2964},{"text":"Instalación de Paquetes","id":"instalación-de-paquetes","depth":4,"charIndex":3214},{"text":"Construcción de Paquetes","id":"construcción-de-paquetes","depth":2,"charIndex":3464},{"text":"Configuración","id":"configuración-2","depth":3,"charIndex":3492},{"text":"Artefactos de Construcción","id":"artefactos-de-construcción","depth":3,"charIndex":3569},{"text":"Proceso de Publicación","id":"proceso-de-publicación","depth":3,"charIndex":3601},{"text":"Mejores Prácticas","id":"mejores-prácticas","depth":2,"charIndex":3629},{"text":"Configuración de Entorno de Desarrollo","id":"configuración-de-entorno-de-desarrollo","depth":3,"charIndex":3650},{"text":"Configuración de Entorno de Producción","id":"configuración-de-entorno-de-producción","depth":3,"charIndex":4077},{"text":"Gestión de Versiones","id":"gestión-de-versiones","depth":3,"charIndex":4500}],"domain":"","frontmatter":{"titleSuffix":"Mecanismo de compartición de código entre servicios en el marco Gez","description":"Explicación detallada del mecanismo de enlace de módulos del marco Gez, incluyendo la compartición de código entre servicios, gestión de dependencias e implementación de la especificación ESM, para ayudar a los desarrolladores a construir aplicaciones de microfrontend eficientes.","head":[["meta",{"property":"keywords","content":"Gez, enlace de módulos, Module Link, ESM, compartición de código, gestión de dependencias, microfrontend"}]]},"version":""},{"id":64,"title":"Contexto de Renderizado","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/es/guide/essentials/render-context","lang":"es","toc":[{"text":"Modo de uso","id":"modo-de-uso","depth":2,"charIndex":-1},{"text":"Funcionalidades principales","id":"funcionalidades-principales","depth":2,"charIndex":-1},{"text":"Recolección de dependencias","id":"recolección-de-dependencias","depth":3,"charIndex":-1},{"text":"Recolección bajo demanda","id":"recolección-bajo-demanda","depth":4,"charIndex":-1},{"text":"Procesamiento automático","id":"procesamiento-automático","depth":4,"charIndex":-1},{"text":"Optimización de rendimiento","id":"optimización-de-rendimiento","depth":4,"charIndex":-1},{"text":"Inyección de recursos","id":"inyección-de-recursos","depth":3,"charIndex":-1},{"text":"Orden de inyección de recursos","id":"orden-de-inyección-de-recursos","depth":3,"charIndex":-1},{"text":"Flujo completo de renderizado","id":"flujo-completo-de-renderizado","depth":2,"charIndex":-1},{"text":"Características avanzadas","id":"características-avanzadas","depth":2,"charIndex":-1},{"text":"Configuración de ruta base","id":"configuración-de-ruta-base","depth":3,"charIndex":-1},{"text":"Modos de mapeo de importación","id":"modos-de-mapeo-de-importación","depth":3,"charIndex":-1},{"text":"Configuración de función de entrada","id":"configuración-de-función-de-entrada","depth":3,"charIndex":-1},{"text":"Mejores prácticas","id":"mejores-prácticas","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Mecanismo central de renderizado del lado del servidor en el framework Gez","description":"Explicación detallada del mecanismo de contexto de renderizado (RenderContext) en el framework Gez, incluyendo la gestión de recursos, generación de HTML y el sistema de módulos ESM, para ayudar a los desarrolladores a comprender y utilizar la funcionalidad de renderizado del lado del servidor.","head":[["meta",{"property":"keywords","content":"Gez, contexto de renderizado, RenderContext, SSR, renderizado del lado del servidor, ESM, gestión de recursos"}]]},"version":""},{"id":65,"title":"Rspack","content":"#\n\nGez se basa en el sistema de construcción Rspack, aprovechando al máximo su\ncapacidad de construcción de alto rendimiento. Este documento presenta el\nposicionamiento y las funciones principales de Rspack en el framework Gez.\n\n\nCaracterísticas#\n\nRspack es el sistema de construcción central del framework Gez y ofrece las\nsiguientes características clave:\n\n * Construcción de alto rendimiento: Motor de construcción implementado en Rust,\n   proporciona una velocidad de compilación extremadamente rápida, mejorando\n   significativamente la velocidad de construcción de proyectos grandes.\n * Optimización de la experiencia de desarrollo: Soporta características\n   modernas como actualización en caliente (HMR) y compilación incremental,\n   ofreciendo una experiencia de desarrollo fluida.\n * Construcción multi-entorno: Configuración de construcción unificada que\n   soporta entornos de cliente (client), servidor (server) y Node.js (node),\n   simplificando el flujo de desarrollo multi-plataforma.\n * Optimización de recursos: Capacidades integradas de procesamiento y\n   optimización de recursos, soporta características como división de código,\n   Tree Shaking y compresión de recursos.\n\n\nConstrucción de aplicaciones#\n\nEl sistema de construcción Rspack de Gez sigue un diseño modular e incluye los\nsiguientes módulos principales:\n\n\n@gez/rspack#\n\nMódulo de construcción básico que proporciona las siguientes capacidades\ncentrales:\n\n * Configuración de construcción unificada: Ofrece gestión estandarizada de\n   configuración de construcción, soporta configuración multi-entorno.\n * Procesamiento de recursos: Capacidades integradas para procesar recursos como\n   TypeScript, CSS, imágenes, etc.\n * Optimización de construcción: Proporciona características de optimización de\n   rendimiento como división de código y Tree Shaking.\n * Servidor de desarrollo: Integra un servidor de desarrollo de alto rendimiento\n   con soporte para HMR.\n\n\n@gez/rspack-vue#\n\nMódulo de construcción específico para el framework Vue, ofrece:\n\n * Compilación de componentes Vue: Soporta compilación eficiente de componentes\n   Vue 2/3.\n * Optimización SSR: Optimizaciones específicas para escenarios de renderizado\n   del lado del servidor.\n * Mejoras de desarrollo: Funcionalidades específicas para mejorar el entorno de\n   desarrollo de Vue.\n\n\nFlujo de construcción#\n\nEl flujo de construcción de Gez se divide principalmente en las siguientes\netapas:\n\n 1. Inicialización de configuración\n    \n    * Carga la configuración del proyecto\n    * Combina la configuración predeterminada con la del usuario\n    * Ajusta la configuración según las variables de entorno\n\n 2. Compilación de recursos\n    \n    * Resuelve las dependencias del código fuente\n    * Transforma varios tipos de recursos (TypeScript, CSS, etc.)\n    * Procesa importaciones y exportaciones de módulos\n\n 3. Procesamiento de optimización\n    \n    * Ejecuta la división de código\n    * Aplica Tree Shaking\n    * Comprime código y recursos\n\n 4. Generación de salida\n    \n    * Genera archivos de destino\n    * Produce mapas de recursos\n    * Genera informes de construcción\n\n\nMejores prácticas#\n\n\nOptimización del entorno de desarrollo#\n\n * Configuración de compilación incremental: Configura adecuadamente la opción\n   cache para acelerar la velocidad de construcción utilizando la caché.\n * Optimización HMR: Configura el alcance de la actualización en caliente de\n   manera específica para evitar actualizaciones innecesarias de módulos.\n * Optimización del procesamiento de recursos: Utiliza configuraciones de loader\n   apropiadas para evitar el procesamiento repetido.\n\n\nOptimización del entorno de producción#\n\n * Estrategia de división de código: Configura adecuadamente splitChunks para\n   optimizar la carga de recursos.\n * Compresión de recursos: Habilita configuraciones de compresión adecuadas para\n   equilibrar el tiempo de construcción y el tamaño de los artefactos.\n * Optimización de caché: Utiliza estrategias de hash de contenido y caché a\n   largo plazo para mejorar el rendimiento de carga.\n\n\nEjemplo de configuración#\n\n\n\nTIP\n\nPara obtener más detalles sobre la API y las opciones de configuración, consulta\nla documentación de la API de Rspack.","routePath":"/es/guide/essentials/rspack","lang":"es","toc":[{"text":"Características","id":"características","depth":2,"charIndex":229},{"text":"Construcción de aplicaciones","id":"construcción-de-aplicaciones","depth":2,"charIndex":1193},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1337},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1942},{"text":"Flujo de construcción","id":"flujo-de-construcción","depth":2,"charIndex":2328},{"text":"Mejores prácticas","id":"mejores-prácticas","depth":2,"charIndex":3121},{"text":"Optimización del entorno de desarrollo","id":"optimización-del-entorno-de-desarrollo","depth":3,"charIndex":3142},{"text":"Optimización del entorno de producción","id":"optimización-del-entorno-de-producción","depth":3,"charIndex":3622},{"text":"Ejemplo de configuración","id":"ejemplo-de-configuración","depth":2,"charIndex":4060}],"domain":"","frontmatter":{"titleSuffix":"Motor de construcción de alto rendimiento del framework Gez","description":"Análisis en profundidad del sistema de construcción Rspack del framework Gez, incluyendo compilación de alto rendimiento, construcción multi-entorno, optimización de recursos y otras características clave, para ayudar a los desarrolladores a construir aplicaciones web modernas eficientes y confiables.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, sistema de construcción, compilación de alto rendimiento, actualización en caliente, construcción multi-entorno, Tree Shaking, división de código, SSR, optimización de recursos, eficiencia de desarrollo, herramientas de construcción"}]]},"version":""},{"id":66,"title":"Normas Estándar","content":"#\n\nGez es un framework SSR moderno que adopta una estructura de proyecto\nestandarizada y un mecanismo de resolución de rutas para garantizar la\nconsistencia y mantenibilidad del proyecto en entornos de desarrollo y\nproducción.\n\n\nNormas de Estructura del Proyecto#\n\n\nEstructura de Directorios Estándar#\n\n\n\nConocimiento Adicional\n * gez.name proviene del campo name en package.json\n * dist/package.json proviene del package.json en el directorio raíz\n * El directorio dist se archiva solo cuando packs.enable está configurado como\n   true\n\n\nNormas de Archivos de Entrada#\n\n\nentry.client.ts#\n\nEl archivo de entrada del cliente es responsable de:\n\n * Inicializar la aplicación: Configurar los ajustes básicos de la aplicación\n   del cliente\n * Gestión de rutas: Manejar las rutas y navegación del cliente\n * Gestión de estado: Implementar el almacenamiento y actualización del estado\n   del cliente\n * Manejo de interacciones: Gestionar eventos del usuario e interacciones de la\n   interfaz\n\n\nentry.server.ts#\n\nEl archivo de entrada del servidor es responsable de:\n\n * Renderizado del servidor: Ejecutar el proceso de renderizado SSR\n * Generación de HTML: Construir la estructura inicial de la página\n * Precarga de datos: Manejar la obtención de datos en el servidor\n * Inyección de estado: Transferir el estado del servidor al cliente\n * Optimización SEO: Asegurar la optimización del motor de búsqueda de la página\n\n\nentry.node.ts#\n\nEl archivo de entrada del servidor Node.js es responsable de:\n\n * Configuración del servidor: Establecer los parámetros del servidor HTTP\n * Manejo de rutas: Gestionar las reglas de rutas del servidor\n * Integración de middleware: Configurar middleware del servidor\n * Gestión del entorno: Manejar variables de entorno y configuraciones\n * Respuesta a solicitudes: Manejar solicitudes y respuestas HTTP\n\n\nNormas de Archivos de Configuración#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/es/guide/essentials/std","lang":"es","toc":[{"text":"Normas de Estructura del Proyecto","id":"normas-de-estructura-del-proyecto","depth":2,"charIndex":228},{"text":"Estructura de Directorios Estándar","id":"estructura-de-directorios-estándar","depth":3,"charIndex":265},{"text":"Normas de Archivos de Entrada","id":"normas-de-archivos-de-entrada","depth":2,"charIndex":538},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":571},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":988},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1416},{"text":"Normas de Archivos de Configuración","id":"normas-de-archivos-de-configuración","depth":2,"charIndex":1837},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1876},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1894}],"domain":"","frontmatter":{"titleSuffix":"Guía de Estructura y Normas del Proyecto del Framework Gez","description":"Descripción detallada de la estructura estándar del proyecto, normas de archivos de entrada y configuración del framework Gez, para ayudar a los desarrolladores a construir aplicaciones SSR normalizadas y mantenibles.","head":[["meta",{"property":"keywords","content":"Gez, Estructura del Proyecto, Archivos de Entrada, Normas de Configuración, Framework SSR, TypeScript, Normas del Proyecto, Estándares de Desarrollo"}]]},"version":""},{"id":67,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/es/guide/frameworks/html","lang":"es","toc":[{"text":"Estructura del proyecto","id":"estructura-del-proyecto","depth":2,"charIndex":-1},{"text":"Configuración del proyecto","id":"configuración-del-proyecto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Estructura del código fuente","id":"estructura-del-código-fuente","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Ejecución del proyecto","id":"ejecución-del-proyecto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Ejemplo de aplicación HTML SSR con Gez","description":"Aprende a crear una aplicación HTML SSR con Gez desde cero. Este tutorial muestra el uso básico del framework, incluyendo la inicialización del proyecto, configuración de HTML y configuración de archivos de entrada.","head":[["meta",{"property":"keywords","content":"Gez, HTML, Aplicación SSR, Configuración TypeScript, Inicialización de proyecto, Renderizado en servidor, Interacción en cliente"}]]},"version":""},{"id":68,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/es/guide/frameworks/preact-htm","lang":"es","toc":[{"text":"Estructura del proyecto","id":"estructura-del-proyecto","depth":2,"charIndex":-1},{"text":"Configuración del proyecto","id":"configuración-del-proyecto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Estructura del código fuente","id":"estructura-del-código-fuente","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Ejecutar el proyecto","id":"ejecutar-el-proyecto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Ejemplo de aplicación SSR con Gez, Preact y HTM","description":"Aprende a crear una aplicación SSR con Preact+HTM desde cero utilizando el framework Gez. Este tutorial cubre la inicialización del proyecto, configuración de Preact y configuración de archivos de entrada.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, Aplicación SSR, Configuración TypeScript, Inicialización de proyecto, Renderizado en el servidor, Interacción en el cliente"}]]},"version":""},{"id":69,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/es/guide/frameworks/vue2","lang":"es","toc":[{"text":"Estructura del proyecto","id":"estructura-del-proyecto","depth":2,"charIndex":-1},{"text":"Configuración del proyecto","id":"configuración-del-proyecto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Estructura del código fuente","id":"estructura-del-código-fuente","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Ejecutar el proyecto","id":"ejecutar-el-proyecto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Ejemplo de aplicación Vue2 SSR con el framework Gez","description":"Crea una aplicación Vue2 SSR basada en Gez desde cero. Este tutorial muestra el uso básico del framework, incluyendo la inicialización del proyecto, configuración de Vue2 y configuración de archivos de entrada.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, Aplicación SSR, Configuración TypeScript, Inicialización de proyecto, Renderizado en el servidor, Interacción en el cliente"}]]},"version":""},{"id":70,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/es/guide/frameworks/vue3","lang":"es","toc":[{"text":"Estructura del proyecto","id":"estructura-del-proyecto","depth":2,"charIndex":-1},{"text":"Configuración del proyecto","id":"configuración-del-proyecto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Estructura del código fuente","id":"estructura-del-código-fuente","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Ejecutar el proyecto","id":"ejecutar-el-proyecto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Ejemplo de aplicación Vue3 SSR con el framework Gez","description":"Aprende a crear una aplicación Vue3 SSR desde cero utilizando el framework Gez. Este tutorial muestra el uso básico del framework, incluyendo la inicialización del proyecto, configuración de Vue3 y configuración de archivos de entrada.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, Aplicación SSR, Configuración TypeScript, Inicialización de proyecto, Renderizado en el servidor, Interacción en el cliente, API de composición"}]]},"version":""},{"id":71,"title":"Requisitos del entorno","content":"#\n\nEste documento describe los requisitos de entorno necesarios para utilizar este\nframework, incluyendo el entorno de Node.js y la compatibilidad con navegadores.\n\n\nEntorno de Node.js#\n\nEl framework requiere Node.js versión >= 22.6, principalmente para admitir la\nimportación de tipos de TypeScript (a través de la bandera\n--experimental-strip-types), sin necesidad de pasos adicionales de compilación.\n\n\nCompatibilidad con navegadores#\n\nEl framework utiliza por defecto un modo de construcción compatible para admitir\nuna gama más amplia de navegadores. Sin embargo, es importante tener en cuenta\nque para lograr un soporte completo de compatibilidad con navegadores, es\nnecesario agregar manualmente la dependencia es-module-shims.\n\n\nModo compatible (por defecto)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nSegún las estadísticas de Can I Use, la cobertura de navegadores en modo\ncompatible alcanza el 96.81%.\n\n\nModo de soporte nativo#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nEl modo de soporte nativo ofrece las siguientes ventajas:\n\n * Cero sobrecarga en tiempo de ejecución, sin necesidad de cargadores de\n   módulos adicionales\n * Análisis nativo del navegador, mayor velocidad de ejecución\n * Mejor capacidad de división de código y carga bajo demanda\n\nSegún las estadísticas de Can I Use, la cobertura de navegadores en modo\ncompatible alcanza el 93.5%.\n\n\nHabilitar soporte compatible#\n\nNota importante\n\nAunque el framework utiliza por defecto el modo de construcción compatible, para\nlograr un soporte completo en navegadores antiguos, es necesario agregar la\ndependencia es-module-shims en su proyecto.\n\nAgregue el siguiente script en su archivo HTML:\n\n\n\nMejores prácticas\n 1. Recomendaciones para el entorno de producción:\n    * Implemente es-module-shims en su propio servidor\n    * Asegure la estabilidad y velocidad de carga de los recursos\n    * Evite posibles riesgos de seguridad\n 2. Consideraciones de rendimiento:\n    * El modo compatible implica un ligero costo de rendimiento\n    * Puede decidir habilitarlo según la distribución de navegadores de su\n      audiencia objetivo","routePath":"/es/guide/start/environment","lang":"es","toc":[{"text":"Entorno de Node.js","id":"entorno-de-nodejs","depth":2,"charIndex":165},{"text":"Compatibilidad con navegadores","id":"compatibilidad-con-navegadores","depth":2,"charIndex":405},{"text":"Modo compatible (por defecto)","id":"modo-compatible-por-defecto","depth":3,"charIndex":736},{"text":"Modo de soporte nativo","id":"modo-de-soporte-nativo","depth":3,"charIndex":953},{"text":"Habilitar soporte compatible","id":"habilitar-soporte-compatible","depth":3,"charIndex":1447}],"domain":"","frontmatter":{"titleSuffix":"Guía de compatibilidad del framework Gez","description":"Detalles sobre los requisitos de entorno del framework Gez, incluyendo los requisitos de versión de Node.js y la compatibilidad con navegadores, para ayudar a los desarrolladores a configurar correctamente el entorno de desarrollo.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, Compatibilidad con navegadores, TypeScript, es-module-shims, Configuración del entorno"}]]},"version":""},{"id":72,"title":"Inicio rápido","content":"#\n\n\nInicialización del proyecto#\n\nPara crear e inicializar un nuevo proyecto con Gez, sigue estos pasos:\n\n\n\n\nSelección de versión del framework#\n\nEl framework Gez ofrece múltiples versiones de pila tecnológica, cada una\noptimizada para diferentes casos de uso. Selecciona la versión adecuada según\nlas necesidades de tu proyecto:\n\n\nHTML#\n\nIdeal para proyectos que buscan una arquitectura minimalista:\n\n * Cero dependencias externas, listo para usar\n * Experiencia de desarrollo con JavaScript nativo\n * Adecuado para construir sitios web estáticos y aplicaciones ligeras\n * Soporta expansión progresiva de funcionalidades\n\nVer documentación detallada de la versión HTML\n\n\nVue2#\n\nRecomendado para desarrollo de aplicaciones empresariales:\n\n * Soporte completo para TypeScript\n * Ecosistema rico en componentes de terceros\n * Cadena de herramientas de desarrollo madura\n * Estabilidad probada en entornos de producción\n\nVer documentación detallada de la versión Vue2\n\n\nVue3#\n\nIdeal para desarrollo de aplicaciones web modernas:\n\n * Sistema reactivo basado en Proxy\n * Soporte para API de composición\n * Mejor rendimiento en tiempo de ejecución\n * Tamaño de paquete más reducido\n\nVer documentación detallada de la versión Vue3\n\n\nPreact+HTM#\n\nPerfecto para proyectos que priorizan ligereza y alto rendimiento:\n\n * Tamaño mínimo en tiempo de ejecución (3KB)\n * Sintaxis de plantillas en JavaScript nativo\n * API compatible con React\n * Excelente rendimiento\n\nVer documentación detallada de la versión Preact+HTM\n\n\nDesarrollo asistido por IA#\n\nEl framework Gez ofrece capacidades de desarrollo asistido por IA que pueden\nmejorar significativamente la eficiencia del desarrollo:\n\n 1. Selecciona la documentación de la versión del framework adecuada\n 2. Proporciona el contenido de la documentación al asistente de IA\n 3. La IA generará automáticamente el esqueleto del proyecto y los archivos de\n    configuración\n\nConsejo\n\nEl desarrollo asistido por IA no solo acelera la inicialización del proyecto,\nsino que también asegura que la estructura del proyecto siga las mejores\nprácticas.","routePath":"/es/guide/start/getting-started","lang":"es","toc":[{"text":"Inicialización del proyecto","id":"inicialización-del-proyecto","depth":2,"charIndex":3},{"text":"Selección de versión del framework","id":"selección-de-versión-del-framework","depth":2,"charIndex":108},{"text":"HTML","id":"html","depth":3,"charIndex":331},{"text":"Vue2","id":"vue2","depth":3,"charIndex":671},{"text":"Vue3","id":"vue3","depth":3,"charIndex":966},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1225},{"text":"Desarrollo asistido por IA","id":"desarrollo-asistido-por-ia","depth":2,"charIndex":1508}],"domain":"","frontmatter":{"titleSuffix":"Guía de inicio rápido del framework Gez","description":"Guía de inicio rápido del framework Gez que te ayudará a configurar un proyecto desde cero, incluyendo la inicialización del proyecto, selección de versiones del framework y desarrollo asistido por IA.","head":[["meta",{"name":"keywords","content":"Framework Gez, Inicio rápido, Inicialización de proyecto, Desarrollo Vue, Desarrollo HTML, Asistencia IA"}]]},"version":""},{"id":73,"title":"Introducción","content":"#\n\n\nContexto del proyecto#\n\nGez es un framework moderno de microfrontend basado en ECMAScript Modules (ESM),\nenfocado en construir aplicaciones de alto rendimiento y escalables con\nrenderizado en el servidor (SSR). Como la tercera generación del proyecto\nGenesis, Gez ha innovado continuamente en su evolución tecnológica:\n\n * v1.0: Implementación de carga bajo demanda de componentes remotos basada en\n   solicitudes HTTP\n * v2.0: Integración de aplicaciones basada en Webpack Module Federation\n * v3.0: Rediseño del sistema de enlace de módulos basado en ESM nativo del\n   navegador\n\n\nContexto tecnológico#\n\nEn el desarrollo de la arquitectura de microfrontend, las soluciones\ntradicionales presentan principalmente las siguientes limitaciones:\n\n\nDesafíos de las soluciones existentes#\n\n * Cuellos de botella de rendimiento: La inyección de dependencias en tiempo de\n   ejecución y los proxies de sandbox de JavaScript generan un sobrecosto\n   significativo de rendimiento\n * Mecanismos de aislamiento: Los entornos de sandbox desarrollados internamente\n   no pueden igualar la capacidad de aislamiento de módulos nativa del navegador\n * Complejidad de construcción: Las modificaciones en las herramientas de\n   construcción para lograr el uso compartido de dependencias aumentan los\n   costos de mantenimiento del proyecto\n * Desviación de estándares: Las estrategias de implementación especiales y los\n   mecanismos de procesamiento en tiempo de ejecución se desvían de los\n   estándares modernos de desarrollo web\n * Limitaciones del ecosistema: El acoplamiento del framework y las API\n   personalizadas restringen la elección de la pila tecnológica\n\n\nInnovación tecnológica#\n\nGez, basado en los estándares web modernos, ofrece una nueva solución:\n\n * Sistema de módulos nativo: Utiliza ESM nativo del navegador e Import Maps\n   para la gestión de dependencias, con una velocidad de análisis y ejecución\n   más rápida\n * Mecanismo de aislamiento estándar: Implementa un aislamiento confiable de\n   aplicaciones basado en el ámbito de módulos de ECMAScript\n * Pila tecnológica abierta: Admite la integración perfecta de cualquier\n   framework frontend moderno\n * Optimización de la experiencia de desarrollo: Proporciona un modo de\n   desarrollo intuitivo y capacidades completas de depuración\n * Optimización extrema del rendimiento: Logra un sobrecosto de tiempo de\n   ejecución cero mediante capacidades nativas, junto con una estrategia de\n   caché inteligente\n\nTIP\n\nGez se enfoca en construir una infraestructura de microfrontend de alto\nrendimiento y fácilmente extensible, especialmente adecuada para escenarios de\naplicaciones de renderizado en el servidor a gran escala.\n\n\nEspecificaciones técnicas#\n\n\nDependencias del entorno#\n\nConsulte el documento Requisitos del entorno para conocer los requisitos\ndetallados del navegador y del entorno Node.js.\n\n\nPila tecnológica principal#\n\n * Gestión de dependencias: Utiliza Import Maps para el mapeo de módulos y\n   es-module-shims para proporcionar soporte de compatibilidad\n * Sistema de construcción: Basado en module-import de Rspack para manejar\n   dependencias externas\n * Cadena de herramientas de desarrollo: Admite actualización en caliente de ESM\n   y ejecución nativa de TypeScript\n\n\nPosicionamiento del framework#\n\nGez es diferente de Next.js o Nuxt.js, ya que se enfoca en proporcionar\ninfraestructura de microfrontend:\n\n * Sistema de enlace de módulos: Implementa importación y exportación de módulos\n   eficiente y confiable\n * Renderizado en el servidor: Proporciona un mecanismo flexible de\n   implementación de SSR\n * Soporte del sistema de tipos: Integra definiciones de tipos completas de\n   TypeScript\n * Neutralidad del framework: Admite la integración con frameworks frontend\n   principales\n\n\nDiseño de arquitectura#\n\n\nGestión centralizada de dependencias#\n\n * Fuente de dependencias unificada: Gestión centralizada de dependencias de\n   terceros\n * Distribución automática: Sincronización global automática de actualizaciones\n   de dependencias\n * Consistencia de versiones: Control preciso de versiones de dependencias\n\n\nDiseño modular#\n\n * Separación de responsabilidades: Desacoplamiento de la lógica de negocio y la\n   infraestructura\n * Mecanismo de plugins: Admite combinación y reemplazo flexible de módulos\n * Interfaz estandarizada: Protocolo de comunicación entre módulos normalizado\n\n\nOptimización del rendimiento#\n\n * Principio de sobrecosto cero: Maximiza el uso de capacidades nativas del\n   navegador\n * Caché inteligente: Estrategia de caché precisa basada en hash de contenido\n * Carga bajo demanda: División de código y gestión de dependencias refinada\n\n\nMadurez del proyecto#\n\nGez, a través de casi 5 años de iteración y evolución (de v1.0 a v3.0), ha sido\ncompletamente validado en entornos empresariales. Actualmente soporta docenas de\nproyectos comerciales en funcionamiento estable y continúa impulsando la\nmodernización de la pila tecnológica. La estabilidad, confiabilidad y ventajas\nde rendimiento del framework han sido plenamente probadas en la práctica,\nproporcionando una base técnica confiable para el desarrollo de aplicaciones a\ngran escala.","routePath":"/es/guide/start/introduction","lang":"es","toc":[{"text":"Contexto del proyecto","id":"contexto-del-proyecto","depth":2,"charIndex":3},{"text":"Contexto tecnológico","id":"contexto-tecnológico","depth":2,"charIndex":586},{"text":"Desafíos de las soluciones existentes","id":"desafíos-de-las-soluciones-existentes","depth":3,"charIndex":748},{"text":"Innovación tecnológica","id":"innovación-tecnológica","depth":3,"charIndex":1656},{"text":"Especificaciones técnicas","id":"especificaciones-técnicas","depth":2,"charIndex":2685},{"text":"Dependencias del entorno","id":"dependencias-del-entorno","depth":3,"charIndex":2714},{"text":"Pila tecnológica principal","id":"pila-tecnológica-principal","depth":3,"charIndex":2864},{"text":"Posicionamiento del framework","id":"posicionamiento-del-framework","depth":2,"charIndex":3250},{"text":"Diseño de arquitectura","id":"diseño-de-arquitectura","depth":2,"charIndex":3771},{"text":"Gestión centralizada de dependencias","id":"gestión-centralizada-de-dependencias","depth":3,"charIndex":3797},{"text":"Diseño modular","id":"diseño-modular","depth":3,"charIndex":4101},{"text":"Optimización del rendimiento","id":"optimización-del-rendimiento","depth":3,"charIndex":4375},{"text":"Madurez del proyecto","id":"madurez-del-proyecto","depth":2,"charIndex":4652}],"domain":"","frontmatter":{"titleSuffix":"Visión general y innovación tecnológica del framework Gez","description":"Profundice en el contexto del proyecto, la evolución tecnológica y las ventajas principales del framework de microfrontend Gez, explorando soluciones modernas de renderizado en el servidor basadas en ESM.","head":[["meta",{"property":"keywords","content":"Gez, microfrontend, ESM, renderizado en el servidor, SSR, innovación tecnológica, federación de módulos"}]]},"version":""}]