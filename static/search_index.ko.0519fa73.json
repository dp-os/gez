[{"id":175,"title":"@gez/rspack-vue","content":"#\n\nRspack Vue 패키지는 Vue 프레임워크 기반의 Rspack 애플리케이션을 생성하고 구성하기 위한 API 세트를 제공하며, Vue 컴포넌트\n개발, 빌드 및 서버 사이드 렌더링을 지원합니다.\n\n\n설치#\n\n패키지 매니저를 사용하여 @gez/rspack-vue 개발 의존성을 설치합니다:\n\n\n타입 내보내기#\n\n\nBuildTarget#\n\n\n\n빌드 대상 환경 타입으로, 애플리케이션의 빌드 대상 환경을 정의하며, 빌드 프로세스에서 특정 최적화 및 기능을 구성하는 데 사용됩니다:\n\n * node: Node.js 환경에서 실행되는 코드로 빌드\n * client: 브라우저 환경에서 실행되는 코드로 빌드\n * server: 서버 환경에서 실행되는 코드로 빌드\n\n\nRspackAppConfigContext#\n\n\n\nRspack 애플리케이션 구성 컨텍스트 인터페이스로, 구성 훅 함수에서 접근할 수 있는 컨텍스트 정보를 제공합니다:\n\n * gez: Gez 프레임워크 인스턴스\n * buildTarget: 현재 빌드 대상 (client/server/node)\n * config: Rspack 구성 객체\n * options: 애플리케이션 구성 옵션\n\n\nRspackAppOptions#\n\n\n\nRspack 애플리케이션 구성 옵션 인터페이스:\n\n * css: CSS 출력 방식, 'css' (독립 파일) 또는 'style' (인라인 스타일) 선택 가능\n * loaders: 사용자 정의 loader 구성\n * styleLoader: style-loader 구성 옵션\n * cssLoader: css-loader 구성 옵션\n * target: 빌드 대상 호환성 구성\n * definePlugin: 전역 상수 정의\n * config: 구성 훅 함수\n\n\nRspackHtmlAppOptions#\n\nRspackAppOptions를 상속받아 HTML 애플리케이션의 특정 옵션을 구성합니다.\n\n\n함수 내보내기#\n\n\ncreateRspackApp#\n\n\n\n표준 Rspack 애플리케이션 인스턴스를 생성합니다.\n\n매개변수:\n\n * gez: Gez 프레임워크 인스턴스\n * options: Rspack 애플리케이션 구성 옵션\n\n반환값:\n\n * 생성된 애플리케이션 인스턴스로 해결되는 Promise 반환\n\n\ncreateRspackHtmlApp#\n\n\n\nHTML 타입의 Rspack 애플리케이션 인스턴스를 생성합니다.\n\n매개변수:\n\n * gez: Gez 프레임워크 인스턴스\n * options: HTML 애플리케이션 구성 옵션\n\n반환값:\n\n * 생성된 HTML 애플리케이션 인스턴스로 해결되는 Promise 반환\n\n\n상수 내보내기#\n\n\nRSPACK_LOADER#\n\n\n\nRspack 내장 loader 식별자 매핑 객체로, 일반적으로 사용되는 loader 이름 상수를 제공합니다:\n\n * builtinSwcLoader: TypeScript/JavaScript 파일을 처리하기 위한 Rspack 내장 SWC loader\n * lightningcssLoader: CSS 파일을 처리하기 위한 Rspack 내장 lightningcss loader\n * styleLoader: CSS를 DOM에 주입하는 loader\n * cssLoader: CSS 파일을 해석하고 CSS 모듈화를 처리하는 loader\n * lessLoader: Less 파일을 CSS로 컴파일하는 loader\n * styleResourcesLoader: 전역 스타일 리소스(예: 변수, mixins)를 자동으로 가져오는 loader\n * workerRspackLoader: Web Worker 파일을 처리하는 loader\n\n이러한 상수를 사용하여 구성에서 내장 loader를 참조할 수 있으며, 수동으로 문자열을 입력할 필요가 없습니다:\n\n\n\n주의사항:\n\n * 이러한 loader는 Rspack에 내장되어 있으므로 별도로 설치할 필요가 없습니다.\n * 사용자 정의 loader 구성을 할 때, 이러한 상수를 사용하여 기본 loader 구현을 대체할 수 있습니다.\n * 일부 loader(예: builtinSwcLoader)는 특정 구성 옵션이 있으므로 해당 구성 문서를 참조하십시오.\n\n\n모듈 내보내기#\n\n\nrspack#\n\n@rspack/core 패키지의 모든 내용을 다시 내보내어 Rspack 코어 기능을 완벽하게 제공합니다.","routePath":"/ko/api/app/rspack-vue","lang":"ko","toc":[{"text":"설치","id":"설치","depth":2,"charIndex":113},{"text":"타입 내보내기","id":"타입-내보내기","depth":2,"charIndex":165},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":176},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":369},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":582},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":857},{"text":"함수 내보내기","id":"함수-내보내기","depth":2,"charIndex":932},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":943},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1101},{"text":"상수 내보내기","id":"상수-내보내기","depth":2,"charIndex":1272},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":1283},{"text":"모듈 내보내기","id":"모듈-내보내기","depth":2,"charIndex":2016},{"text":"rspack","id":"rspack","depth":3,"charIndex":2027}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 Vue 빌드 도구","description":"Gez 프레임워크의 Vue 전용 빌드 도구로, Vue 2/3 애플리케이션 빌드를 완벽하게 지원하며, 컴포넌트 개발, SSR 렌더링 및 성능 최적화 등의 기능을 제공합니다.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, 빌드 도구, 컴포넌트 개발, 서버 사이드 렌더링, 성능 최적화"}]]},"version":""},{"id":176,"title":"@gez/rspack","content":"#\n\nRspack 패키지는 Rspack 애플리케이션을 생성하고 설정하기 위한 API를 제공하며, 표준 애플리케이션과 HTML 애플리케이션의 빌드 및\n개발을 지원합니다.\n\n\n설치#\n\n패키지 매니저를 사용하여 @gez/rspack 개발 의존성을 설치합니다:\n\n\n타입 내보내기#\n\n\nBuildTarget#\n\n\n\n빌드 대상 환경 타입으로, 애플리케이션의 빌드 대상 환경을 정의하며, 빌드 과정에서의 특정 최적화와 기능을 설정하는 데 사용됩니다:\n\n * node: Node.js 환경에서 실행되는 코드로 빌드\n * client: 브라우저 환경에서 실행되는 코드로 빌드\n * server: 서버 환경에서 실행되는 코드로 빌드\n\n\nRspackAppConfigContext#\n\n\n\nRspack 애플리케이션 설정 컨텍스트 인터페이스로, 설정 훅 함수에서 접근할 수 있는 컨텍스트 정보를 제공합니다:\n\n * gez: Gez 프레임워크 인스턴스\n * buildTarget: 현재의 빌드 대상 (client/server/node)\n * config: Rspack 설정 객체\n * options: 애플리케이션 설정 옵션\n\n\nRspackAppOptions#\n\n\n\nRspack 애플리케이션 설정 옵션 인터페이스:\n\n * css: CSS 출력 방식, 'css' (독립 파일) 또는 'style' (인라인 스타일) 선택 가능\n * loaders: 사용자 정의 loader 설정\n * styleLoader: style-loader 설정 옵션\n * cssLoader: css-loader 설정 옵션\n * target: 빌드 대상 호환성 설정\n * definePlugin: 전역 상수 정의\n * config: 설정 훅 함수\n\n\nRspackHtmlAppOptions#\n\nRspackAppOptions를 상속받아 HTML 애플리케이션의 특정 옵션을 설정합니다.\n\n\n함수 내보내기#\n\n\ncreateRspackApp#\n\n\n\n표준 Rspack 애플리케이션 인스턴스를 생성합니다.\n\n매개변수:\n\n * gez: Gez 프레임워크 인스턴스\n * options: Rspack 애플리케이션 설정 옵션\n\n반환값:\n\n * 생성된 애플리케이션 인스턴스를 resolve하는 Promise\n\n\ncreateRspackHtmlApp#\n\n\n\nHTML 타입의 Rspack 애플리케이션 인스턴스를 생성합니다.\n\n매개변수:\n\n * gez: Gez 프레임워크 인스턴스\n * options: HTML 애플리케이션 설정 옵션\n\n반환값:\n\n * 생성된 HTML 애플리케이션 인스턴스를 resolve하는 Promise\n\n\n상수 내보내기#\n\n\nRSPACK_LOADER#\n\n\n\nRspack 내장 loader 식별자 매핑 객체로, 자주 사용되는 loader 이름 상수를 제공합니다:\n\n * builtinSwcLoader: TypeScript/JavaScript 파일을 처리하기 위한 Rspack 내장 SWC loader\n * lightningcssLoader: CSS 파일을 처리하기 위한 고성능 컴파일러인 Rspack 내장 lightningcss loader\n * styleLoader: CSS를 DOM에 주입하는 loader\n * cssLoader: CSS 파일을 해석하고 CSS 모듈화를 처리하는 loader\n * lessLoader: Less 파일을 CSS로 컴파일하는 loader\n * styleResourcesLoader: 전역 스타일 리소스(예: 변수, mixins)를 자동으로 가져오는 loader\n * workerRspackLoader: Web Worker 파일을 처리하는 loader\n\n이러한 상수를 사용하여 설정에서 내장 loader를 참조할 수 있으며, 수동으로 문자열을 입력하는 것을 방지할 수 있습니다:\n\n\n\n주의사항:\n\n * 이러한 loader는 Rspack에 내장되어 있어 별도의 설치가 필요하지 않습니다.\n * 사용자 정의 loader 설정 시, 이러한 상수를 사용하여 기본 loader 구현을 대체할 수 있습니다.\n * 일부 loader(예: builtinSwcLoader)는 특정 설정 옵션이 있으므로, 해당 설정 문서를 참조하십시오.\n\n\n모듈 내보내기#\n\n\nrspack#\n\n@rspack/core 패키지의 모든 내용을 재내보내어, Rspack의 핵심 기능을 완전히 제공합니다.","routePath":"/ko/api/app/rspack","lang":"ko","toc":[{"text":"설치","id":"설치","depth":2,"charIndex":95},{"text":"타입 내보내기","id":"타입-내보내기","depth":2,"charIndex":143},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":154},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":345},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":559},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":834},{"text":"함수 내보내기","id":"함수-내보내기","depth":2,"charIndex":909},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":920},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1080},{"text":"상수 내보내기","id":"상수-내보내기","depth":2,"charIndex":1253},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":1264},{"text":"모듈 내보내기","id":"모듈-내보내기","depth":2,"charIndex":2007},{"text":"rspack","id":"rspack","depth":3,"charIndex":2018}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 Rspack 빌드 도구","description":"Gez 프레임워크의 Rspack 빌드 도구는 고성능 애플리케이션 빌드 기능을 제공하며, 표준 애플리케이션과 HTML 애플리케이션의 개발 및 빌드를 지원합니다. 내장된 다양한 리소스 프로세서와 최적화 설정을 포함하고 있습니다.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, 빌드 도구, 애플리케이션 빌드, HTML 애플리케이션, TypeScript, CSS, 리소스 처리, 성능 최적화"}]]},"version":""},{"id":177,"title":"App","content":"#\n\nApp은 Gez 프레임워크의 애플리케이션 추상화로, 애플리케이션의 생명주기, 정적 리소스 및 서버 사이드 렌더링을 관리하기 위한 통합\n인터페이스를 제공합니다.\n\n\n\n\n타입 정의#\n\n\nApp#\n\n\n\nmiddleware#\n\n * 타입: Middleware\n\n정적 리소스 처리 미들웨어.\n\n개발 환경:\n\n * 소스 코드의 정적 리소스 요청 처리\n * 실시간 컴파일 및 핫 리로드 지원\n * no-cache 캐시 정책 사용\n\n프로덕션 환경:\n\n * 빌드된 정적 리소스 처리\n * 불변 파일의 장기 캐싱 지원 (.final.xxx)\n * 최적화된 리소스 로딩 전략\n\n\n\nrender#\n\n * 타입: (options?: RenderContextOptions) => Promise\n\n서버 사이드 렌더링 함수. 실행 환경에 따라 다른 구현 제공:\n\n * 프로덕션 환경 (start): 빌드된 서버 진입 파일(entry.server) 로드 및 렌더링 실행\n * 개발 환경 (dev): 소스 코드의 서버 진입 파일 로드 및 렌더링 실행\n\n\n\nbuild#\n\n * 타입: () => Promise\n\n프로덕션 환경 빌드 함수. 리소스 패키징 및 최적화에 사용. 빌드 성공 시 true 반환, 실패 시 false 반환.\n\ndestroy#\n\n * 타입: () => Promise\n\n리소스 정리 함수. 서버 종료, 연결 해제 등에 사용. 정리 성공 시 true 반환, 실패 시 false 반환.","routePath":"/ko/api/core/app","lang":"ko","toc":[{"text":"타입 정의","id":"타입-정의","depth":2,"charIndex":95},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":112},{"text":"render","id":"render","depth":4,"charIndex":316},{"text":"build","id":"build","depth":4,"charIndex":519},{"text":"destroy","id":"destroy","depth":4,"charIndex":616}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 애플리케이션 추상 인터페이스","description":"Gez 프레임워크의 App 인터페이스에 대해 자세히 설명합니다. 애플리케이션 생명주기 관리, 정적 리소스 처리 및 서버 사이드 렌더링 기능을 포함하여 개발자가 애플리케이션의 핵심 기능을 이해하고 사용할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, App, 애플리케이션 추상, 생명주기, 정적 리소스, 서버 사이드 렌더링, API"}]]},"version":""},{"id":178,"title":"Gez","content":"#\n\n\n소개#\n\nGez는 Rspack 기반의 고성능 웹 애플리케이션 프레임워크로, 완전한 애플리케이션 생명주기 관리, 정적 리소스 처리 및 서버 사이드 렌더링\n기능을 제공합니다.\n\n\n타입 정의#\n\n\nRuntimeTarget#\n\n * 타입 정의:\n\n\n\n애플리케이션 런타임 환경 타입:\n\n * client: 브라우저 환경에서 실행되며, DOM 조작 및 브라우저 API를 지원합니다.\n * server: Node.js 환경에서 실행되며, 파일 시스템 및 서버 사이드 기능을 지원합니다.\n\n\nImportMap#\n\n * 타입 정의:\n\n\n\nES 모듈 임포트 맵 타입.\n\nSpecifierMap#\n\n * 타입 정의:\n\n\n\n모듈 식별자 맵 타입으로, 모듈 임포트 경로의 매핑 관계를 정의합니다.\n\nScopesMap#\n\n * 타입 정의:\n\n\n\n스코프 맵 타입으로, 특정 스코프 내의 모듈 임포트 매핑 관계를 정의합니다.\n\n\nCOMMAND#\n\n * 타입 정의:\n\n\n\n명령어 타입 열거형:\n\n * dev: 개발 환경 명령어로, 개발 서버를 시작하고 핫 리로드를 지원합니다.\n * build: 빌드 명령어로, 프로덕션 환경의 빌드 결과물을 생성합니다.\n * preview: 미리보기 명령어로, 로컬 미리보기 서버를 시작합니다.\n * start: 시작 명령어로, 프로덕션 환경 서버를 실행합니다.\n\n\n인스턴스 옵션#\n\nGez 프레임워크의 핵심 설정 옵션을 정의합니다.\n\n\n\nroot#\n\n * 타입: string\n * 기본값: process.cwd()\n\n프로젝트 �트 디렉토리 경로. 절대 경로 또는 상대 경로를 사용할 수 있으며, 상대 경로는 현재 작업 디렉토리를 기준으로 해석됩니다.\n\nisProd#\n\n * 타입: boolean\n * 기본값: process.env.NODE_ENV === 'production'\n\n환경 식별자.\n\n * true: 프로덕션 환경\n * false: 개발 환경\n\nbasePathPlaceholder#\n\n * 타입: string | false\n * 기본값: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\n기본 경로 플레이스홀더 설정. 런타임에 리소스의 기본 경로를 동적으로 대체하는 데 사용됩니다. false로 설정하면 이 기능을 비활성화할 수\n있습니다.\n\nmodules#\n\n * 타입: ModuleConfig\n\n모듈 설정 옵션. 프로젝트의 모듈 해석 규칙을 구성하며, 모듈 별칭, 외부 종속성 등의 설정을 포함합니다.\n\npacks#\n\n * 타입: PackConfig\n\n패키징 설정 옵션. 빌드 결과물을 표준 npm .tgz 형식의 소프트웨어 패키지로 패키징합니다.\n\ndevApp#\n\n * 타입: (gez: Gez) => Promise\n\n개발 환경 애플리케이션 생성 함수. 개발 환경에서만 사용되며, 개발 서버의 애플리케이션 인스턴스를 생성합니다.\n\n\n\nserver#\n\n * 타입: (gez: Gez) => Promise\n\n서버 시작 설정 함수. HTTP 서버를 구성하고 시작하는 데 사용되며, 개발 환경 및 프로덕션 환경에서 모두 사용할 수 있습니다.\n\n\n\npostBuild#\n\n * 타입: (gez: Gez) => Promise\n\n빌드 후 처리 함수. 프로젝트 빌드가 완료된 후 실행되며, 다음 작업에 사용할 수 있습니다:\n\n * 추가 리소스 처리\n * 배포 작업\n * 정적 파일 생성\n * 빌드 알림 전송\n\n\n인스턴스 속성#\n\n\nname#\n\n * 타입: string\n * 읽기 전용: true\n\n현재 모듈의 이름으로, 모듈 설정에서 가져옵니다.\n\n\nvarName#\n\n * 타입: string\n * 읽기 전용: true\n\n모듈 이름을 기반으로 생성된 유효한 JavaScript 변수 이름.\n\n\nroot#\n\n * 타입: string\n * 읽기 전용: true\n\n프로젝트 루트 디렉토리의 절대 경로. root가 상대 경로로 설정된 경우 현재 작업 디렉토리를 기준으로 해석됩니다.\n\n\nisProd#\n\n * 타입: boolean\n * 읽기 전용: true\n\n현재가 프로덕션 환경인지 여부를 판단합니다. 설정 항목의 isProd를 우선 사용하며, 설정되지 않은 경우\nprocess.env.NODE_ENV를 기준으로 판단합니다.\n\n\nbasePath#\n\n * 타입: string\n * 읽기 전용: true\n * 예외: NotReadyError - 프레임워크가 초기화되지 않은 경우\n\n슬래시로 시작하고 끝나는 모듈 기본 경로를 가져옵니다. 반환 형식은 /${name}/이며, 여기서 name은 모듈 설정에서 가져옵니다.\n\n\nbasePathPlaceholder#\n\n * 타입: string\n * 읽기 전용: true\n\n런타임에 동적으로 대체되는 기본 경로 플레이스홀더를 가져옵니다. 설정을 통해 비활성화할 수 있습니다.\n\n\nmiddleware#\n\n * 타입: Middleware\n * 읽기 전용: true\n\n정적 리소스 처리 미들웨어를 가져옵니다. 환경에 따라 다른 구현을 제공합니다:\n\n * 개발 환경: 소스 코드 실시간 컴파일 및 핫 리로드 지원\n * 프로덕션 환경: 정적 리소스의 장기 캐싱 지원\n\n\n\n\nrender#\n\n * 타입: (options?: RenderContextOptions) => Promise\n * 읽기 전용: true\n\n서버 사이드 렌더링 함수를 가져옵니다. 환경에 따라 다른 구현을 제공합니다:\n\n * 개발 환경: 핫 리로드 및 실시간 미리보기 지원\n * 프로덕션 환경: 최적화된 렌더링 성능 제공\n\n\n\n\nCOMMAND#\n\n * 타입: typeof COMMAND\n * 읽기 전용: true\n\n명령어 열거형 타입 정의를 가져옵니다.\n\n\nmoduleConfig#\n\n * 타입: ParsedModuleConfig\n * 읽기 전용: true\n * 예외: NotReadyError - 프레임워크가 초기화되지 않은 경우\n\n현재 모듈의 완전한 설정 정보를 가져옵니다. 모듈 해석 규칙, 별칭 설정 등을 포함합니다.\n\n\npackConfig#\n\n * 타입: ParsedPackConfig\n * 읽기 전용: true\n * 예외: NotReadyError - 프레임워크가 초기화되지 않은 경우\n\n현재 모듈의 패키징 관련 설정을 가져옵니다. 출력 경로, package.json 처리 등을 포함합니다.\n\n\n인스턴스 메서드#\n\n\nconstructor()#\n\n * 매개변수:\n   * options?: GezOptions - 프레임워크 설정 옵션\n * 반환값: Gez\n\nGez 프레임워크 인스턴스를 생성합니다.\n\n\n\n\ninit()#\n\n * 매개변수: command: COMMAND\n * 반환값: Promise\n * 예외:\n   * Error: 중복 초기화 시\n   * NotReadyError: 초기화되지 않은 인스턴스에 접근 시\n\nGez 프레임워크 인스턴스를 초기화합니다. 다음 핵심 초기화 프로세스를 실행합니다:\n\n 1. 프로젝트 설정 해석 (package.json, 모듈 설정, 패키징 설정 등)\n 2. 애플리케이션 인스턴스 생성 (개발 환경 또는 프로덕션 환경)\n 3. 명령어에 따라 해당 생명주기 메서드 실행\n\n주의\n * 중복 초기화 시 오류가 발생합니다.\n * 초기화되지 않은 인스턴스에 접근 시 NotReadyError가 발생합니다.\n\n\n\n\ndestroy()#\n\n * 반환값: Promise\n\nGez 프레임워크 인스턴스를 파괴하고, 리소스 정리 및 연결 종료 등의 작업을 수행합니다. 주로 다음 작업에 사용됩니다:\n\n * 개발 서버 종료\n * 임시 파일 및 캐시 정리\n * 시스템 리소스 해제\n\n\n\n\nbuild()#\n\n * 반환값: Promise\n\n애플리케이션의 빌드 프로세스를 실행하며, 다음 작업을 포함합니다:\n\n * 소스 코드 컴파일\n * 프로덕션 환경의 빌드 결과물 생성\n * 코드 최적화 및 압축\n * 리소스 매니페스트 생성\n\n주의\n\n프레임워크 인스턴스가 초기화되지 않은 상태에서 호출 시 NotReadyError가 발생합니다.\n\n\n\n\nserver()#\n\n * 반환값: Promise\n * 예외: NotReadyError - 프레임워크가 초기화되지 않은 경우\n\nHTTP 서버 및 설정 서버 인스턴스를 시작합니다. 다음 생명주기에서 호출됩니다:\n\n * 개발 환경 (dev): 개발 서버를 시작하고 핫 리로드를 제공합니다.\n * 프로덕션 환경 (start): 프로덕션 서버를 시작하고 프로덕션 수준의 성능을 제공합니다.\n\n\n\n\npostBuild()#\n\n * 반환값: Promise\n\n빌드 후 처리 로직을 실행하며, 다음 작업에 사용됩니다:\n\n * 정적 HTML 파일 생성\n * 빌드 결과물 처리\n * 배포 작업 실행\n * 빌드 알림 전송\n\n\n\n\nresolvePath#\n\n프로젝트 경로를 해석하여 상대 경로를 절대 경로로 변환합니다.\n\n * 매개변수:\n   \n   * projectPath: ProjectPath - 프로젝트 경로 타입\n   * ...args: string[] - 경로 조각\n\n * 반환값: string - 해석된 절대 경로\n\n * 예제:\n\n\n\n\nwriteSync()#\n\n파일 내용을 동기적으로 작성합니다.\n\n * 매개변수:\n   \n   * filepath: string - 파일의 절대 경로\n   * data: any - 작성할 데이터로, 문자열, Buffer 또는 객체일 수 있습니다.\n\n * 반환값: boolean - 작성 성공 여부\n\n * 예제:\n\n\n\n\nreadJsonSync()#\n\nJSON 파일을 동기적으로 읽고 해석합니다.\n\n * 매개변수:\n   \n   * filename: string - JSON 파일의 절대 경로\n\n * 반환값: any - 해석된 JSON 객체\n\n * 예외: 파일이 존재하지 않거나 JSON 형식이 잘못된 경우 예외가 발생합니다.\n\n * 예제:\n\n\n\n\nreadJson()#\n\nJSON 파일을 비동기적으로 읽고 해석합니다.\n\n * 매개변수:\n   \n   * filename: string - JSON 파일의 절대 경로\n\n * 반환값: Promise - 해석된 JSON 객체\n\n * 예외: 파일이 존재하지 않거나 JSON 형식이 잘못된 경우 예외가 발생합니다.\n\n * 예제:\n\n\n\n\ngetManifestList()#\n\n빌드 매니페스트 목록을 가져옵니다.\n\n * 매개변수:\n   \n   * target: RuntimeTarget - 대상 환경 타입\n     * 'client': 클라이언트 환경\n     * 'server': 서버 환경\n\n * 반환값: Promise - 읽기 전용 빌드 매니페스트 목록\n\n * 예외: 프레임워크 인스턴스가 초기화되지 않은 경우 NotReadyError가 발생합니다.\n\n이 메서드는 지정된 대상 환경의 빌드 매니페","routePath":"/ko/api/core/gez","lang":"ko","toc":[{"text":"소개","id":"소개","depth":2,"charIndex":3},{"text":"타입 정의","id":"타입-정의","depth":2,"charIndex":101},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":110},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":270},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":312},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":381},{"text":"COMMAND","id":"command","depth":3,"charIndex":451},{"text":"인스턴스 옵션","id":"인스턴스-옵션","depth":2,"charIndex":658},{"text":"root","id":"root","depth":4,"charIndex":699},{"text":"isProd","id":"isprod","depth":4,"charIndex":819},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":933},{"text":"modules","id":"modules","depth":4,"charIndex":1103},{"text":"packs","id":"packs","depth":4,"charIndex":1195},{"text":"devApp","id":"devapp","depth":4,"charIndex":1277},{"text":"server","id":"server","depth":4,"charIndex":1381},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":1496},{"text":"인스턴스 속성","id":"인스턴스-속성","depth":2,"charIndex":1639},{"text":"name","id":"name","depth":3,"charIndex":1650},{"text":"varName","id":"varname","depth":3,"charIndex":1717},{"text":"root","id":"root-1","depth":3,"charIndex":1797},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":1901},{"text":"basePath","id":"basepath","depth":3,"charIndex":2037},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":2198},{"text":"middleware","id":"middleware","depth":3,"charIndex":2309},{"text":"render","id":"render","depth":3,"charIndex":2469},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":2650},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":2722},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":2874},{"text":"인스턴스 메서드","id":"인스턴스-메서드","depth":2,"charIndex":3029},{"text":"constructor()","id":"constructor","depth":3,"charIndex":3041},{"text":"init()","id":"init","depth":3,"charIndex":3146},{"text":"destroy()","id":"destroy","depth":3,"charIndex":3502},{"text":"build()","id":"build","depth":3,"charIndex":3647},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":4179},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":4356},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":4532},{"text":"readJson()","id":"readjson","depth":3,"charIndex":4714},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":4897}],"domain":"","frontmatter":{"titleSuffix":"프레임워크 코어 클래스 API 참조","description":"Gez 프레임워크의 코어 클래스 API에 대해 자세히 설명합니다. 애플리케이션 생명주기 관리, 정적 리소스 처리 및 서버 사이드 렌더링 기능을 포함하여 개발자가 프레임워크의 핵심 기능을 깊이 이해할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, API, 생명주기 관리, 정적 리소스, 서버 사이드 렌더링, Rspack, 웹 애플리케이션 프레임워크"}]]},"version":""},{"id":179,"title":"ManifestJson","content":"#\n\nmanifest.json은 Gez 프레임워크가 빌드 과정에서 생성하는 매니페스트 파일로, 서비스 빌드의 산출물 정보를 기록합니다. 이 파일은\n빌드 산출물, 내보내기 파일 및 리소스 크기 통계를 관리하기 위한 통합 인터페이스를 제공합니다.\n\n\n\n\n타입 정의#\n\n\nManifestJson#\n\n\n\nname#\n\n * 타입: string\n\n서비스 이름으로, GezOptions.name 설정에서 가져옵니다.\n\nexports#\n\n * 타입: Record\n\n외부로 내보내는 파일의 매핑 관계로, key는 소스 파일 경로이고 value는 빌드된 파일 경로입니다.\n\nbuildFiles#\n\n * 타입: string[]\n\n빌드 산출물의 전체 파일 목록으로, 생성된 모든 파일 경로를 포함합니다.\n\nchunks#\n\n * 타입: Record\n\n소스 파일과 컴파일된 산출물의 대응 관계로, key는 소스 파일 경로이고 value는 컴파일 정보입니다.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * 타입: string\n\n현재 소스 파일이 컴파일된 JS 파일 경로입니다.\n\ncss#\n\n * 타입: string[]\n\n현재 소스 파일과 연결된 CSS 파일 경로 목록입니다.\n\nresources#\n\n * 타입: string[]\n\n현재 소스 파일과 연결된 기타 리소스 파일 경로 목록입니다.\n\nsizes#\n\n * 타입: ManifestJsonChunkSizes\n\n빌드 산출물의 크기 통계 정보입니다.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * 타입: number\n\nJS 파일 크기(바이트)입니다.\n\ncss#\n\n * 타입: number\n\nCSS 파일 크기(바이트)입니다.\n\nresource#\n\n * 타입: number\n\n리소스 파일 크기(바이트)입니다.","routePath":"/ko/api/core/manifest-json","lang":"ko","toc":[{"text":"타입 정의","id":"타입-정의","depth":2,"charIndex":139},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":165},{"text":"exports","id":"exports","depth":4,"charIndex":226},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":310},{"text":"chunks","id":"chunks","depth":4,"charIndex":382},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":467},{"text":"js","id":"js","depth":4,"charIndex":490},{"text":"css","id":"css","depth":4,"charIndex":539},{"text":"resources","id":"resources","depth":4,"charIndex":594},{"text":"sizes","id":"sizes","depth":4,"charIndex":658},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":720},{"text":"js","id":"js-1","depth":4,"charIndex":747},{"text":"css","id":"css-1","depth":4,"charIndex":786},{"text":"resource","id":"resource","depth":4,"charIndex":827}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 빌드 매니페스트 파일 참조","description":"Gez 프레임워크의 빌드 매니페스트 파일(manifest.json) 구조를 상세히 설명하며, 빌드 산출물 관리, 파일 매핑 및 리소스 통계 기능을 통해 개발자가 빌드 시스템을 이해하고 사용할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, 빌드 매니페스트, 리소스 관리, 빌드 산출물, 파일 매핑, API"}]]},"version":""},{"id":180,"title":"ModuleConfig","content":"#\n\nModuleConfig는 Gez 프레임워크의 모듈 설정 기능을 제공하며, 모듈의 가져오기 및 내보내기 규칙, 별칭 설정, 외부 종속성 등을\n정의하는 데 사용됩니다.\n\n\n타입 정의#\n\n\nPathType#\n\n * 타입 정의:\n\n\n\n모듈 경로 타입 열거형:\n\n * npm: node_modules의 종속성을 나타냄\n * root: 프로젝트 루트 디렉토리의 파일을 나타냄\n\n\nModuleConfig#\n\n * 타입 정의:\n\n\n\n모듈 설정 인터페이스로, 서비스의 내보내기, 가져오기 및 외부 종속성 설정을 정의하는 데 사용됩니다.\n\nexports#\n\n내보내기 설정 목록으로, 서비스의 특정 코드 단위(예: 컴포넌트, 유틸리티 함수 등)를 ESM 형식으로 외부에 노출합니다.\n\n두 가지 타입을 지원합니다:\n\n * root:*: 소스 코드 파일을 내보냄, 예: 'root:src/components/button.vue'\n * npm:*: 서드파티 종속성을 내보냄, 예: 'npm:vue'\n\nimports#\n\n가져오기 설정 매핑으로, 필요한 원격 모듈과 해당 로컬 경로를 설정합니다.\n\n설치 방식에 따라 설정이 다릅니다:\n\n * 소스 코드 설치(Workspace, Git): dist 디렉토리를 가리켜야 함\n * 패키지 설치(Link, 정적 서버, 프라이빗 미러, File): 패키지 디렉토리를 직접 가리킴\n\nexternals#\n\n외부 종속성 매핑으로, 사용할 외부 종속성을 설정하며, 일반적으로 원격 모듈의 종속성을 사용합니다.\n\n예제:\n\n\n\n\nParsedModuleConfig#\n\n * 타입 정의:\n\n\n\n파싱된 모듈 설정으로, 원본 모듈 설정을 표준화된 내부 형식으로 변환합니다:\n\nname#\n\n현재 서비스의 이름\n\n * 모듈을 식별하고 가져오기 경로를 생성하는 데 사용됨\n\nroot#\n\n현재 서비스의 루트 디렉토리 경로\n\n * 상대 경로를 해석하고 빌드 산출물을 저장하는 데 사용됨\n\nexports#\n\n내보내기 설정 목록\n\n * name: 원본 내보내기 경로, 예: 'npm:vue' 또는 'root:src/components'\n * type: 경로 타입(npm 또는 root)\n * importName: 가져오기 이름, 형식: '${serviceName}/${type}/${path}'\n * exportName: 서비스 루트 디렉토리를 기준으로 한 내보내기 경로\n * exportPath: 실제 파일 경로\n * externalName: 외부 종속성 이름, 다른 서비스가 이 모듈을 가져올 때 사용하는 식별자\n\nimports#\n\n가져오기 설정 목록\n\n * name: 외부 서비스의 이름\n * localPath: 로컬 저장 경로, 외부 모듈의 빌드 산출물을 저장하는 데 사용됨\n\nexternals#\n\n외부 종속성 매핑\n\n * 모듈의 가져오기 경로를 실제 모듈 위치에 매핑\n * match: 가져오기 문을 매칭하는 정규 표현식\n * import: 실제 모듈 경로","routePath":"/ko/api/core/module-config","lang":"ko","toc":[{"text":"타입 정의","id":"타입-정의","depth":2,"charIndex":96},{"text":"PathType","id":"pathtype","depth":3,"charIndex":105},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":294},{"text":"imports","id":"imports","depth":4,"charIndex":492},{"text":"externals","id":"externals","depth":4,"charIndex":670},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":747},{"text":"name","id":"name","depth":4,"charIndex":825},{"text":"root","id":"root","depth":4,"charIndex":877},{"text":"exports","id":"exports-1","depth":4,"charIndex":939},{"text":"imports","id":"imports-1","depth":4,"charIndex":1234},{"text":"externals","id":"externals-1","depth":4,"charIndex":1327}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 모듈 설정 API 참조","description":"Gez 프레임워크의 ModuleConfig 설정 인터페이스에 대해 자세히 설명하며, 모듈 가져오기 및 내보내기 규칙, 별칭 설정, 외부 종속성 관리 등을 포함하여 개발자가 프레임워크의 모듈화 시스템을 깊이 이해할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, 모듈 설정, 모듈 가져오기 내보내기, 외부 종속성, 별칭 설정, 종속성 관리, 웹 애플리케이션 프레임워크"}]]},"version":""},{"id":181,"title":"PackConfig","content":"#\n\nPackConfig는 소프트웨어 패키지 패키징 설정 인터페이스로, 서비스의 빌드 결과물을 표준 npm .tgz 형식의 소프트웨어 패키지로\n패키징하는 데 사용됩니다.\n\n * 표준화: npm 표준 .tgz 패키징 형식 사용\n * 완전성: 모듈의 소스 코드, 타입 선언 및 설정 파일 등 모든 필요한 파일 포함\n * 호환성: npm 생태계와 완벽하게 호환되며, 표준 패키지 관리 워크플로우 지원\n\n\n타입 정의#\n\n\n\n\nPackConfig#\n\nenable#\n\n패키징 기능을 활성화할지 여부. 활성화하면 빌드 결과물을 표준 npm .tgz 형식의 소프트웨어 패키지로 패키징합니다.\n\n * 타입: boolean\n * 기본값: false\n\noutputs#\n\n출력할 소프트웨어 패키지 파일 경로를 지정합니다. 다음 설정 방식을 지원합니다:\n\n * string: 단일 출력 경로, 예: 'dist/versions/my-app.tgz'\n * string[]: 여러 출력 경로, 여러 버전을 동시에 생성할 때 사용\n * boolean: true일 때 기본 경로 'dist/client/versions/latest.tgz' 사용\n\npackageJson#\n\npackage.json 내용을 사용자 정의하는 콜백 함수. 패키징 전에 호출되며, package.json 내용을 사용자 정의하는 데 사용됩니다.\n\n * 매개변수:\n   * gez: Gez - Gez 인스턴스\n   * pkg: any - 원본 package.json 내용\n * 반환값: Promise - 수정된 package.json 내용\n\n일반적인 용도:\n\n * 패키지 이름 및 버전 번호 수정\n * 의존성 추가 또는 업데이트\n * 사용자 정의 필드 추가\n * 릴리스 관련 정보 설정\n\n예제:\n\n\n\nonBefore#\n\n패키징 전 준비 작업을 위한 콜백 함수.\n\n * 매개변수:\n   * gez: Gez - Gez 인스턴스\n   * pkg: Record - package.json 내용\n * 반환값: Promise\n\n일반적인 용도:\n\n * 추가 파일 추가 (README, LICENSE 등)\n * 테스트 또는 빌드 검증 실행\n * 문서 또는 메타데이터 생성\n * 임시 파일 정리\n\n예제:\n\n\n\nonAfter#\n\n패키징 완료 후 처리 작업을 위한 콜백 함수. .tgz 파일 생성 후 호출되며, 패키징 결과물을 처리하는 데 사용됩니다.\n\n * 매개변수:\n   * gez: Gez - Gez 인스턴스\n   * pkg: Record - package.json 내용\n   * file: Buffer - 패키징된 파일 내용\n * 반환값: Promise\n\n일반적인 용도:\n\n * npm 저장소에 릴리스 (공개 또는 개인)\n * 정적 리소스 서버에 업로드\n * 버전 관리 실행\n * CI/CD 프로세스 트리거\n\n예제:\n\n\n\n\n사용 예제#\n\n","routePath":"/ko/api/core/pack-config","lang":"ko","toc":[{"text":"타입 정의","id":"타입-정의","depth":2,"charIndex":222},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":246},{"text":"outputs","id":"outputs","depth":4,"charIndex":353},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":567},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":860},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1080},{"text":"사용 예제","id":"사용-예제","depth":2,"charIndex":1370}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 패키징 설정 API 참조","description":"Gez 프레임워크의 PackConfig 설정 인터페이스에 대해 자세히 설명합니다. 소프트웨어 패키지 패키징 규칙, 출력 설정 및 라이프사이클 훅을 포함하여 개발자가 표준화된 빌드 프로세스를 구현할 수 있도록 도와줍니다.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, 소프트웨어 패키지 패키징, 빌드 설정, 라이프사이클 훅, 패키징 설정, 웹 애플리케이션 프레임워크"}]]},"version":""},{"id":182,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ko/api/core/render-context","lang":"ko","toc":[{"text":"타입 정의","id":"타입-정의","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"인스턴스 옵션","id":"인스턴스-옵션","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"인스턴스 속성","id":"인스턴스-속성","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"인스턴스 메서드","id":"인스턴스-메서드","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1},{"text":"importmap()","id":"importmap","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 렌더링 컨텍스트 API 참조","description":"Gez 프레임워크의 RenderContext 핵심 클래스에 대해 자세히 설명합니다. 렌더링 제어, 리소스 관리, 상태 동기화 및 라우팅 제어 등의 기능을 포함하여 개발자가 효율적인 서버 사이드 렌더링(SSR)을 구현할 수 있도록 도와줍니다.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, 서버 사이드 렌더링, 렌더링 컨텍스트, 상태 동기화, 리소스 관리, 웹 애플리케이션 프레임워크"}]]},"version":""},{"id":183,"title":"컴포넌트 공유에서 네이티브 모듈화까지: Gez 마이크로 프론트엔드 프레임워크의 진화 과정","content":"#\n\n\n프로젝트 배경#\n\n지난 몇 년 동안, 마이크로 프론트엔드 아키텍처는 올바른 길을 찾기 위해 노력해 왔습니다. 그러나 우리가 본 것은 다양한 복잡한 기술적\n해결책들이었으며, 이들은 이상적인 마이크로 프론트엔드 세계를 모방하기 위해 여러 겹의 포장과 인위적인 격리를 사용했습니다. 이러한 해결책들은\n심각한 성능 부담을 가져왔고, 간단한 개발을 복잡하게 만들며, 표준적인 프로세스를 난해하게 만들었습니다.\n\n\n전통적인 해결책의 한계#\n\n마이크로 프론트엔드 아키텍처를 실천하는 과정에서, 우리는 전통적인 해결책의 여러 제한 사항을 깊이 깨달았습니다:\n\n * 성능 손실: 런타임에 의존성 주입, JS 샌드박스 프록시, 모든 작업이 소중한 성능을 소모합니다.\n * 취약한 격리: 인위적으로 만든 샌드박스 환경은 브라우저의 네이티브 격리 능력에 도달할 수 없습니다.\n * 빌드 복잡성: 의존성 관계를 처리하기 위해 빌드 도구를 수정해야 하며, 간단한 프로젝트를 유지하기 어렵게 만듭니다.\n * 맞춤형 규칙: 특별한 배포 전략, 런타임 처리, 모든 단계가 현대 개발의 표준 프로세스에서 벗어납니다.\n * 생태계 제한: 프레임워크 결합, 맞춤형 API, 기술 선택이 특정 생태계에 묶이게 됩니다.\n\n이러한 문제들은 2019년의 한 기업급 프로젝트에서 특히 두드러졌습니다. 당시, 대형 제품이 독립적인 비즈니스 하위 시스템으로 분할되었으며,\n이러한 하위 시스템들은 기본 컴포넌트와 비즈니스 컴포넌트를 공유해야 했습니다. 초기에 npm 패키지 기반의 컴포넌트 공유 해결책을 사용했지만,\n실제로는 심각한 유지 보수 효율성 문제가 드러났습니다: 공유 컴포넌트가 업데이트될 때, 해당 컴포넌트에 의존하는 모든 하위 시스템은 완전한\n빌드와 배포 프로세스를 거쳐야 했습니다.\n\n\n기술 진화#\n\n\nv1.0: 원격 컴포넌트 탐구#\n\n컴포넌트 공유의 효율성 문제를 해결하기 위해, Gez v1.0은 HTTP 프로토콜 기반의 RemoteView 컴포넌트 메커니즘을 도입했습니다.\n이 해결책은 런타임에 동적으로 요청하는 방식으로 서비스 간의 코드를 필요에 따라 조립할 수 있게 하여, 빌드 의존성 체인이 너무 길어지는 문제를\n해결했습니다. 그러나 표준화된 런타임 통신 메커니즘이 부족하여, 서비스 간의 상태 동기화와 이벤트 전달은 여전히 효율성 문제가 있었습니다.\n\n\nv2.0: 모듈 연합 시도#\n\nv2.0 버전에서, 우리는 Webpack 5.0의 모듈 연합(Module Federation) 기술을 사용했습니다. 이 기술은 통일된 모듈 로딩\n메커니즘과 런타임 컨테이너를 통해 서비스 간의 협업 효율성을 크게 향상시켰습니다. 그러나 대규모 실천에서, 모듈 연합의 폐쇄형 구현 메커니즘은\n새로운 도전을 가져왔습니다: 정확한 의존성 버전 관리가 어려웠으며, 특히 여러 서비스의 공유 의존성을 통일할 때, 버전 충돌과 런타임 예외가\n자주 발생했습니다.\n\n\nESM 신시대를 맞이하며#\n\nv3.0 버전을 계획할 때, 우리는 프론트엔드 생태계의 발전 추세를 깊이 관찰했으며, 브라우저의 네이티브 능력의 발전이 마이크로 프론트엔드\n아키텍처에 새로운 가능성을 가져왔음을 발견했습니다:\n\n\n표준화된 모듈 시스템#\n\n주요 브라우저들이 ES Modules를 전면적으로 지원하고, Import Maps 규격이 성숙해짐에 따라, 프론트엔드 개발은 진정한 모듈화\n시대를 맞이했습니다. Can I Use의 통계에 따르면, 현재 주요 브라우저(Chrome >= 89, Edge >= 89, Firefox >=\n108, Safari >= 16.4)의 ESM 네이티브 지원률은 93.5%에 달하며, 이는 우리에게 다음과 같은 이점을 제공합니다:\n\n * 의존성 관리 표준화: Import Maps는 브라우저 수준에서 모듈 의존성을 해결할 수 있는 능력을 제공하며, 복잡한 런타임 주입이 필요\n   없습니다.\n * 리소스 로딩 최적화: 브라우저의 네이티브 모듈 캐싱 메커니즘은 리소스 로딩 효율성을 크게 향상시킵니다.\n * 빌드 프로세스 단순화: ESM 기반의 개발 모드는 개발 환경과 프로덕션 환경의 빌드 프로세스를 더욱 일관되게 만듭니다.\n\n동시에, 호환 모드 지원(Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14)을 통해, 우리는\n브라우저 커버리지를 96.81%까지 더욱 향상시킬 수 있으며, 이는 고성능을 유지하면서도 구형 브라우저에 대한 지원을 희생하지 않을 수 있게\n합니다.\n\n\n성능과 격리의 돌파#\n\n네이티브 모듈 시스템이 가져온 것은 표준화뿐만 아니라, 성능과 격리성의 질적인 향상입니다:\n\n * 런타임 오버헤드 제로: 전통적인 마이크로 프론트엔드 해결책의 JavaScript 샌드박스 프록시와 런타임 주입을 더 이상 사용하지\n   않습니다.\n * 신뢰할 수 있는 격리 메커니즘: ESM의 엄격한 모듈 스코프는 가장 신뢰할 수 있는 격리 능력을 제공합니다.\n * 정확한 의존성 관리: 정적 임포트 분석은 의존성 관계를 더욱 명확하게 만들며, 버전 제어를 더욱 정확하게 만듭니다.\n\n\n빌드 도구 선택#\n\n기술 해결책의 실천 과정에서, 빌드 도구 선택은 중요한 결정점입니다. 거의 1년간의 기술 조사와 실천을 통해, 우리의 선택은 다음과 같은 진화를\n거쳤습니다:\n\n 1. Vite 탐구\n    \n    * 장점: ESM 기반의 개발 서버, 최고의 개발 경험 제공\n    * 도전: 개발 환경과 프로덕션 환경의 빌드 차이로 인해 일부 불확실성이 발생\n\n 2. Rspack 확정\n    \n    * 성능 장점: Rust 기반의 고성능 컴파일, 빌드 속도 크게 향상\n    * 생태계 지원: Webpack 생태계와의 높은 호환성, 마이그레이션 비용 감소\n    * ESM 지원: Rslib 프로젝트의 실천을 통해, ESM 빌드 측면에서의 신뢰성 검증\n\n이 결정은 우리가 개발 경험을 유지하면서도 더 안정적인 프로덕션 환경 지원을 얻을 수 있게 했습니다. ESM과 Rspack의 조합을 통해,\n우리는 고성능, 낮은 침입성의 마이크로 프론트엔드 해결책을 최종적으로 구축했습니다.\n\n\n미래 전망#\n\n미래의 발전 계획에서, Gez 프레임워크는 다음 세 가지 방향에 중점을 둘 것입니다:\n\n\nImport Maps 심화 최적화#\n\n * 동적 의존성 관리: 런타임 의존성 버전의 지능형 스케줄링 구현, 다중 애플리케이션 간의 의존성 충돌 해결\n * 프리로딩 전략: 라우팅 분석 기반의 지능형 프리로딩, 리소스 로딩 효율성 향상\n * 빌드 최적화: 최적의 Import Maps 설정 자동 생성, 개발자의 수동 설정 비용 감소\n\n\n프레임워크 독립적인 라우팅 해결책#\n\n * 통일된 라우팅 추상화: Vue, React 등 주요 프레임워크를 지원하는 프레임워크 독립적인 라우팅 인터페이스 설계\n * 마이크로 애플리케이션 라우팅: 애플리케이션 간의 라우팅 연동 구현, URL과 애플리케이션 상태의 일관성 유지\n * 라우팅 미들웨어: 확장 가능한 미들웨어 메커니즘 제공, 권한 제어, 페이지 전환 등의 기능 지원\n\n\n프레임워크 간 통신 최적의 실천#\n\n * 예제 애플리케이션: Vue, React, Preact 등 주요 프레임워크를 포함한 완전한 프레임워크 간 통신 예제 제공\n * 상태 동기화: ESM 기반의 경량 상태 공유 해결책 구현\n * 이벤트 버스: 표준화된 이벤트 통신 메커니즘, 애플리케이션 간의 분리된 통신 지원\n\n이러한 최적화와 확장을 통해, 우리는 Gez를 더욱 완벽하고 사용하기 쉬운 마이크로 프론트엔드 해결책으로 만들고자 하며, 개발자들에게 더 나은\n개발 경험과 더 높은 개발 효율성을 제공하고자 합니다.","routePath":"/ko/blog/birth-of-gez","lang":"ko","toc":[{"text":"프로젝트 배경","id":"프로젝트-배경","depth":2,"charIndex":3},{"text":"전통적인 해결책의 한계","id":"전통적인-해결책의-한계","depth":3,"charIndex":229},{"text":"기술 진화","id":"기술-진화","depth":2,"charIndex":871},{"text":"v1.0: 원격 컴포넌트 탐구","id":"v10-원격-컴포넌트-탐구","depth":3,"charIndex":880},{"text":"v2.0: 모듈 연합 시도","id":"v20-모듈-연합-시도","depth":3,"charIndex":1140},{"text":"ESM 신시대를 맞이하며","id":"esm-신시대를-맞이하며","depth":2,"charIndex":1410},{"text":"표준화된 모듈 시스템","id":"표준화된-모듈-시스템","depth":3,"charIndex":1535},{"text":"성능과 격리의 돌파","id":"성능과-격리의-돌파","depth":3,"charIndex":2167},{"text":"빌드 도구 선택","id":"빌드-도구-선택","depth":3,"charIndex":2451},{"text":"미래 전망","id":"미래-전망","depth":2,"charIndex":2948},{"text":"Import Maps 심화 최적화","id":"import-maps-심화-최적화","depth":3,"charIndex":3006},{"text":"프레임워크 독립적인 라우팅 해결책","id":"프레임워크-독립적인-라우팅-해결책","depth":3,"charIndex":3192},{"text":"프레임워크 간 통신 최적의 실천","id":"프레임워크-간-통신-최적의-실천","depth":3,"charIndex":3404}],"domain":"","frontmatter":{"titleSuffix":"마이크로 프론트엔드의 어려움에서 ESM 혁신까지: Gez 프레임워크의 진화 과정","description":"Gez 프레임워크가 전통적인 마이크로 프론트엔드 아키텍처의 어려움에서 ESM 기반의 혁신적인 돌파구를 찾아가는 과정을 깊이 있게 탐구하며, 성능 최적화, 의존성 관리, 빌드 도구 선택 등의 기술적 실천 경험을 공유합니다.","head":[["meta",{"property":"keywords","content":"Gez, 마이크로 프론트엔드 프레임워크, ESM, Import Maps, Rspack, 모듈 연합, 의존성 관리, 성능 최적화, 기술 진화, 서버 사이드 렌더링"}]],"sidebar":false},"version":""},{"id":184,"title":"팀 블로그","content":"#\n\nGez 팀의 기술 블로그에 오신 것을 환영합니다! 여기서는 프레임워크 개발 과정에서의 경험, 기술 혁신 및 베스트 프랙티스를 공유합니다.\n\n\n최신 글#\n\n * 2025-02-25 컴포넌트 공유에서 네이티브 모듈화까지: Gez 마이크로 프론트엔드 프레임워크의 진화\n   \n   > Gez 프레임워크가 전통적인 컴포넌트 공유에서 ESM 기반의 네이티브 모듈화로 진화한 과정을 탐구하며, 성능 최적화, 의존성 관리 및\n   > 빌드 도구 선택 등의 기술적 실무 경험을 공유합니다.","routePath":"/ko/blog/","lang":"ko","toc":[{"text":"최신 글","id":"최신-글","depth":2,"charIndex":81}],"domain":"","frontmatter":{"titleSuffix":"Gez 팀 블로그","description":"Gez 팀의 기술 블로그로, 프레임워크 개발 경험, 베스트 프랙티스 및 기술 혁신을 공유합니다.","head":[["meta",{"property":"keywords","content":"Gez, 팀 블로그, 기술 공유, 베스트 프랙티스, 개발 경험"}]],"sidebar":false},"version":""},{"id":185,"title":"경로 별칭","content":"#\n\n경로 별칭(Path Alias)은 모듈 임포트 경로 매핑 메커니즘으로, 개발자가 완전한 모듈 경로 대신 짧고 의미 있는 식별자를 사용할 수 있게\n해줍니다. Gez에서 경로 별칭 메커니즘은 다음과 같은 장점을 제공합니다:\n\n * 임포트 경로 단순화: 의미 있는 별칭을 사용하여 긴 상대 경로를 대체함으로써 코드 가독성을 높입니다.\n * 깊은 중첩 방지: ../../../../와 같은 다중 디렉토리 참조로 인한 유지보수 어려움을 해결합니다.\n * 타입 안전성: TypeScript의 타입 시스템과 완전히 통합되어 코드 완성 및 타입 검사를 제공합니다.\n * 모듈 해석 최적화: 미리 정의된 경로 매핑을 통해 모듈 해석 성능을 향상시킵니다.\n\n\n기본 별칭 메커니즘#\n\nGez는 서비스 이름(Service Name) 기반의 자동 별칭 메커니즘을 사용하며, 이는 설정보다 규약을 우선하는 설계로 다음과 같은 특징을\n가집니다:\n\n * 자동 구성: package.json의 name 필드를 기반으로 별칭이 자동 생성되며, 수동 설정이 필요 없습니다.\n * 통일된 규범: 모든 서비스 모듈이 일관된 명명 및 참조 규칙을 따르도록 보장합니다.\n * 타입 지원: npm run build:dts 명령어와 함께 사용하여 타입 선언 파일을 자동 생성함으로써, 서비스 간 타입 추론을 가능하게\n   합니다.\n * 예측 가능성: 서비스 이름을 통해 모듈 참조 경로를 추론할 수 있어 유지보수 비용을 줄입니다.\n\n\n설정 설명#\n\n\npackage.json 설정#\n\npackage.json에서 name 필드를 통해 서비스 이름을 정의하며, 이 이름은 서비스의 기본 별칭 접두사로 사용됩니다:\n\n\n\n\ntsconfig.json 설정#\n\nTypeScript가 별칭 경로를 올바르게 해석할 수 있도록 tsconfig.json에서 paths 매핑을 설정해야 합니다:\n\n\n\n\n사용 예제#\n\n\n서비스 내부 모듈 임포트#\n\n\n\n\n다른 서비스 모듈 임포트#\n\n\n\n최적의 실천 방법\n * 상대 경로보다 별칭 경로를 우선적으로 사용합니다.\n * 별칭 경로의 의미와 일관성을 유지합니다.\n * 별칭 경로에서 너무 많은 디렉토리 계층을 사용하지 않습니다.\n\n\n\n\n서비스 간 임포트#\n\n모듈 링크(Module Link)가 구성된 경우, 동일한 방식으로 다른 서비스의 모듈을 임포트할 수 있습니다:\n\n\n\n\n사용자 정의 별칭#\n\n서드파티 패키지나 특수한 상황을 위해 Gez 설정 파일을 통해 사용자 정의 별칭을 설정할 수 있습니다:\n\n\n\n주의 사항\n 1. 비즈니스 모듈의 경우, 프로젝트의 일관성을 유지하기 위해 기본 별칭 메커니즘을 항상 사용하는 것이 좋습니다.\n 2. 사용자 정의 별칭은 주로 서드파티 패키지의 특수 요구 사항이나 개발 경험을 최적화하는 데 사용됩니다.\n 3. 사용자 정의 별칭을 과도하게 사용하면 코드의 유지보수성과 빌드 최적화에 영향을 미칠 수 있습니다.","routePath":"/ko/guide/essentials/alias","lang":"ko","toc":[{"text":"기본 별칭 메커니즘","id":"기본-별칭-메커니즘","depth":2,"charIndex":361},{"text":"설정 설명","id":"설정-설명","depth":2,"charIndex":724},{"text":"package.json 설정","id":"packagejson-설정","depth":3,"charIndex":733},{"text":"tsconfig.json 설정","id":"tsconfigjson-설정","depth":3,"charIndex":825},{"text":"사용 예제","id":"사용-예제","depth":2,"charIndex":918},{"text":"서비스 내부 모듈 임포트","id":"서비스-내부-모듈-임포트","depth":3,"charIndex":927},{"text":"다른 서비스 모듈 임포트","id":"다른-서비스-모듈-임포트","depth":3,"charIndex":946},{"text":"서비스 간 임포트","id":"서비스-간-임포트","depth":3,"charIndex":1072},{"text":"사용자 정의 별칭","id":"사용자-정의-별칭","depth":3,"charIndex":1150}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 모듈 임포트 경로 매핑 가이드","description":"Gez 프레임워크의 경로 별칭(Path Alias) 메커니즘에 대해 자세히 설명합니다. 이는 임포트 경로 단순화, 깊은 중첩 방지, 타입 안전성, 모듈 해석 최적화 등의 기능을 포함하며, 개발자가 코드 유지보수성을 향상시키는 데 도움을 줍니다.","head":[["meta",{"property":"keywords","content":"Gez, 경로 별칭, Path Alias, TypeScript, 모듈 임포트, 경로 매핑, 코드 유지보수성"}]]},"version":""},{"id":186,"title":"기본 경로","content":"#\n\n기본 경로(Base Path)는 애플리케이션에서 JavaScript, CSS, 이미지 등의 정적 리소스에 접근하기 위한 경로 접두사입니다.\nGez에서 기본 경로를 적절히 설정하는 것은 다음과 같은 시나리오에서 중요합니다:\n\n * 다중 환경 배포: 개발 환경, 테스트 환경, 프로덕션 환경 등 다양한 환경에서의 리소스 접근 지원\n * 다중 지역 배포: 다양한 지역 또는 국가의 클러스터 배포 요구 사항에 적응\n * CDN 분산: 정적 리소스의 글로벌 분산 및 가속화 구현\n\n\n기본 경로 메커니즘#\n\nGez는 서비스 이름을 기반으로 한 자동 경로 생성 메커니즘을 사용합니다. 기본적으로 프레임워크는 프로젝트의 package.json 파일에 있는\nname 필드를 읽어 정적 리소스의 기본 경로를 생성합니다: /your-app-name/.\n\n\n\n이러한 설정보다 우선하는 설계는 다음과 같은 장점이 있습니다:\n\n * 일관성: 모든 정적 리소스가 통일된 접근 경로를 사용하도록 보장\n * 예측 가능성: package.json의 name 필드를 통해 리소스의 접근 경로를 추론 가능\n * 유지 보수성: 추가 설정 없이 유지 보수 비용 절감\n\n\n동적 경로 설정#\n\n실제 프로젝트에서는 동일한 코드를 다양한 환경이나 지역에 배포해야 하는 경우가 많습니다. Gez는 동적 기본 경로를 지원하여 애플리케이션이\n다양한 배포 시나리오에 적응할 수 있도록 합니다.\n\n\n사용 시나리오#\n\n서브 디렉토리 배포#\n\n\n\n독립 도메인 배포#\n\n\n\n\n설정 방법#\n\ngez.render() 메서드의 base 매개변수를 통해 요청 컨텍스트에 따라 기본 경로를 동적으로 설정할 수 있습니다:\n\n","routePath":"/ko/guide/essentials/base-path","lang":"ko","toc":[{"text":"기본 경로 메커니즘","id":"기본-경로-메커니즘","depth":2,"charIndex":267},{"text":"동적 경로 설정","id":"동적-경로-설정","depth":2,"charIndex":579},{"text":"사용 시나리오","id":"사용-시나리오","depth":3,"charIndex":698},{"text":"서브 디렉토리 배포","id":"서브-디렉토리-배포","depth":4,"charIndex":708},{"text":"독립 도메인 배포","id":"독립-도메인-배포","depth":4,"charIndex":723},{"text":"설정 방법","id":"설정-방법","depth":3,"charIndex":738}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 정적 리소스 경로 설정 가이드","description":"Gez 프레임워크의 기본 경로 설정에 대해 자세히 설명하며, 다중 환경 배포, CDN 분산 및 리소스 접근 경로 설정을 포함하여 개발자가 유연한 정적 리소스 관리를 구현할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, 기본 경로, Base Path, CDN, 정적 리소스, 다중 환경 배포, 리소스 관리"}]]},"version":""},{"id":187,"title":"클라이언트 사이드 렌더링","content":"\n${rc.importmap()} // 임포트 맵 ${rc.moduleEntry()} // 엔트리 모듈 ${rc.modulePreload()}\n// 모듈 프리로드","routePath":"/ko/guide/essentials/csr","lang":"ko","toc":[{"text":"사용 시나리오","id":"사용-시나리오","depth":2,"charIndex":-1},{"text":"설정 설명","id":"설정-설명","depth":2,"charIndex":-1},{"text":"HTML 템플릿 설정","id":"html-템플릿-설정","depth":3,"charIndex":-1},{"text":"정적 HTML 생성","id":"정적-html-생성","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 클라이언트 사이드 렌더링 구현 가이드","description":"Gez 프레임워크의 클라이언트 사이드 렌더링 메커니즘을 상세히 설명하며, 정적 빌드, 배포 전략 및 모범 사례를 포함하여 서버리스 환경에서 효율적인 프론트엔드 렌더링을 구현하는 방법을 안내합니다.","head":[["meta",{"property":"keywords","content":"Gez, 클라이언트 사이드 렌더링, CSR, 정적 빌드, 프론트엔드 렌더링, 서버리스 배포, 성능 최적화"}]]},"version":""},{"id":188,"title":"모듈 링크","content":"#\n\nGez 프레임워크는 서비스 간 코드 공유와 의존성 관리를 위한 완전한 모듈 링크 메커니즘을 제공합니다. 이 메커니즘은 ESM(ECMAScript\nModule) 규격을 기반으로 구현되었으며, 소스 코드 수준의 모듈 내보내기 및 가져오기와 완전한 의존성 관리 기능을 지원합니다.\n\n\n핵심 개념#\n\n모듈 내보내기#\n\n모듈 내보내기는 서비스 내의 특정 코드 단위(예: 컴포넌트, 유틸리티 함수 등)를 ESM 형식으로 외부에 노출하는 과정입니다. 두 가지 내보내기\n유형을 지원합니다:\n\n * 소스 코드 내보내기: 프로젝트 내의 소스 코드 파일을 직접 내보냄\n * 의존성 내보내기: 프로젝트에서 사용하는 서드파티 의존성 패키지를 내보냄\n\n모듈 가져오기#\n\n모듈 가져오기는 서비스에서 다른 서비스가 내보낸 코드 단위를 참조하는 과정입니다. 여러 설치 방식을 지원합니다:\n\n * 소스 코드 설치: 개발 환경에 적합하며, 실시간 수정 및 핫 리로드를 지원\n * 패키지 설치: 프로덕션 환경에 적합하며, 빌드 결과물을 직접 사용\n\n\n사전 로딩 메커니즘#\n\n서비스 성능을 최적화하기 위해 Gez는 지능형 모듈 사전 로딩 메커니즘을 구현했습니다:\n\n 1. 의존성 분석\n    \n    * 빌드 시 컴포넌트 간 의존성 관계 분석\n    * 핵심 경로 상의 주요 모듈 식별\n    * 모듈 로딩 우선순위 결정\n\n 2. 로딩 전략\n    \n    * 즉시 로딩: 핵심 경로 상의 주요 모듈\n    * 지연 로딩: 비핵심 기능 모듈\n    * 필요 시 로딩: 조건부 렌더링 모듈\n\n 3. 리소스 최적화\n    \n    * 지능형 코드 분할 전략\n    * 모듈 수준의 캐시 관리\n    * 필요 시 컴파일 및 패키징\n\n\n모듈 내보내기#\n\n\n설정 설명#\n\nentry.node.ts에서 내보낼 모듈을 설정합니다:\n\n\n\n내보내기 설정은 두 가지 유형을 지원합니다:\n\n * root:*: 소스 코드 파일 내보내기, 경로는 프로젝트 루트 디렉토리를 기준으로 함\n * npm:*: 서드파티 의존성 내보내기, 패키지 이름을 직접 지정\n\n\n모듈 가져오기#\n\n\n설정 설명#\n\nentry.node.ts에서 가져올 모듈을 설정합니다:\n\n\n\n설정 항목 설명:\n\n 1. imports: 원격 모듈의 로컬 경로 설정\n    \n    * 소스 코드 설치: 빌드 결과물 디렉토리(dist) 지정\n    * 패키지 설치: 패키지 디렉토리 직접 지정\n\n 2. externals: 외부 의존성 설정\n    \n    * 원격 모듈의 의존성 공유\n    * 동일 의존성 중복 패키징 방지\n    * 여러 모듈 간 의존성 공유 지원\n\n\n설치 방식#\n\n소스 코드 설치#\n\n개발 환경에 적합하며, 실시간 수정 및 핫 리로드를 지원합니다.\n\n 1. Workspace 방식 Monorepo 프로젝트에서 사용 권장:\n\n\n\n 2. Link 방식 로컬 개발 디버깅에 사용:\n\n\n\n패키지 설치#\n\n프로덕션 환경에 적합하며, 빌드 결과물을 직접 사용합니다.\n\n 1. NPM Registry npm registry를 통해 설치:\n\n\n\n 2. 정적 서버 HTTP/HTTPS 프로토콜을 통해 설치:\n\n\n\n\n패키지 빌드#\n\n\n설정 설명#\n\nentry.node.ts에서 빌드 옵션을 설정합니다:\n\n\n\n\n빌드 결과물#\n\n\n\n\n배포 프로세스#\n\n\n\n\n모범 사례#\n\n\n개발 환경 설정#\n\n * 의존성 관리\n   \n   * Workspace 또는 Link 방식으로 의존성 설치\n   * 의존성 버전 통합 관리\n   * 동일 의존성 중복 설치 방지\n\n * 개발 경험\n   \n   * 핫 리로드 기능 활성화\n   * 적절한 사전 로딩 전략 설정\n   * 빌드 속도 최적화\n\n\n프로덕션 환경 설정#\n\n * 배포 전략\n   \n   * NPM Registry 또는 정적 서버 사용\n   * 빌드 결과물 무결성 보장\n   * 그레이스케일 배포 메커니즘 적용\n\n * 성능 최적화\n   \n   * 리소스 사전 로딩 적절히 설정\n   * 모듈 로딩 순서 최적화\n   * 효과적인 캐시 전략 적용\n\n\n버전 관리#\n\n * 버전 규칙\n   \n   * 시맨틱 버전 규칙 준수\n   * 상세한 변경 로그 유지\n   * 버전 호환성 테스트 수행\n\n * 의존성 업데이트\n   \n   * 의존성 패키지 정기 업데이트\n   * 정기적인 보안 감사 수행\n   * 의존성 버전 일관성 유지\n\n","routePath":"/ko/guide/essentials/module-link","lang":"ko","toc":[{"text":"핵심 개념","id":"핵심-개념","depth":3,"charIndex":158},{"text":"모듈 내보내기","id":"모듈-내보내기","depth":4,"charIndex":166},{"text":"모듈 가져오기","id":"모듈-가져오기","depth":4,"charIndex":353},{"text":"사전 로딩 메커니즘","id":"사전-로딩-메커니즘","depth":3,"charIndex":514},{"text":"모듈 내보내기","id":"모듈-내보내기-1","depth":2,"charIndex":837},{"text":"설정 설명","id":"설정-설명","depth":3,"charIndex":848},{"text":"모듈 가져오기","id":"모듈-가져오기-1","depth":2,"charIndex":1008},{"text":"설정 설명","id":"설정-설명-1","depth":3,"charIndex":1019},{"text":"설치 방식","id":"설치-방식","depth":3,"charIndex":1272},{"text":"소스 코드 설치","id":"소스-코드-설치","depth":4,"charIndex":1280},{"text":"패키지 설치","id":"패키지-설치","depth":4,"charIndex":1401},{"text":"패키지 빌드","id":"패키지-빌드","depth":2,"charIndex":1523},{"text":"설정 설명","id":"설정-설명-2","depth":3,"charIndex":1533},{"text":"빌드 결과물","id":"빌드-결과물","depth":3,"charIndex":1575},{"text":"배포 프로세스","id":"배포-프로세스","depth":3,"charIndex":1587},{"text":"모범 사례","id":"모범-사례","depth":2,"charIndex":1600},{"text":"개발 환경 설정","id":"개발-환경-설정","depth":3,"charIndex":1609},{"text":"프로덕션 환경 설정","id":"프로덕션-환경-설정","depth":3,"charIndex":1778},{"text":"버전 관리","id":"버전-관리","depth":3,"charIndex":1952}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 서비스 간 코드 공유 메커니즘","description":"Gez 프레임워크의 모듈 링크 메커니즘을 상세히 설명하며, 서비스 간 코드 공유, 의존성 관리 및 ESM 규격 구현을 통해 개발자가 효율적인 마이크로 프론트엔드 애플리케이션을 구축할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, 모듈 링크, Module Link, ESM, 코드 공유, 의존성 관리, 마이크로 프론트엔드"}]]},"version":""},{"id":189,"title":"렌더링 컨텍스트","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ko/guide/essentials/render-context","lang":"ko","toc":[{"text":"사용 방법","id":"사용-방법","depth":2,"charIndex":-1},{"text":"주요 기능","id":"주요-기능","depth":2,"charIndex":-1},{"text":"의존성 수집","id":"의존성-수집","depth":3,"charIndex":-1},{"text":"필요 시 수집","id":"필요-시-수집","depth":4,"charIndex":-1},{"text":"자동화 처리","id":"자동화-처리","depth":4,"charIndex":-1},{"text":"성능 최적화","id":"성능-최적화","depth":4,"charIndex":-1},{"text":"리소스 주입","id":"리소스-주입","depth":3,"charIndex":-1},{"text":"리소스 주입 순서","id":"리소스-주입-순서","depth":3,"charIndex":-1},{"text":"전체 렌더링 프로세스","id":"전체-렌더링-프로세스","depth":2,"charIndex":-1},{"text":"고급 기능","id":"고급-기능","depth":2,"charIndex":-1},{"text":"베이스 경로 설정","id":"베이스-경로-설정","depth":3,"charIndex":-1},{"text":"임포트 매핑 모드","id":"임포트-매핑-모드","depth":3,"charIndex":-1},{"text":"진입 함수 설정","id":"진입-함수-설정","depth":3,"charIndex":-1},{"text":"모범 사례","id":"모범-사례","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 서버 사이드 렌더링 핵심 메커니즘","description":"Gez 프레임워크의 렌더링 컨텍스트(RenderContext) 메커니즘에 대해 자세히 설명합니다. 리소스 관리, HTML 생성 및 ESM 모듈 시스템을 포함하여 개발자가 서버 사이드 렌더링(SSR) 기능을 이해하고 사용할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, 렌더링 컨텍스트, RenderContext, SSR, 서버 사이드 렌더링, ESM, 리소스 관리"}]]},"version":""},{"id":190,"title":"Rspack","content":"#\n\nGez는 Rspack 빌드 시스템을 기반으로 구현되어 Rspack의 고성능 빌드 기능을 최대한 활용합니다. 이 문서에서는 Gez 프레임워크에서\nRspack의 역할과 핵심 기능에 대해 설명합니다.\n\n\n기능#\n\nRspack은 Gez 프레임워크의 핵심 빌드 시스템으로, 다음과 같은 주요 기능을 제공합니다:\n\n * 고성능 빌드: Rust로 구현된 빌드 엔진을 기반으로 빠른 컴파일 성능을 제공하여 대규모 프로젝트의 빌드 속도를 크게 향상시킵니다.\n * 개발 경험 최적화: 핫 리로드(HMR), 증분 컴파일 등 현대적인 개발 기능을 지원하여 원활한 개발 경험을 제공합니다.\n * 다중 환경 빌드: 클라이언트(client), 서버(server), Node.js(node) 환경을 지원하는 통합 빌드 설정을 제공하여 다중\n   플랫폼 개발 프로세스를 단순화합니다.\n * 리소스 최적화: 코드 분할, Tree Shaking, 리소스 압축 등 리소스 처리 및 최적화 기능을 내장하고 있습니다.\n\n\n애플리케이션 빌드#\n\nGez의 Rspack 빌드 시스템은 모듈식 설계를 채택하며, 다음과 같은 핵심 모듈로 구성됩니다:\n\n\n@gez/rspack#\n\n기본 빌드 모듈로, 다음과 같은 핵심 기능을 제공합니다:\n\n * 통합 빌드 설정: 표준화된 빌드 설정 관리를 제공하며, 다중 환경 설정을 지원합니다.\n * 리소스 처리: TypeScript, CSS, 이미지 등 다양한 리소스에 대한 처리 기능을 내장하고 있습니다.\n * 빌드 최적화: 코드 분할, Tree Shaking 등 성능 최적화 기능을 제공합니다.\n * 개발 서버: 고성능 개발 서버를 통합하여 HMR을 지원합니다.\n\n\n@gez/rspack-vue#\n\nVue 프레임워크 전용 빌드 모듈로, 다음과 같은 기능을 제공합니다:\n\n * Vue 컴포넌트 컴파일: Vue 2/3 컴포넌트의 효율적인 컴파일을 지원합니다.\n * SSR 최적화: 서버 사이드 렌더링(SSR) 시나리오에 특화된 최적화를 제공합니다.\n * 개발 기능 강화: Vue 개발 환경에 특화된 기능을 강화합니다.\n\n\n빌드 프로세스#\n\nGez의 빌드 프로세스는 주로 다음과 같은 단계로 구성됩니다:\n\n 1. 설정 초기화\n    \n    * 프로젝트 설정 로드\n    * 기본 설정과 사용자 설정 병합\n    * 환경 변수에 따라 설정 조정\n\n 2. 리소스 컴파일\n    \n    * 소스 코드 의존성 분석\n    * TypeScript, CSS 등 다양한 리소스 변환\n    * 모듈 임포트/익스포트 처리\n\n 3. 최적화 처리\n    \n    * 코드 분할 실행\n    * Tree Shaking 적용\n    * 코드 및 리소스 압축\n\n 4. 출력 생성\n    \n    * 대상 파일 생성\n    * 리소스 매핑 출력\n    * 빌드 리포트 생성\n\n\n모범 사례#\n\n\n개발 환경 최적화#\n\n * 증분 컴파일 설정: cache 옵션을 적절히 설정하여 캐시를 활용해 빌드 속도를 높입니다.\n * HMR 최적화: 핫 리로드 범위를 적절히 설정하여 불필요한 모듈 업데이트를 방지합니다.\n * 리소스 처리 최적화: 적절한 로더 설정을 사용하여 중복 처리를 방지합니다.\n\n\n프로덕션 환경 최적화#\n\n * 코드 분할 전략: splitChunks를 적절히 설정하여 리소스 로딩을 최적화합니다.\n * 리소스 압축: 적절한 압축 설정을 활성화하여 빌드 시간과 결과물 크기를 균형 있게 조정합니다.\n * 캐시 최적화: 콘텐츠 해시 및 장기 캐시 전략을 활용하여 로딩 성능을 향상시킵니다.\n\n\n설정 예제#\n\n\n\nTIP\n\n더 자세한 API 설명과 설정 옵션은 Rspack API 문서를 참조하세요.","routePath":"/ko/guide/essentials/rspack","lang":"ko","toc":[{"text":"기능","id":"기능","depth":2,"charIndex":113},{"text":"애플리케이션 빌드","id":"애플리케이션-빌드","depth":2,"charIndex":496},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":565},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":818},{"text":"빌드 프로세스","id":"빌드-프로세스","depth":2,"charIndex":1015},{"text":"모범 사례","id":"모범-사례","depth":2,"charIndex":1369},{"text":"개발 환경 최적화","id":"개발-환경-최적화","depth":3,"charIndex":1378},{"text":"프로덕션 환경 최적화","id":"프로덕션-환경-최적화","depth":3,"charIndex":1543},{"text":"설정 예제","id":"설정-예제","depth":2,"charIndex":1716}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 고성능 빌드 엔진","description":"Gez 프레임워크의 Rspack 빌드 시스템에 대해 심층적으로 분석합니다. 고성능 컴파일, 다중 환경 빌드, 리소스 최적화 등 핵심 기능을 포함하여 개발자가 효율적이고 신뢰할 수 있는 현대적인 웹 애플리케이션을 구축할 수 있도록 지원합니다.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, 빌드 시스템, 고성능 컴파일, 핫 리로드, 다중 환경 빌드, Tree Shaking, 코드 분할, SSR, 리소스 최적화, 개발 효율성, 빌드 도구"}]]},"version":""},{"id":191,"title":"표준 규범","content":"#\n\nGez는 현대적인 SSR 프레임워크로, 표준화된 프로젝트 구조와 경로 해석 메커니즘을 채택하여 개발 및 프로덕션 환경에서의 일관성과 유지보수성을\n보장합니다.\n\n\n프로젝트 구조 규범#\n\n\n표준 디렉토리 구조#\n\n\n\n확장 지식\n * gez.name은 package.json의 name 필드에서 유래\n * dist/package.json은 루트 디렉토리의 package.json에서 유래\n * packs.enable을 true로 설정할 경우에만 dist 디렉토리를 아카이브\n\n\n진입 파일 규범#\n\n\nentry.client.ts#\n\n클라이언트 진입 파일은 다음을 담당합니다:\n\n * 애플리케이션 초기화: 클라이언트 애플리케이션의 기본 설정 구성\n * 라우팅 관리: 클라이언트 라우팅 및 네비게이션 처리\n * 상태 관리: 클라이언트 상태 저장 및 업데이트 구현\n * 상호작용 처리: 사용자 이벤트 및 인터페이스 상호작용 관리\n\n\nentry.server.ts#\n\n서버 진입 파일은 다음을 담당합니다:\n\n * 서버 측 렌더링: SSR 렌더링 프로세스 실행\n * HTML 생성: 초기 페이지 구조 구축\n * 데이터 프리페치: 서버 측 데이터 가져오기 처리\n * 상태 주입: 서버 상태를 클라이언트에 전달\n * SEO 최적화: 페이지의 검색 엔진 최적화 보장\n\n\nentry.node.ts#\n\nNode.js 서버 진입 파일은 다음을 담당합니다:\n\n * 서버 설정: HTTP 서버 매개변수 설정\n * 라우팅 처리: 서버 측 라우팅 규칙 관리\n * 미들웨어 통합: 서버 미들웨어 설정\n * 환경 관리: 환경 변수 및 설정 처리\n * 요청 응답: HTTP 요청 및 응답 처리\n\n\n설정 파일 규범#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/ko/guide/essentials/std","lang":"ko","toc":[{"text":"프로젝트 구조 규범","id":"프로젝트-구조-규범","depth":2,"charIndex":92},{"text":"표준 디렉토리 구조","id":"표준-디렉토리-구조","depth":3,"charIndex":106},{"text":"진입 파일 규범","id":"진입-파일-규범","depth":2,"charIndex":266},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":278},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":461},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":644},{"text":"설정 파일 규범","id":"설정-파일-규범","depth":2,"charIndex":817},{"text":"package.json","id":"packagejson","depth":3,"charIndex":829},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":847}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 프로젝트 구조 및 규범 가이드","description":"Gez 프레임워크의 표준 프로젝트 구조, 진입 파일 규범 및 설정 파일 규범을 상세히 설명하여 개발자가 표준화되고 유지보수 가능한 SSR 애플리케이션을 구축할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, 프로젝트 구조, 진입 파일, 설정 규범, SSR 프레임워크, TypeScript, 프로젝트 규범, 개발 표준"}]]},"version":""},{"id":192,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ko/guide/frameworks/html","lang":"ko","toc":[{"text":"프로젝트 구조","id":"프로젝트-구조","depth":2,"charIndex":-1},{"text":"프로젝트 설정","id":"프로젝트-설정","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"소스 코드 구조","id":"소스-코드-구조","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"프로젝트 실행","id":"프로젝트-실행","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 HTML SSR 애플리케이션 예제","description":"Gez 기반의 HTML SSR 애플리케이션을 처음부터 구축하는 방법을 보여주는 예제입니다. 프로젝트 초기화, HTML 설정 및 진입 파일 설정을 포함한 프레임워크의 기본 사용법을 다룹니다.","head":[["meta",{"property":"keywords","content":"Gez, HTML, SSR 애플리케이션, TypeScript 설정, 프로젝트 초기화, 서버 사이드 렌더링, 클라이언트 상호작용"}]]},"version":""},{"id":193,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ko/guide/frameworks/preact-htm","lang":"ko","toc":[{"text":"프로젝트 구조","id":"프로젝트-구조","depth":2,"charIndex":-1},{"text":"프로젝트 설정","id":"프로젝트-설정","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"소스 코드 구조","id":"소스-코드-구조","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"프로젝트 실행","id":"프로젝트-실행","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 Preact+HTM SSR 애플리케이션 예제","description":"Gez를 기반으로 Preact+HTM SSR 애플리케이션을 처음부터 구축하는 방법을 보여주는 예제입니다. 프로젝트 초기화, Preact 설정 및 진입 파일 설정을 포함한 프레임워크의 기본 사용법을 다룹니다.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, SSR 애플리케이션, TypeScript 설정, 프로젝트 초기화, 서버 사이드 렌더링, 클라이언트 상호작용"}]]},"version":""},{"id":194,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ko/guide/frameworks/vue2","lang":"ko","toc":[{"text":"프로젝트 구조","id":"프로젝트-구조","depth":2,"charIndex":-1},{"text":"프로젝트 구성","id":"프로젝트-구성","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"소스 코드 구조","id":"소스-코드-구조","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"프로젝트 실행","id":"프로젝트-실행","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 Vue2 SSR 애플리케이션 예제","description":"Gez를 기반으로 Vue2 SSR 애플리케이션을 처음부터 구축하는 방법을 보여주는 예제입니다. 프로젝트 초기화, Vue2 구성 및 진입 파일 설정을 포함한 프레임워크의 기본 사용법을 다룹니다.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, SSR 애플리케이션, TypeScript 구성, 프로젝트 초기화, 서버 사이드 렌더링, 클라이언트 상호작용"}]]},"version":""},{"id":195,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ko/guide/frameworks/vue3","lang":"ko","toc":[{"text":"프로젝트 구조","id":"프로젝트-구조","depth":2,"charIndex":-1},{"text":"프로젝트 설정","id":"프로젝트-설정","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"소스 코드 구조","id":"소스-코드-구조","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"프로젝트 실행","id":"프로젝트-실행","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 Vue3 SSR 애플리케이션 예제","description":"Gez를 기반으로 Vue3 SSR 애플리케이션을 처음부터 구축하는 방법을 설명합니다. 프로젝트 초기화, Vue3 설정, 엔트리 파일 설정 등 프레임워크의 기본 사용법을 예제를 통해 보여줍니다.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, SSR 애플리케이션, TypeScript 설정, 프로젝트 초기화, 서버 사이드 렌더링, 클라이언트 상호작용, 컴포지션 API"}]]},"version":""},{"id":196,"title":"환경 요구사항","content":"#\n\n이 문서는 본 프레임워크를 사용하기 위한 환경 요구사항을 설명하며, Node.js 환경과 브라우저 호환성을 포함합니다.\n\n\nNode.js 환경#\n\n프레임워크는 Node.js 버전 >= 22.6을 요구하며, 주로 TypeScript 타입 임포트를 지원하기 위해 사용됩니다\n(--experimental-strip-types 플래그를 통해). 추가 컴파일 단계가 필요하지 않습니다.\n\n\n브라우저 호환성#\n\n프레임워크는 기본적으로 호환 모드로 빌드되어 더 넓은 범위의 브라우저를 지원합니다. 그러나 완전한 브라우저 호환성을 구현하려면\nes-module-shims 의존성을 수동으로 추가해야 합니다.\n\n\n호환 모드 (기본)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nCan I Use 통계에 따르면, 호환 모드에서의 브라우저 커버리지는 96.81%입니다.\n\n\n네이티브 지원 모드#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\n네이티브 지원 모드의 장점:\n\n * 런타임 오버헤드 없음, 추가 모듈 로더 불필요\n * 브라우저 네이티브 파싱, 더 빠른 실행 속도\n * 더 나은 코드 분할 및 필요시 로딩 기능\n\nCan I Use 통계에 따르면, 호환 모드에서의 브라우저 커버리지는 93.5%입니다.\n\n\n호환 지원 활성화#\n\n중요 사항\n\n프레임워크는 기본적으로 호환 모드로 빌드되지만, 구형 브라우저에 대한 완전한 지원을 위해서는 프로젝트에 es-module-shims 의존성을\n추가해야 합니다.\n\nHTML 파일에 다음 스크립트를 추가하세요:\n\n\n\n최적의 실천 방법\n 1. 프로덕션 환경 권장 사항:\n    * es-module-shims를 자체 서버에 배포\n    * 리소스 로딩의 안정성과 접근 속도 보장\n    * 잠재적인 보안 위험 방지\n 2. 성능 고려 사항:\n    * 호환 모드는 약간의 성능 오버헤드를 초래\n    * 대상 사용자 그룹의 브라우저 분포에 따라 활성화 여부 결정","routePath":"/ko/guide/start/environment","lang":"ko","toc":[{"text":"Node.js 환경","id":"nodejs-환경","depth":2,"charIndex":71},{"text":"브라우저 호환성","id":"브라우저-호환성","depth":2,"charIndex":215},{"text":"호환 모드 (기본)","id":"호환-모드-기본","depth":3,"charIndex":335},{"text":"네이티브 지원 모드","id":"네이티브-지원-모드","depth":3,"charIndex":480},{"text":"호환 지원 활성화","id":"호환-지원-활성화","depth":3,"charIndex":728}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 호환성 가이드","description":"Gez 프레임워크의 환경 요구사항을 상세히 설명하며, Node.js 버전 요구사항과 브라우저 호환성 정보를 포함하여 개발자가 개발 환경을 올바르게 구성할 수 있도록 돕습니다.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, 브라우저 호환성, TypeScript, es-module-shims, 환경 설정"}]]},"version":""},{"id":197,"title":"빠른 시작","content":"#\n\n\n프로젝트 초기화#\n\n새로운 Gez 프로젝트를 생성하고 초기화하려면 다음 단계를 따르세요:\n\n\n\n\n프레임워크 버전 선택#\n\nGez 프레임워크는 다양한 기술 스택 버전을 제공하며, 각 버전은 다른 애플리케이션 시나리오에 맞게 최적화되어 있습니다. 프로젝트 요구 사항에\n따라 적합한 버전을 선택하세요:\n\n\nHTML#\n\n극도로 간단한 아키텍처를 추구하는 프로젝트에 적합:\n\n * 외부 의존성 없이 바로 사용 가능\n * 순수 JavaScript 개발 경험\n * 정적 웹사이트 및 경량 애플리케이션 구축에 적합\n * 점진적 기능 확장 지원\n\nHTML 버전 상세 문서 보기\n\n\nVue2#\n\n기업급 애플리케이션 개발에 적합:\n\n * 완전한 TypeScript 지원\n * 풍부한 서드파티 컴포넌트 생태계\n * 성숙한 개발 도구 체인\n * 생산 환경에서 검증된 안정성\n\nVue2 버전 상세 문서 보기\n\n\nVue3#\n\n현대적인 웹 애플리케이션 개발에 적합:\n\n * Proxy 기반의 반응형 시스템\n * 컴포지션 API 지원\n * 더 나은 런타임 성능\n * 더 작은 번들 크기\n\nVue3 버전 상세 문서 보기\n\n\nPreact+HTM#\n\n경량 및 고성능을 추구하는 프로젝트에 적합:\n\n * 매우 작은 런타임 크기 (3KB)\n * 순수 JavaScript 템플릿 구문\n * React와 호환되는 API\n * 우수한 성능\n\nPreact+HTM 버전 상세 문서 보기\n\n\nAI 지원 개발#\n\nGez 프레임워크는 AI 지원 개발 기능을 제공하여 개발 효율성을 크게 향상시킬 수 있습니다:\n\n 1. 적합한 프레임워크 버전 문서 선택\n 2. 문서 내용을 AI 어시스턴트에 제공\n 3. AI가 자동으로 프로젝트 골격과 설정 파일 생성\n\n팁\n\nAI 지원 개발은 프로젝트 초기화 속도를 높일 뿐만 아니라, 프로젝트 구조가 최적의 관행을 따르도록 보장합니다.","routePath":"/ko/guide/start/getting-started","lang":"ko","toc":[{"text":"프로젝트 초기화","id":"프로젝트-초기화","depth":2,"charIndex":3},{"text":"프레임워크 버전 선택","id":"프레임워크-버전-선택","depth":2,"charIndex":57},{"text":"HTML","id":"html","depth":3,"charIndex":171},{"text":"Vue2","id":"vue2","depth":3,"charIndex":319},{"text":"Vue3","id":"vue3","depth":3,"charIndex":443},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":558},{"text":"AI 지원 개발","id":"ai-지원-개발","depth":2,"charIndex":698}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 빠른 시작 가이드","description":"Gez 프레임워크 빠른 시작 가이드로, 프로젝트 초기화, 프레임워크 버전 선택, AI 지원 개발 등을 포함하여 처음부터 프로젝트를 구축하는 방법을 안내합니다.","head":[["meta",{"name":"keywords","content":"Gez 프레임워크, 빠른 시작, 프로젝트 초기화, Vue 개발, HTML 개발, AI 지원"}]]},"version":""},{"id":198,"title":"소개","content":"#\n\n\n프로젝트 배경#\n\nGez는 ECMAScript Modules (ESM) 기반의 현대적인 마이크로 프론트엔드 프레임워크로, 고성능 및 확장 가능한 서버 사이드\n렌더링(SSR) 애플리케이션 구축에 중점을 둡니다. Genesis 프로젝트의 3세대 제품인 Gez는 기술 진화 과정에서 지속적으로 혁신을 이루어\n왔습니다:\n\n * v1.0: HTTP 요청 기반의 원격 컴포넌트 온디맨드 로딩 구현\n * v2.0: Webpack Module Federation 기반의 애플리케이션 통합 구현\n * v3.0: 브라우저 네이티브 ESM 기반으로 모듈 링크 시스템 재설계\n\n\n기술 배경#\n\n마이크로 프론트엔드 아키텍처 발전 과정에서 기존 솔루션은 주로 다음과 같은 한계를 가지고 있었습니다:\n\n\n기존 솔루션의 과제#\n\n * 성능 병목: 런타임 의존성 주입 및 JavaScript 샌드박스 프록시로 인한 상당한 성능 오버헤드\n * 격리 메커니즘: 자체 개발한 샌드박스 환경은 브라우저 네이티브 모듈 격리 능력에 미치지 못함\n * 빌드 복잡성: 의존성 공유를 위한 빌드 도구 개조로 인한 프로젝트 유지보수 비용 증가\n * 표준 이탈: 특수한 배포 전략 및 런타임 처리 메커니즘으로 인한 현대 웹 개발 표준과의 괴리\n * 생태계 제한: 프레임워크 결합 및 맞춤형 API로 인한 기술 스택 선택의 제한\n\n\n기술 혁신#\n\nGez는 현대 웹 표준을 기반으로 새로운 솔루션을 제공합니다:\n\n * 네이티브 모듈 시스템: 브라우저 네이티브 ESM 및 Import Maps를 활용한 의존성 관리로 더 빠른 파싱 및 실행 속도 제공\n * 표준 격리 메커니즘: ECMAScript 모듈 스코프 기반의 신뢰할 수 있는 애플리케이션 격리\n * 개방형 기술 스택: 모든 현대 프론트엔드 프레임워크의 원활한 통합 지원\n * 개발자 경험 최적화: 직관적인 개발 모드 및 완전한 디버깅 기능 제공\n * 극致的 성능 최적화: 네이티브 기능을 활용한 제로 런타임 오버헤드 및 스마트 캐싱 전략\n\nTIP\n\nGez는 고성능 및 확장 가능한 마이크로 프론트엔드 인프라 구축에 중점을 두며, 특히 대규모 서버 사이드 렌더링 애플리케이션 시나리오에\n적합합니다.\n\n\n기술 사양#\n\n\n환경 의존성#\n\n자세한 브라우저 및 Node.js 환경 요구 사항은 환경 요구 사항 문서를 참조하십시오.\n\n\n핵심 기술 스택#\n\n * 의존성 관리: Import Maps를 사용한 모듈 매핑 및 es-module-shims를 통한 호환성 지원\n * 빌드 시스템: Rspack 기반의 module-import를 사용한 외부 의존성 처리\n * 개발 도구 체인: ESM 핫 리로드 및 TypeScript 네이티브 실행 지원\n\n\n프레임워크 포지셔닝#\n\nGez는 Next.js 또는 Nuxt.js와 달리 마이크로 프론트엔드 인프라 제공에 중점을 둡니다:\n\n * 모듈 링크 시스템: 효율적이고 신뢰할 수 있는 모듈 임포트 및 익스포트 구현\n * 서버 사이드 렌더링: 유연한 SSR 구현 메커니즘 제공\n * 타입 시스템 지원: 완전한 TypeScript 타입 정의 통합\n * 프레임워크 중립성: 주요 프론트엔드 프레임워크 통합 지원\n\n\n아키텍처 설계#\n\n\n중앙 집중식 의존성 관리#\n\n * 통합 의존성 소스: 중앙 집중화된 서드파티 의존성 관리\n * 자동화된 배포: 의존성 업데이트의 전역 자동 동기화\n * 버전 일관성: 정확한 의존성 버전 제어\n\n\n모듈화 설계#\n\n * 책임 분리: 비즈니스 로직과 인프라의 분리\n * 플러그인 메커니즘: 모듈의 유연한 조합 및 교체 지원\n * 표준 인터페이스: 표준화된 모듈 간 통신 프로토콜\n\n\n성능 최적화#\n\n * 제로 오버헤드 원칙: 브라우저 네이티브 기능의 최대 활용\n * 스마트 캐싱: 콘텐츠 해시 기반의 정확한 캐싱 전략\n * 온디맨드 로딩: 세분화된 코드 분할 및 의존성 관리\n\n\n프로젝트 성숙도#\n\nGez는 약 5년간의 반복적 진화(v1.0 ~ v3.0)를 통해 기업 환경에서 포괄적으로 검증되었습니다. 현재 수십 개의 비즈니스 프로젝트를\n안정적으로 지원하며, 기술 스택의 현대화 업그레이드를 지속적으로 추진하고 있습니다. 프레임워크의 안정성, 신뢰성 및 성능 이점은 실무에서 충분히\n검증되었으며, 대규모 애플리케이션 개발을 위한 신뢰할 수 있는 기술 기반을 제공합니다.","routePath":"/ko/guide/start/introduction","lang":"ko","toc":[{"text":"프로젝트 배경","id":"프로젝트-배경","depth":2,"charIndex":3},{"text":"기술 배경","id":"기술-배경","depth":2,"charIndex":315},{"text":"기존 솔루션의 과제","id":"기존-솔루션의-과제","depth":3,"charIndex":382},{"text":"기술 혁신","id":"기술-혁신","depth":3,"charIndex":664},{"text":"기술 사양","id":"기술-사양","depth":2,"charIndex":1068},{"text":"환경 의존성","id":"환경-의존성","depth":3,"charIndex":1077},{"text":"핵심 기술 스택","id":"핵심-기술-스택","depth":3,"charIndex":1138},{"text":"프레임워크 포지셔닝","id":"프레임워크-포지셔닝","depth":2,"charIndex":1312},{"text":"아키텍처 설계","id":"아키텍처-설계","depth":2,"charIndex":1537},{"text":"중앙 집중식 의존성 관리","id":"중앙-집중식-의존성-관리","depth":3,"charIndex":1548},{"text":"모듈화 설계","id":"모듈화-설계","depth":3,"charIndex":1657},{"text":"성능 최적화","id":"성능-최적화","depth":3,"charIndex":1759},{"text":"프로젝트 성숙도","id":"프로젝트-성숙도","depth":2,"charIndex":1869}],"domain":"","frontmatter":{"titleSuffix":"Gez 프레임워크 개요 및 기술 혁신","description":"Gez 마이크로 프론트엔드 프레임워크의 프로젝트 배경, 기술 진화 및 핵심 장점을 심층적으로 이해하고, ESM 기반의 현대적인 서버 사이드 렌더링(SSR) 솔루션을 탐구합니다.","head":[["meta",{"property":"keywords","content":"Gez, 마이크로 프론트엔드, ESM, 서버 사이드 렌더링, SSR, 기술 혁신, 모듈 연합"}]]},"version":""}]