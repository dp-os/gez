[{"id":25,"title":"@gez/rspack-vue","content":"#\n\nThe Rspack Vue package provides a set of APIs for creating and configuring\nRspack applications based on the Vue framework, supporting Vue component\ndevelopment, building, and server-side rendering.\n\n\nInstallation#\n\nInstall @gez/rspack-vue as a development dependency using your package manager:\n\n\nType Exports#\n\n\nBuildTarget#\n\n\n\nThe build target environment type defines the target environment for the\napplication build, used to configure specific optimizations and features during\nthe build process:\n\n * node: Build code to run in a Node.js environment\n * client: Build code to run in a browser environment\n * server: Build code to run in a server environment\n\n\nRspackAppConfigContext#\n\n\n\nThe Rspack application configuration context interface provides context\ninformation accessible within configuration hook functions:\n\n * gez: Gez framework instance\n * buildTarget: Current build target (client/server/node)\n * config: Rspack configuration object\n * options: Application configuration options\n\n\nRspackAppOptions#\n\n\n\nRspack application configuration options interface:\n\n * css: CSS output method, either 'css' (separate file) or 'style' (inline\n   styles)\n * loaders: Custom loader configuration\n * styleLoader: style-loader configuration options\n * cssLoader: css-loader configuration options\n * target: Build target compatibility configuration\n * definePlugin: Global constant definitions\n * config: Configuration hook function\n\n\nRspackHtmlAppOptions#\n\nExtends RspackAppOptions, used to configure specific options for HTML\napplications.\n\n\nFunction Exports#\n\n\ncreateRspackApp#\n\n\n\nCreates a standard Rspack application instance.\n\nParameters:\n\n * gez: Gez framework instance\n * options: Rspack application configuration options\n\nReturns:\n\n * A Promise that resolves to the created application instance\n\n\ncreateRspackHtmlApp#\n\n\n\nCreates an HTML-type Rspack application instance.\n\nParameters:\n\n * gez: Gez framework instance\n * options: HTML application configuration options\n\nReturns:\n\n * A Promise that resolves to the created HTML application instance\n\n\nConstant Exports#\n\n\nRSPACK_LOADER#\n\n\n\nA mapping object of Rspack's built-in loader identifiers, providing commonly\nused loader name constants:\n\n * builtinSwcLoader: Rspack's built-in SWC loader for processing\n   TypeScript/JavaScript files\n * lightningcssLoader: Rspack's built-in lightningcss loader for\n   high-performance CSS file compilation\n * styleLoader: Loader for injecting CSS into the DOM\n * cssLoader: Loader for parsing CSS files and handling CSS modularization\n * lessLoader: Loader for compiling Less files into CSS\n * styleResourcesLoader: Loader for automatically importing global style\n   resources (e.g., variables, mixins)\n * workerRspackLoader: Loader for processing Web Worker files\n\nUsing these constants allows referencing built-in loaders in configurations,\navoiding manual string input:\n\n\n\nNotes:\n\n * These loaders are built into Rspack and do not require additional\n   installation\n * When customizing loader configurations, these constants can be used to\n   replace default loader implementations\n * Some loaders (e.g., builtinSwcLoader) have specific configuration options;\n   refer to the respective documentation\n\n\nModule Exports#\n\n\nrspack#\n\nRe-exports all contents of the @rspack/core package, providing full Rspack core\nfunctionality.","routePath":"/en/api/app/rspack-vue","lang":"en","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":202},{"text":"Type Exports","id":"type-exports","depth":2,"charIndex":299},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":315},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":665},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1001},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1437},{"text":"Function Exports","id":"function-exports","depth":2,"charIndex":1546},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1566},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1808},{"text":"Constant Exports","id":"constant-exports","depth":2,"charIndex":2059},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2079},{"text":"Module Exports","id":"module-exports","depth":2,"charIndex":3205},{"text":"rspack","id":"rspack","depth":3,"charIndex":3223}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Vue Build Tool","description":"The Vue-specific build tool for the Gez framework, providing comprehensive support for Vue 2/3 application builds, including component development, SSR rendering, and performance optimization.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, Build Tool, Component Development, Server-Side Rendering, Performance Optimization"}]]},"version":""},{"id":26,"title":"@gez/rspack","content":"#\n\nThe Rspack package provides a set of APIs for creating and configuring Rspack\napplications, supporting the building and development of standard applications\nand HTML applications.\n\n\nInstallation#\n\nInstall @gez/rspack as a development dependency using a package manager:\n\n\nType Exports#\n\n\nBuildTarget#\n\n\n\nThe build target environment type defines the target environment for application\nbuilding, used to configure specific optimizations and features during the build\nprocess:\n\n * node: Build code to run in a Node.js environment\n * client: Build code to run in a browser environment\n * server: Build code to run in a server environment\n\n\nRspackAppConfigContext#\n\n\n\nThe Rspack application configuration context interface provides context\ninformation accessible within configuration hook functions:\n\n * gez: Gez framework instance\n * buildTarget: Current build target (client/server/node)\n * config: Rspack configuration object\n * options: Application configuration options\n\n\nRspackAppOptions#\n\n\n\nRspack application configuration options interface:\n\n * css: CSS output method, either 'css' (standalone file) or 'style' (inline\n   styles)\n * loaders: Custom loader configurations\n * styleLoader: style-loader configuration options\n * cssLoader: css-loader configuration options\n * target: Build target compatibility configurations\n * definePlugin: Global constant definitions\n * config: Configuration hook function\n\n\nRspackHtmlAppOptions#\n\nInherits from RspackAppOptions, used to configure specific options for HTML\napplications.\n\n\nFunction Exports#\n\n\ncreateRspackApp#\n\n\n\nCreates a standard Rspack application instance.\n\nParameters:\n\n * gez: Gez framework instance\n * options: Rspack application configuration options\n\nReturns:\n\n * A Promise that resolves to the created application instance\n\n\ncreateRspackHtmlApp#\n\n\n\nCreates an HTML-type Rspack application instance.\n\nParameters:\n\n * gez: Gez framework instance\n * options: HTML application configuration options\n\nReturns:\n\n * A Promise that resolves to the created HTML application instance\n\n\nConstant Exports#\n\n\nRSPACK_LOADER#\n\n\n\nA mapping object of Rspack's built-in loader identifiers, providing commonly\nused loader name constants:\n\n * builtinSwcLoader: Rspack's built-in SWC loader for processing\n   TypeScript/JavaScript files\n * lightningcssLoader: Rspack's built-in lightningcss loader for\n   high-performance CSS file compilation\n * styleLoader: Loader for injecting CSS into the DOM\n * cssLoader: Loader for parsing CSS files and handling CSS modularization\n * lessLoader: Loader for compiling Less files into CSS\n * styleResourcesLoader: Loader for automatically importing global style\n   resources (e.g., variables, mixins)\n * workerRspackLoader: Loader for processing Web Worker files\n\nUsing these constants allows referencing built-in loaders in configurations,\navoiding manual string input:\n\n\n\nNotes:\n\n * These loaders are built into Rspack and do not require additional\n   installation\n * When customizing loader configurations, these constants can be used to\n   replace default loader implementations\n * Some loaders (e.g., builtinSwcLoader) have specific configuration options;\n   refer to the respective documentation\n\n\nModule Exports#\n\n\nrspack#\n\nRe-exports all contents of the @rspack/core package, providing full Rspack core\nfunctionality.","routePath":"/en/api/app/rspack","lang":"en","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":184},{"text":"Type Exports","id":"type-exports","depth":2,"charIndex":274},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":290},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":639},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":975},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1415},{"text":"Function Exports","id":"function-exports","depth":2,"charIndex":1530},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1550},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1792},{"text":"Constant Exports","id":"constant-exports","depth":2,"charIndex":2043},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2063},{"text":"Module Exports","id":"module-exports","depth":2,"charIndex":3189},{"text":"rspack","id":"rspack","depth":3,"charIndex":3207}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rspack Build Tool","description":"The Rspack build tool for the Gez framework provides high-performance application building capabilities, supporting the development and building of standard applications and HTML applications, with built-in multiple resource processors and optimization configurations.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Build Tool, Application Building, HTML Application, TypeScript, CSS, Resource Processing, Performance Optimization"}]]},"version":""},{"id":27,"title":"App","content":"#\n\nApp is the application abstraction in the Gez framework, providing a unified\ninterface to manage the application lifecycle, static resources, and server-side\nrendering.\n\n\n\n\nType Definitions#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Type: Middleware\n\nStatic resource handling middleware.\n\nDevelopment environment:\n\n * Handles static resource requests for source code\n * Supports real-time compilation and hot updates\n * Uses no-cache policy\n\nProduction environment:\n\n * Handles built static resources\n * Supports long-term caching for immutable files (.final.xxx)\n * Optimized resource loading strategy\n\n\n\nrender#\n\n * Type: (options?: RenderContextOptions) => Promise\n\nServer-side rendering function. Provides different implementations based on the\nenvironment:\n\n * Production environment (start): Loads and executes the built server entry\n   file (entry.server) for rendering\n * Development environment (dev): Loads and executes the server entry file from\n   the source code for rendering\n\n\n\nbuild#\n\n * Type: () => Promise\n\nProduction environment build function. Used for resource bundling and\noptimization. Returns true on successful build, false on failure.\n\ndestroy#\n\n * Type: () => Promise\n\nResource cleanup function. Used for shutting down servers, disconnecting\nconnections, etc. Returns true on successful cleanup, false on failure.","routePath":"/en/api/core/app","lang":"en","toc":[{"text":"Type Definitions","id":"type-definitions","depth":2,"charIndex":175},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":203},{"text":"render","id":"render","depth":4,"charIndex":592},{"text":"build","id":"build","depth":4,"charIndex":979},{"text":"destroy","id":"destroy","depth":4,"charIndex":1148}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Application Abstraction Interface","description":"Detailed introduction to the App interface of the Gez framework, including application lifecycle management, static resource handling, and server-side rendering functionality, helping developers understand and use core application features.","head":[["meta",{"property":"keywords","content":"Gez, App, Application Abstraction, Lifecycle, Static Resources, Server-Side Rendering, API"}]]},"version":""},{"id":28,"title":"Gez","content":"","routePath":"/en/api/core/gez","lang":"en","toc":[{"text":"Introduction","id":"introduction","depth":2,"charIndex":-1},{"text":"Type Definitions","id":"type-definitions","depth":2,"charIndex":-1},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":-1},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":-1},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":-1},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":-1},{"text":"COMMAND","id":"command","depth":3,"charIndex":-1},{"text":"Instance Options","id":"instance-options","depth":2,"charIndex":-1},{"text":"root","id":"root","depth":4,"charIndex":-1},{"text":"isProd","id":"isprod","depth":4,"charIndex":-1},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":-1},{"text":"modules","id":"modules","depth":4,"charIndex":-1},{"text":"packs","id":"packs","depth":4,"charIndex":-1},{"text":"devApp","id":"devapp","depth":4,"charIndex":-1},{"text":"server","id":"server","depth":4,"charIndex":-1},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":-1},{"text":"Instance Properties","id":"instance-properties","depth":2,"charIndex":-1},{"text":"name","id":"name","depth":3,"charIndex":-1},{"text":"varName","id":"varname","depth":3,"charIndex":-1},{"text":"root","id":"root-1","depth":3,"charIndex":-1},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":-1},{"text":"basePath","id":"basepath","depth":3,"charIndex":-1},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":3,"charIndex":-1},{"text":"render","id":"render","depth":3,"charIndex":-1},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":-1},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":-1},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":-1},{"text":"Instance Methods","id":"instance-methods","depth":2,"charIndex":-1},{"text":"constructor()","id":"constructor","depth":3,"charIndex":-1},{"text":"init()","id":"init","depth":3,"charIndex":-1},{"text":"destroy()","id":"destroy","depth":3,"charIndex":-1},{"text":"build()","id":"build","depth":3,"charIndex":-1},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":-1},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":-1},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":-1},{"text":"readJson()","id":"readjson","depth":3,"charIndex":-1},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":-1},{"text":"getImportMap()","id":"getimportmap","depth":3,"charIndex":-1},{"text":"getImportMapClientInfo()","id":"getimportmapclientinfo","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Framework Core Class API Reference","description":"Detailed documentation of the Gez framework's core class API, including application lifecycle management, static asset handling, and server-side rendering capabilities, helping developers gain a deep understanding of the framework's core functionalities.","head":[["meta",{"property":"keywords","content":"Gez, API, Lifecycle Management, Static Assets, Server-Side Rendering, Rspack, Web Application Framework"}]]},"version":""},{"id":29,"title":"ManifestJson","content":"#\n\nmanifest.json is a manifest file generated by the Gez framework during the build\nprocess, used to record the artifact information of the service build. It\nprovides a unified interface for managing build artifacts, export files, and\nresource size statistics.\n\n\n\n\nType Definitions#\n\n\nManifestJson#\n\n\n\nname#\n\n * Type: string\n\nThe service name, derived from the GezOptions.name configuration.\n\nexports#\n\n * Type: Record\n\nThe mapping of exported files, where the key is the source file path and the\nvalue is the built file path.\n\nbuildFiles#\n\n * Type: string[]\n\nThe complete list of build artifacts, including all generated file paths.\n\nchunks#\n\n * Type: Record\n\nThe correspondence between source files and compiled artifacts, where the key is\nthe source file path and the value is the compilation information.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Type: string\n\nThe path to the compiled JS file for the current source file.\n\ncss#\n\n * Type: string[]\n\nThe list of CSS file paths associated with the current source file.\n\nresources#\n\n * Type: string[]\n\nThe list of other resource file paths associated with the current source file.\n\nsizes#\n\n * Type: ManifestJsonChunkSizes\n\nThe size statistics of the build artifacts.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Type: number\n\nThe size of the JS file in bytes.\n\ncss#\n\n * Type: number\n\nThe size of the CSS file in bytes.\n\nresource#\n\n * Type: number\n\nThe size of the resource file in bytes.","routePath":"/en/api/core/manifest-json","lang":"en","toc":[{"text":"Type Definitions","id":"type-definitions","depth":2,"charIndex":264},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":301},{"text":"exports","id":"exports","depth":4,"charIndex":392},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":527},{"text":"chunks","id":"chunks","depth":4,"charIndex":634},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":810},{"text":"js","id":"js","depth":4,"charIndex":833},{"text":"css","id":"css","depth":4,"charIndex":918},{"text":"resources","id":"resources","depth":4,"charIndex":1012},{"text":"sizes","id":"sizes","depth":4,"charIndex":1123},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1210},{"text":"js","id":"js-1","depth":4,"charIndex":1237},{"text":"css","id":"css-1","depth":4,"charIndex":1294},{"text":"resource","id":"resource","depth":4,"charIndex":1353}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Build Manifest File Reference","description":"Detailed explanation of the structure of the Gez framework's build manifest file (manifest.json), including build artifact management, export file mapping, and resource statistics, helping developers understand and utilize the build system.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, Build Manifest, Resource Management, Build Artifacts, File Mapping, API"}]]},"version":""},{"id":30,"title":"ModuleConfig","content":"#\n\nModuleConfig provides module configuration capabilities for the Gez framework,\nused to define module import/export rules, alias configuration, and external\ndependencies.\n\n\nType Definitions#\n\n\nPathType#\n\n * Type Definition:\n\n\n\nModule path type enumeration:\n\n * npm: Represents dependencies in node_modules\n * root: Represents files in the project root directory\n\n\nModuleConfig#\n\n * Type Definition:\n\n\n\nModule configuration interface, used to define service exports, imports, and\nexternal dependency configurations.\n\nexports#\n\nExport configuration list, exposing specific code units (such as components,\nutility functions, etc.) from the service in ESM format.\n\nSupports two types:\n\n * root:*: Exports source code files, e.g., 'root:src/components/button.vue'\n * npm:*: Exports third-party dependencies, e.g., 'npm:vue'\n\nimports#\n\nImport configuration mapping, configuring remote modules to be imported and\ntheir local paths.\n\nConfiguration varies based on installation method:\n\n * Source installation (Workspace, Git): Needs to point to the dist directory\n * Package installation (Link, static server, private registry, File): Directly\n   points to the package directory\n\nexternals#\n\nExternal dependency mapping, configuring external dependencies to be used,\ntypically dependencies from remote modules.\n\nExample:\n\n\n\n\nParsedModuleConfig#\n\n * Type Definition:\n\n\n\nParsed module configuration, converting the original module configuration into a\nstandardized internal format:\n\nname#\n\nCurrent service name\n\n * Used to identify the module and generate import paths\n\nroot#\n\nCurrent service root directory path\n\n * Used to resolve relative paths and store build artifacts\n\nexports#\n\nExport configuration list\n\n * name: Original export path, e.g., 'npm:vue' or 'root:src/components'\n * type: Path type (npm or root)\n * importName: Import name, format: '${serviceName}/${type}/${path}'\n * exportName: Export path, relative to the service root directory\n * exportPath: Actual file path\n * externalName: External dependency name, used as an identifier when other\n   services import this module\n\nimports#\n\nImport configuration list\n\n * name: External service name\n * localPath: Local storage path, used to store build artifacts of external\n   modules\n\nexternals#\n\nExternal dependency mapping\n\n * Maps module import paths to actual module locations\n * match: Regular expression used to match import statements\n * import: Actual module path\n\n","routePath":"/en/api/core/module-config","lang":"en","toc":[{"text":"Type Definitions","id":"type-definitions","depth":2,"charIndex":174},{"text":"PathType","id":"pathtype","depth":3,"charIndex":194},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":517},{"text":"imports","id":"imports","depth":4,"charIndex":821},{"text":"externals","id":"externals","depth":4,"charIndex":1173},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1318},{"text":"name","id":"name","depth":4,"charIndex":1474},{"text":"root","id":"root","depth":4,"charIndex":1561},{"text":"exports","id":"exports-1","depth":4,"charIndex":1666},{"text":"imports","id":"imports-1","depth":4,"charIndex":2084},{"text":"externals","id":"externals-1","depth":4,"charIndex":2240}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Module Configuration API Reference","description":"Detailed documentation on the ModuleConfig interface in the Gez framework, including module import/export rules, alias configuration, and external dependency management, helping developers gain a deeper understanding of the framework's modular system.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, Module Configuration, Module Import/Export, External Dependencies, Alias Configuration, Dependency Management, Web Application Framework"}]]},"version":""},{"id":31,"title":"PackConfig","content":"#\n\nPackConfig is the package bundling configuration interface used to bundle the\nbuild artifacts of a service into a standard npm .tgz format package.\n\n * Standardization: Uses the npm standard .tgz bundling format\n * Completeness: Includes all necessary files such as module source code, type\n   declarations, and configuration files\n * Compatibility: Fully compatible with the npm ecosystem, supporting standard\n   package management workflows\n\n\nType Definition#\n\n\n\n\nPackConfig#\n\nenable#\n\nWhether to enable the bundling feature. When enabled, the build artifacts will\nbe bundled into a standard npm .tgz format package.\n\n * Type: boolean\n * Default: false\n\noutputs#\n\nSpecifies the output package file path. Supports the following configuration\nmethods:\n\n * string: A single output path, e.g., 'dist/versions/my-app.tgz'\n * string[]: Multiple output paths for generating multiple versions\n   simultaneously\n * boolean: When true, uses the default path 'dist/client/versions/latest.tgz'\n\npackageJson#\n\nA callback function to customize the package.json content. Called before\nbundling to customize the package.json content.\n\n * Parameters:\n   * gez: Gez - Gez instance\n   * pkg: any - Original package.json content\n * Return Value: Promise - Modified package.json content\n\nCommon Use Cases:\n\n * Modify package name and version\n * Add or update dependencies\n * Add custom fields\n * Configure publishing information\n\nExample:\n\n\n\nonBefore#\n\nA callback function for pre-bundling preparations.\n\n * Parameters:\n   * gez: Gez - Gez instance\n   * pkg: Record - package.json content\n * Return Value: Promise\n\nCommon Use Cases:\n\n * Add additional files (README, LICENSE, etc.)\n * Execute tests or build validations\n * Generate documentation or metadata\n * Clean up temporary files\n\nExample:\n\n\n\nonAfter#\n\nA callback function for post-bundling processing. Called after the .tgz file is\ngenerated to handle the bundled artifacts.\n\n * Parameters:\n   * gez: Gez - Gez instance\n   * pkg: Record - package.json content\n   * file: Buffer - Bundled file content\n * Return Value: Promise\n\nCommon Use Cases:\n\n * Publish to npm registry (public or private)\n * Upload to static resource server\n * Perform version management\n * Trigger CI/CD workflows\n\nExample:\n\n\n\n\nUsage Example#\n\n","routePath":"/en/api/core/pack-config","lang":"en","toc":[{"text":"Type Definition","id":"type-definition","depth":2,"charIndex":447},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":481},{"text":"outputs","id":"outputs","depth":4,"charIndex":658},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":987},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1425},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1782},{"text":"Usage Example","id":"usage-example","depth":2,"charIndex":2240}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Pack Configuration API Reference","description":"Detailed documentation on the PackConfig configuration interface of the Gez framework, including package bundling rules, output configurations, and lifecycle hooks, helping developers implement standardized build processes.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, Package Bundling, Build Configuration, Lifecycle Hooks, Bundling Configuration, Web Application Framework"}]]},"version":""},{"id":32,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${html} ${rc.importmap()}\n${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/en/api/core/render-context","lang":"en","toc":[{"text":"Type Definitions","id":"type-definitions","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Instance Options","id":"instance-options","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Instance Properties","id":"instance-properties","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Instance Methods","id":"instance-methods","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1},{"text":"importmap()","id":"importmap","depth":3,"charIndex":-1},{"text":"moduleEntry()","id":"moduleentry","depth":3,"charIndex":-1},{"text":"modulePreload()","id":"modulepreload","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rendering Context API Reference","description":"Detailed documentation of the RenderContext core class in the Gez framework, including rendering control, resource management, state synchronization, and routing control, helping developers achieve efficient server-side rendering.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, Server-Side Rendering, Rendering Context, State Synchronization, Resource Management, Web Application Framework"}]]},"version":""},{"id":33,"title":"From Component Sharing to Native Modularity: The Evolution of the Gez Micro-Frontend Framework","content":"From Component Sharing to Native Modularity: The Evolution of the Gez\nMicro-Frontend Framework#\n\n\nProject Background#\n\nOver the past few years, micro-frontend architecture has been searching for the\nright path. However, what we have seen are various complex technical solutions\nthat simulate an ideal micro-frontend world with layers of packaging and\nartificial isolation. These solutions bring heavy performance burdens,\ncomplicate simple development, and obscure standard processes.\n\n\nLimitations of Traditional Solutions#\n\nIn practicing micro-frontend architecture, we have deeply experienced the many\nlimitations of traditional solutions:\n\n * Performance Overhead: Runtime dependency injection, JS sandbox proxies—every\n   operation consumes valuable performance.\n * Fragile Isolation: Artificially created sandbox environments can never match\n   the native isolation capabilities of browsers.\n * Build Complexity: To handle dependency relationships, build tools must be\n   heavily modified, making simple projects difficult to maintain.\n * Custom Rules: Special deployment strategies and runtime processing deviate\n   from standard modern development processes.\n * Ecosystem Constraints: Framework coupling and custom APIs force technology\n   choices to be tied to specific ecosystems.\n\nThese issues were particularly evident in a large enterprise project we worked\non in 2019. At that time, a large product was divided into more than ten\nindependent business subsystems, which needed to share a set of basic and\nbusiness components. The initial npm-based component sharing solution exposed\nserious maintenance efficiency problems: when shared components were updated,\nall subsystems dependent on those components had to go through a complete build\nand deployment process.\n\n\nTechnical Evolution#\n\n\nv1.0: Exploring Remote Components#\n\nTo address the efficiency issues of component sharing, Gez v1.0 introduced the\nRemoteView component mechanism based on the HTTP protocol. This solution\nachieved on-demand code assembly between services through runtime dynamic\nrequests, successfully solving the problem of long build dependency chains.\nHowever, due to the lack of a standardized runtime communication mechanism,\nstate synchronization and event passing between services still had efficiency\nbottlenecks.\n\n\nv2.0: Module Federation Experiment#\n\nIn version v2.0, we adopted Webpack 5.0's Module Federation technology. This\ntechnology significantly improved the collaboration efficiency between services\nthrough a unified module loading mechanism and runtime containers. However, in\nlarge-scale practice, the closed implementation mechanism of Module Federation\nbrought new challenges: it was difficult to achieve precise dependency version\nmanagement, especially when unifying shared dependencies across multiple\nservices, often leading to version conflicts and runtime exceptions.\n\n\nEmbracing the ESM Era#\n\nWhen planning version v3.0, we closely observed the development trends of the\nfront-end ecosystem and found that advancements in native browser capabilities\nbrought new possibilities for micro-frontend architecture:\n\n\nStandardized Module System#\n\nWith mainstream browsers fully supporting ES Modules and the maturity of the\nImport Maps specification, front-end development has entered a true modular era.\nAccording to Can I Use statistics, the native support rate for ESM in mainstream\nbrowsers (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) has reached\n93.5%, providing us with the following advantages:\n\n * Standardized Dependency Management: Import Maps provide the ability to\n   resolve module dependencies at the browser level, eliminating the need for\n   complex runtime injection.\n * Resource Loading Optimization: The browser's native module caching mechanism\n   significantly improves resource loading efficiency.\n * Simplified Build Process: The ESM-based development model makes the build\n   process more consistent between development and production environments.\n\nAt the same time, with compatibility mode support (Chrome >= 87, Edge >= 88,\nFirefox >= 78, Safari >= 14), we can further increase browser coverage to\n96.81%, allowing us to maintain high performance without sacrificing support for\nolder browsers.\n\n\nBreakthroughs in Performance and Isolation#\n\nThe native module system brings not only standardization but also qualitative\nimprovements in performance and isolation:\n\n * Zero Runtime Overhead: Eliminates the need for JavaScript sandbox proxies and\n   runtime injection in traditional micro-frontend solutions.\n * Reliable Isolation Mechanism: The strict module scope of ESM naturally\n   provides the most reliable isolation capabilities.\n * Precise Dependency Management: Static import analysis makes dependency\n   relationships clearer and version control more precise.\n\n\nBuild Tool Selection#\n\nIn the implementation of the technical solution, the choice of build tools was a\ncritical decision point. After nearly a year of technical research and practice,\nour selection evolved as follows:\n\n 1. Vite Exploration\n    \n    * Advantages: ESM-based development server, providing an excellent\n      development experience.\n    * Challenges: Differences between development and production builds\n      introduced some uncertainty.\n\n 2. Rspack Adoption\n    \n    * Performance Advantage: High-performance compilation based on Rust,\n      significantly improving build speed.\n    * Ecosystem Support: High compatibility with the Webpack ecosystem, reducing\n      migration costs.\n    * ESM Support: Verified reliability in ESM builds through the Rslib project.\n\nThis decision allowed us to maintain a good development experience while gaining\nmore stable production environment support. Based on the combination of ESM and\nRspack, we ultimately built a high-performance, low-intrusive micro-frontend\nsolution.\n\n\nFuture Outlook#\n\nIn future development plans, the Gez framework will focus on the following three\ndirections:\n\n\nDeep Optimization of Import Maps#\n\n * Dynamic Dependency Management: Implement intelligent runtime dependency\n   version scheduling to resolve dependency conflicts between multiple\n   applications.\n * Preloading Strategy: Intelligent preloading based on route analysis to\n   improve resource loading efficiency.\n * Build Optimization: Automatically generate optimal Import Maps\n   configurations, reducing manual configuration costs for developers.\n\n\nFramework-Agnostic Routing Solution#\n\n * Unified Routing Abstraction: Design a framework-agnostic routing interface to\n   support mainstream frameworks like Vue and React.\n * Micro-Application Routing: Implement routing linkage between applications to\n   maintain URL and application state consistency.\n * Routing Middleware: Provide an extensible middleware mechanism to support\n   features like permission control and page transitions.\n\n\nBest Practices for Cross-Framework Communication#\n\n * Example Applications: Provide complete cross-framework communication\n   examples, covering mainstream frameworks like Vue, React, and Preact.\n * State Synchronization: Lightweight state sharing solution based on ESM.\n * Event Bus: Standardized event communication mechanism to support decoupled\n   communication between applications.\n\nThrough these optimizations and expansions, we aim to make Gez a more\ncomprehensive and user-friendly micro-frontend solution, providing developers\nwith a better development experience and higher efficiency.","routePath":"/en/blog/birth-of-gez","lang":"en","toc":[{"text":"Project Background","id":"project-background","depth":2,"charIndex":97},{"text":"Limitations of Traditional Solutions","id":"limitations-of-traditional-solutions","depth":3,"charIndex":486},{"text":"Technical Evolution","id":"technical-evolution","depth":2,"charIndex":1779},{"text":"v1.0: Exploring Remote Components","id":"v10-exploring-remote-components","depth":3,"charIndex":1802},{"text":"v2.0: Module Federation Experiment","id":"v20-module-federation-experiment","depth":3,"charIndex":2309},{"text":"Embracing the ESM Era","id":"embracing-the-esm-era","depth":2,"charIndex":2884},{"text":"Standardized Module System","id":"standardized-module-system","depth":3,"charIndex":3126},{"text":"Breakthroughs in Performance and Isolation","id":"breakthroughs-in-performance-and-isolation","depth":3,"charIndex":4247},{"text":"Build Tool Selection","id":"build-tool-selection","depth":3,"charIndex":4820},{"text":"Future Outlook","id":"future-outlook","depth":2,"charIndex":5852},{"text":"Deep Optimization of Import Maps","id":"deep-optimization-of-import-maps","depth":3,"charIndex":5964},{"text":"Framework-Agnostic Routing Solution","id":"framework-agnostic-routing-solution","depth":3,"charIndex":6415},{"text":"Best Practices for Cross-Framework Communication","id":"best-practices-for-cross-framework-communication","depth":3,"charIndex":6855}],"domain":"","frontmatter":{"titleSuffix":"From Micro-Frontend Challenges to ESM Innovation: The Evolution of the Gez Framework","description":"Explore the journey of the Gez framework from the challenges of traditional micro-frontend architectures to breakthroughs in ESM-based innovation. Share technical practices in performance optimization, dependency management, and build tool selection.","head":[["meta",{"property":"keywords","content":"Gez, Micro-Frontend Framework, ESM, Import Maps, Rspack, Module Federation, Dependency Management, Performance Optimization, Technical Evolution, Server-Side Rendering"}]],"sidebar":false},"version":""},{"id":34,"title":"Team Blog","content":"#\n\nWelcome to the Gez Team's technical blog! Here, we share our experiences in\nframework development, technological innovations, and best practices.\n\n\nLatest Articles#\n\n * 2025-02-25 From Component Sharing to Native Modularization: The Evolution of\n   the Gez Micro-Frontend Framework\n   \n   > Explore the evolution of the Gez framework from traditional component\n   > sharing to native modularization based on ESM. Share technical practices in\n   > performance optimization, dependency management, and build tool selection.","routePath":"/en/blog/","lang":"en","toc":[{"text":"Latest Articles","id":"latest-articles","depth":2,"charIndex":150}],"domain":"","frontmatter":{"titleSuffix":"Gez Team Blog","description":"Technical blog of the Gez team, sharing framework development experience, best practices, and technological innovations.","head":[["meta",{"property":"keywords","content":"Gez, Team Blog, Technical Sharing, Best Practices, Development Experience"}]],"sidebar":false},"version":""},{"id":35,"title":"Path Alias","content":"#\n\nPath Alias is a module import path mapping mechanism that allows developers to\nuse short, semantic identifiers to replace full module paths. In Gez, the path\nalias mechanism offers the following advantages:\n\n * Simplified Import Paths: Use semantic aliases to replace lengthy relative\n   paths, improving code readability.\n * Avoid Deep Nesting: Eliminate maintenance difficulties caused by multi-level\n   directory references (e.g., ../../../../).\n * Type Safety: Fully integrated with TypeScript's type system, providing code\n   completion and type checking.\n * Module Resolution Optimization: Improve module resolution performance through\n   predefined path mappings.\n\n\nDefault Alias Mechanism#\n\nGez adopts an automatic alias mechanism based on service names, which follows\nthe convention-over-configuration design with the following characteristics:\n\n * Automatic Configuration: Automatically generates aliases based on the name\n   field in package.json, eliminating the need for manual configuration.\n * Unified Standard: Ensures all service modules follow consistent naming and\n   referencing conventions.\n * Type Support: Works with the npm run build:dts command to automatically\n   generate type declaration files, enabling cross-service type inference.\n * Predictability: Allows inferring module reference paths from service names,\n   reducing maintenance costs.\n\n\nConfiguration Instructions#\n\n\npackage.json Configuration#\n\nIn package.json, define the service name using the name field, which will serve\nas the default alias prefix for the service:\n\n\n\n\ntsconfig.json Configuration#\n\nTo ensure TypeScript correctly resolves alias paths, configure the paths mapping\nin tsconfig.json:\n\n\n\n\nUsage Examples#\n\n\nImporting Internal Service Modules#\n\n\n\n\nImporting Modules from Other Services#\n\n\n\nBest Practices\n * Prefer using alias paths over relative paths.\n * Maintain semantic and consistent alias paths.\n * Avoid excessive directory levels in alias paths.\n\n\n\n\nCross-Service Imports#\n\nWhen module linking (Module Link) is configured, you can import modules from\nother services in the same way:\n\n\n\n\nCustom Aliases#\n\nFor third-party packages or special scenarios, you can define custom aliases\nthrough the Gez configuration file:\n\n\n\nNotes\n 1. For business modules, it is recommended to always use the default alias\n    mechanism to maintain project consistency.\n 2. Custom aliases are primarily used for handling special requirements of\n    third-party packages or optimizing development experience.\n 3. Excessive use of custom aliases may impact code maintainability and build\n    optimization.","routePath":"/en/guide/essentials/alias","lang":"en","toc":[{"text":"Default Alias Mechanism","id":"default-alias-mechanism","depth":2,"charIndex":675},{"text":"Configuration Instructions","id":"configuration-instructions","depth":2,"charIndex":1376},{"text":"package.json Configuration","id":"packagejson-configuration","depth":3,"charIndex":1406},{"text":"tsconfig.json Configuration","id":"tsconfigjson-configuration","depth":3,"charIndex":1564},{"text":"Usage Examples","id":"usage-examples","depth":2,"charIndex":1697},{"text":"Importing Internal Service Modules","id":"importing-internal-service-modules","depth":3,"charIndex":1715},{"text":"Importing Modules from Other Services","id":"importing-modules-from-other-services","depth":3,"charIndex":1755},{"text":"Cross-Service Imports","id":"cross-service-imports","depth":3,"charIndex":1966},{"text":"Custom Aliases","id":"custom-aliases","depth":3,"charIndex":2103}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Module Import Path Mapping Guide","description":"Detailed explanation of Gez framework's path alias mechanism, including features such as simplified import paths, avoiding deep nesting, type safety, and module resolution optimization, helping developers improve code maintainability.","head":[["meta",{"property":"keywords","content":"Gez, Path Alias, TypeScript, Module Import, Path Mapping, Code Maintainability"}]]},"version":""},{"id":36,"title":"Base Path","content":"#\n\nThe Base Path refers to the prefix of the access path for static resources (such\nas JavaScript, CSS, images, etc.) in an application. In Gez, proper\nconfiguration of the base path is crucial for the following scenarios:\n\n * Multi-environment Deployment: Supporting resource access in different\n   environments such as development, testing, and production\n * Multi-region Deployment: Adapting to cluster deployment requirements in\n   different regions or countries\n * CDN Distribution: Enabling global distribution and acceleration of static\n   resources\n\n\nDefault Path Mechanism#\n\nGez employs an automatic path generation mechanism based on the service name. By\ndefault, the framework reads the name field in the project's package.json to\ngenerate the base path for static resources: /your-app-name/.\n\n\n\nThis convention-over-configuration design offers the following advantages:\n\n * Consistency: Ensures all static resources use a unified access path\n * Predictability: The resource access path can be inferred directly from the\n   name field in package.json\n * Maintainability: No additional configuration required, reducing maintenance\n   costs\n\n\nDynamic Path Configuration#\n\nIn real-world projects, we often need to deploy the same codebase to different\nenvironments or regions. Gez provides support for dynamic base paths, allowing\napplications to adapt to various deployment scenarios.\n\n\nUse Cases#\n\nSubdirectory Deployment#\n\n\n\nIndependent Domain Deployment#\n\n\n\n\nConfiguration Method#\n\nYou can dynamically set the base path based on the request context using the\nbase parameter in the gez.render() method:\n\n","routePath":"/en/guide/essentials/base-path","lang":"en","toc":[{"text":"Default Path Mechanism","id":"default-path-mechanism","depth":2,"charIndex":558},{"text":"Dynamic Path Configuration","id":"dynamic-path-configuration","depth":2,"charIndex":1151},{"text":"Use Cases","id":"use-cases","depth":3,"charIndex":1395},{"text":"Subdirectory Deployment","id":"subdirectory-deployment","depth":4,"charIndex":1407},{"text":"Independent Domain Deployment","id":"independent-domain-deployment","depth":4,"charIndex":1435},{"text":"Configuration Method","id":"configuration-method","depth":3,"charIndex":1470}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Static Resource Path Configuration Guide","description":"A detailed guide on configuring base paths in the Gez framework, including multi-environment deployment, CDN distribution, and resource access path settings, helping developers achieve flexible static resource management.","head":[["meta",{"property":"keywords","content":"Gez, Base Path, CDN, Static Resources, Multi-environment Deployment, Resource Management"}]]},"version":""},{"id":37,"title":"Client-Side Rendering","content":"\n${rc.importmap()} // Import map ${rc.moduleEntry()} // Entry module\n${rc.modulePreload()} // Module preload","routePath":"/en/guide/essentials/csr","lang":"en","toc":[{"text":"Use Cases","id":"use-cases","depth":2,"charIndex":-1},{"text":"Configuration Instructions","id":"configuration-instructions","depth":2,"charIndex":-1},{"text":"HTML Template Configuration","id":"html-template-configuration","depth":3,"charIndex":-1},{"text":"Static HTML Generation","id":"static-html-generation","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Client-Side Rendering Implementation Guide","description":"Detailed guide on the client-side rendering mechanism of the Gez framework, including static build, deployment strategies, and best practices, helping developers achieve efficient front-end rendering in serverless environments.","head":[["meta",{"property":"keywords","content":"Gez, Client-Side Rendering, CSR, Static Build, Front-End Rendering, Serverless Deployment, Performance Optimization"}]]},"version":""},{"id":38,"title":"Module Linking","content":"#\n\nThe Gez framework provides a comprehensive module linking mechanism for managing\ncode sharing and dependency relationships between services. This mechanism is\nimplemented based on the ESM (ECMAScript Module) specification, supporting\nsource-level module exports and imports, as well as complete dependency\nmanagement functionality.\n\n\nCore Concepts#\n\nModule Export#\n\nModule export is the process of exposing specific code units (such as\ncomponents, utility functions, etc.) from a service in ESM format. It supports\ntwo types of exports:\n\n * Source Code Export: Directly exports source code files from the project\n * Dependency Export: Exports third-party dependency packages used by the\n   project\n\nModule Import#\n\nModule import is the process of referencing code units exported by other\nservices within a service. It supports multiple installation methods:\n\n * Source Code Installation: Suitable for development environments, supports\n   real-time modifications and hot updates\n * Package Installation: Suitable for production environments, directly uses\n   build artifacts\n\n\nPreloading Mechanism#\n\nTo optimize service performance, Gez implements an intelligent module preloading\nmechanism:\n\n 1. Dependency Analysis\n    \n    * Analyze dependencies between components during build time\n    * Identify core modules on critical paths\n    * Determine module loading priorities\n\n 2. Loading Strategy\n    \n    * Immediate Loading: Core modules on critical paths\n    * Lazy Loading: Non-critical functional modules\n    * On-demand Loading: Conditionally rendered modules\n\n 3. Resource Optimization\n    \n    * Intelligent code splitting strategy\n    * Module-level cache management\n    * On-demand compilation and bundling\n\n\nModule Export#\n\n\nConfiguration Instructions#\n\nConfigure the modules to be exported in entry.node.ts:\n\n\n\nExport configuration supports two types:\n\n * root:*: Exports source code files, paths relative to the project root\n   directory\n * npm:*: Exports third-party dependencies, directly specifies package names\n\n\nModule Import#\n\n\nConfiguration Instructions#\n\nConfigure the modules to be imported in entry.node.ts:\n\n\n\nConfiguration item descriptions:\n\n 1. imports: Configures local paths for remote modules\n    \n    * Source code installation: Points to build artifact directory (dist)\n    * Package installation: Directly points to package directory\n\n 2. externals: Configures external dependencies\n    \n    * Used for sharing dependencies from remote modules\n    * Avoids duplicate bundling of the same dependencies\n    * Supports multiple modules sharing dependencies\n\n\nInstallation Methods#\n\nSource Code Installation#\n\nSuitable for development environments, supports real-time modifications and hot\nupdates.\n\n 1. Workspace Method Recommended for use in Monorepo projects:\n\n\n\n 2. Link Method Used for local development and debugging:\n\n\n\nPackage Installation#\n\nSuitable for production environments, directly uses build artifacts.\n\n 1. NPM Registry Install via npm registry:\n\n\n\n 2. Static Server Install via HTTP/HTTPS protocol:\n\n\n\n\nPackage Building#\n\n\nConfiguration Instructions#\n\nConfigure build options in entry.node.ts:\n\n\n\n\nBuild Artifacts#\n\n\n\n\nPublishing Process#\n\n\n\n\nBest Practices#\n\n\nDevelopment Environment Configuration#\n\n * Dependency Management\n   \n   * Use Workspace or Link method for dependency installation\n   * Unified management of dependency versions\n   * Avoid duplicate installation of the same dependencies\n\n * Development Experience\n   \n   * Enable hot update functionality\n   * Configure appropriate preloading strategies\n   * Optimize build speed\n\n\nProduction Environment Configuration#\n\n * Deployment Strategy\n   \n   * Use NPM Registry or static server\n   * Ensure build artifact integrity\n   * Implement canary release mechanism\n\n * Performance Optimization\n   \n   * Properly configure resource preloading\n   * Optimize module loading order\n   * Implement effective caching strategies\n\n\nVersion Management#\n\n * Version Specification\n   \n   * Follow semantic versioning specification\n   * Maintain detailed changelogs\n   * Conduct version compatibility testing\n\n * Dependency Updates\n   \n   * Update dependencies promptly\n   * Conduct regular security audits\n   * Maintain dependency version consistency\n\n","routePath":"/en/guide/essentials/module-link","lang":"en","toc":[{"text":"Core Concepts","id":"core-concepts","depth":3,"charIndex":336},{"text":"Module Export","id":"module-export","depth":4,"charIndex":352},{"text":"Module Import","id":"module-import","depth":4,"charIndex":701},{"text":"Preloading Mechanism","id":"preloading-mechanism","depth":3,"charIndex":1079},{"text":"Module Export","id":"module-export-1","depth":2,"charIndex":1720},{"text":"Configuration Instructions","id":"configuration-instructions","depth":3,"charIndex":1737},{"text":"Module Import","id":"module-import-1","depth":2,"charIndex":2031},{"text":"Configuration Instructions","id":"configuration-instructions-1","depth":3,"charIndex":2048},{"text":"Installation Methods","id":"installation-methods","depth":3,"charIndex":2590},{"text":"Source Code Installation","id":"source-code-installation","depth":4,"charIndex":2613},{"text":"Package Installation","id":"package-installation","depth":4,"charIndex":2857},{"text":"Package Building","id":"package-building","depth":2,"charIndex":3051},{"text":"Configuration Instructions","id":"configuration-instructions-2","depth":3,"charIndex":3071},{"text":"Build Artifacts","id":"build-artifacts","depth":3,"charIndex":3146},{"text":"Publishing Process","id":"publishing-process","depth":3,"charIndex":3167},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":3191},{"text":"Development Environment Configuration","id":"development-environment-configuration","depth":3,"charIndex":3209},{"text":"Production Environment Configuration","id":"production-environment-configuration","depth":3,"charIndex":3591},{"text":"Version Management","id":"version-management","depth":3,"charIndex":3931}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Inter-Service Code Sharing Mechanism","description":"Detailed introduction to Gez framework's module linking mechanism, including inter-service code sharing, dependency management, and ESM specification implementation, helping developers build efficient micro-frontend applications.","head":[["meta",{"property":"keywords","content":"Gez, Module Linking, ESM, Code Sharing, Dependency Management, Micro-frontend"}]]},"version":""},{"id":39,"title":"Render Context","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/en/guide/essentials/render-context","lang":"en","toc":[{"text":"Usage","id":"usage","depth":2,"charIndex":-1},{"text":"Main Features","id":"main-features","depth":2,"charIndex":-1},{"text":"Dependency Collection","id":"dependency-collection","depth":3,"charIndex":-1},{"text":"On-demand Collection","id":"on-demand-collection","depth":4,"charIndex":-1},{"text":"Automated Processing","id":"automated-processing","depth":4,"charIndex":-1},{"text":"Performance Optimization","id":"performance-optimization","depth":4,"charIndex":-1},{"text":"Resource Injection","id":"resource-injection","depth":3,"charIndex":-1},{"text":"Resource Injection Order","id":"resource-injection-order","depth":3,"charIndex":-1},{"text":"Complete Rendering Process","id":"complete-rendering-process","depth":2,"charIndex":-1},{"text":"Advanced Features","id":"advanced-features","depth":2,"charIndex":-1},{"text":"Base Path Configuration","id":"base-path-configuration","depth":3,"charIndex":-1},{"text":"Import Map Modes","id":"import-map-modes","depth":3,"charIndex":-1},{"text":"Entry Function Configuration","id":"entry-function-configuration","depth":3,"charIndex":-1},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Server-Side Rendering Core Mechanism","description":"Detailed introduction to the RenderContext mechanism of the Gez framework, including resource management, HTML generation, and ESM module system, helping developers understand and utilize server-side rendering capabilities.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, Server-Side Rendering, ESM, Resource Management"}]]},"version":""},{"id":40,"title":"Rspack","content":"#\n\nGez is built on the Rspack build system, leveraging its high-performance build\ncapabilities. This document will introduce the role and core features of Rspack\nin the Gez framework.\n\n\nFeatures#\n\nRspack is the core build system of the Gez framework, offering the following key\nfeatures:\n\n * High-Performance Builds: A Rust-based build engine that provides extremely\n   fast compilation performance, significantly improving build speeds for large\n   projects.\n * Optimized Development Experience: Supports modern development features such\n   as Hot Module Replacement (HMR) and incremental compilation, delivering a\n   smooth development experience.\n * Multi-Environment Builds: Unified build configurations support client,\n   server, and Node.js environments, simplifying multi-platform development\n   workflows.\n * Resource Optimization: Built-in resource processing and optimization\n   capabilities, including code splitting, Tree Shaking, and resource\n   compression.\n\n\nBuilding Applications#\n\nGez's Rspack build system is designed with a modular architecture, primarily\nconsisting of the following core modules:\n\n\n@gez/rspack#\n\nThe foundational build module, providing the following core capabilities:\n\n * Unified Build Configuration: Standardized build configuration management with\n   support for multi-environment configurations.\n * Resource Processing: Built-in handling for TypeScript, CSS, images, and other\n   resources.\n * Build Optimization: Features such as code splitting and Tree Shaking for\n   performance optimization.\n * Development Server: Integrated high-performance development server with HMR\n   support.\n\n\n@gez/rspack-vue#\n\nA specialized build module for the Vue framework, offering:\n\n * Vue Component Compilation: Efficient compilation for Vue 2/3 components.\n * SSR Optimization: Specific optimizations for server-side rendering scenarios.\n * Development Enhancements: Enhanced features tailored for Vue development\n   environments.\n\n\nBuild Process#\n\nThe build process in Gez is divided into the following stages:\n\n 1. Configuration Initialization\n    \n    * Load project configurations.\n    * Merge default and user configurations.\n    * Adjust configurations based on environment variables.\n\n 2. Resource Compilation\n    \n    * Resolve source code dependencies.\n    * Transform various resources (TypeScript, CSS, etc.).\n    * Handle module imports and exports.\n\n 3. Optimization\n    \n    * Perform code splitting.\n    * Apply Tree Shaking.\n    * Compress code and resources.\n\n 4. Output Generation\n    \n    * Generate target files.\n    * Output resource maps.\n    * Generate build reports.\n\n\nBest Practices#\n\n\nDevelopment Environment Optimization#\n\n * Incremental Compilation Configuration: Properly configure the cache option to\n   leverage caching for faster builds.\n * HMR Optimization: Configure the scope of hot updates to avoid unnecessary\n   module updates.\n * Resource Processing Optimization: Use appropriate loader configurations to\n   avoid redundant processing.\n\n\nProduction Environment Optimization#\n\n * Code Splitting Strategy: Properly configure splitChunks to optimize resource\n   loading.\n * Resource Compression: Enable appropriate compression configurations to\n   balance build time and output size.\n * Cache Optimization: Utilize content hashing and long-term caching strategies\n   to improve loading performance.\n\n\nConfiguration Example#\n\n\n\nTIP\n\nFor more detailed API documentation and configuration options, please refer to\nthe Rspack API Documentation.","routePath":"/en/guide/essentials/rspack","lang":"en","toc":[{"text":"Features","id":"features","depth":2,"charIndex":185},{"text":"Building Applications","id":"building-applications","depth":2,"charIndex":973},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1118},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1630},{"text":"Build Process","id":"build-process","depth":2,"charIndex":1961},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":2621},{"text":"Development Environment Optimization","id":"development-environment-optimization","depth":3,"charIndex":2639},{"text":"Production Environment Optimization","id":"production-environment-optimization","depth":3,"charIndex":3005},{"text":"Configuration Example","id":"configuration-example","depth":2,"charIndex":3365}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework High-Performance Build Engine","description":"An in-depth analysis of the Rspack build system in the Gez framework, including core features such as high-performance compilation, multi-environment builds, and resource optimization, helping developers build efficient and reliable modern web applications.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Build System, High-Performance Compilation, Hot Module Replacement, Multi-Environment Build, Tree Shaking, Code Splitting, SSR, Resource Optimization, Development Efficiency, Build Tools"}]]},"version":""},{"id":41,"title":"Standard Specifications","content":"#\n\nGez is a modern SSR framework that adopts standardized project structures and\npath resolution mechanisms to ensure consistency and maintainability across\ndevelopment and production environments.\n\n\nProject Structure Specifications#\n\n\nStandard Directory Structure#\n\n\n\nExtended Knowledge\n * gez.name is derived from the name field in package.json\n * dist/package.json is derived from the root directory's package.json\n * The dist directory is archived only when packs.enable is set to true\n\n\nEntry File Specifications#\n\n\nentry.client.ts#\n\nThe client entry file is responsible for:\n\n * Application Initialization: Configuring basic settings for the client\n   application\n * Routing Management: Handling client-side routing and navigation\n * State Management: Implementing client-side state storage and updates\n * Interaction Handling: Managing user events and interface interactions\n\n\nentry.server.ts#\n\nThe server entry file is responsible for:\n\n * Server-Side Rendering: Executing the SSR rendering process\n * HTML Generation: Building the initial page structure\n * Data Prefetching: Handling server-side data fetching\n * State Injection: Passing server-side state to the client\n * SEO Optimization: Ensuring search engine optimization for pages\n\n\nentry.node.ts#\n\nThe Node.js server entry file is responsible for:\n\n * Server Configuration: Setting HTTP server parameters\n * Routing Handling: Managing server-side routing rules\n * Middleware Integration: Configuring server middleware\n * Environment Management: Handling environment variables and configurations\n * Request Response: Processing HTTP requests and responses\n\n\nConfiguration File Specifications#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/en/guide/essentials/std","lang":"en","toc":[{"text":"Project Structure Specifications","id":"project-structure-specifications","depth":2,"charIndex":199},{"text":"Standard Directory Structure","id":"standard-directory-structure","depth":3,"charIndex":235},{"text":"Entry File Specifications","id":"entry-file-specifications","depth":2,"charIndex":491},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":520},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":883},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1247},{"text":"Configuration File Specifications","id":"configuration-file-specifications","depth":2,"charIndex":1622},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1659},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1677}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Project Structure and Specification Guide","description":"Detailed introduction to the standard project structure, entry file specifications, and configuration file specifications of the Gez framework, helping developers build standardized and maintainable SSR applications.","head":[["meta",{"property":"keywords","content":"Gez, Project Structure, Entry Files, Configuration Specifications, SSR Framework, TypeScript, Project Standards, Development Standards"}]]},"version":""},{"id":42,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/en/guide/frameworks/html","lang":"en","toc":[{"text":"Project Structure","id":"project-structure","depth":2,"charIndex":-1},{"text":"Project Configuration","id":"project-configuration","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Source Code Structure","id":"source-code-structure","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Running the Project","id":"running-the-project","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework HTML SSR Application Example","description":"Build a Gez-based HTML SSR application from scratch. This example demonstrates the basic usage of the framework, including project initialization, HTML configuration, and entry file setup.","head":[["meta",{"property":"keywords","content":"Gez, HTML, SSR Application, TypeScript Configuration, Project Initialization, Server-Side Rendering, Client-Side Interaction"}]]},"version":""},{"id":43,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/en/guide/frameworks/preact-htm","lang":"en","toc":[{"text":"Project Structure","id":"project-structure","depth":2,"charIndex":-1},{"text":"Project Configuration","id":"project-configuration","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Source Code Structure","id":"source-code-structure","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Running the Project","id":"running-the-project","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Preact+HTM SSR Application Example","description":"Build a Preact+HTM SSR application from scratch using the Gez framework. This example demonstrates the basic usage of the framework, including project initialization, Preact configuration, and entry file setup.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, SSR Application, TypeScript Configuration, Project Initialization, Server-Side Rendering, Client-Side Interaction"}]]},"version":""},{"id":44,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/en/guide/frameworks/vue2","lang":"en","toc":[{"text":"Project Structure","id":"project-structure","depth":2,"charIndex":-1},{"text":"Project Configuration","id":"project-configuration","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Source Code Structure","id":"source-code-structure","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Running the Project","id":"running-the-project","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Vue2 SSR Application Example","description":"Build a Vue2 SSR application from scratch using Gez framework. This example demonstrates the basic usage of the framework, including project initialization, Vue2 configuration, and entry file setup.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, SSR Application, TypeScript Configuration, Project Initialization, Server-Side Rendering, Client-Side Interaction"}]]},"version":""},{"id":45,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/en/guide/frameworks/vue3","lang":"en","toc":[{"text":"Project Structure","id":"project-structure","depth":2,"charIndex":-1},{"text":"Project Configuration","id":"project-configuration","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Source Code Structure","id":"source-code-structure","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Running the Project","id":"running-the-project","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Vue3 SSR Application Example","description":"Build a Vue3 SSR application based on Gez from scratch. This example demonstrates the basic usage of the framework, including project initialization, Vue3 configuration, and entry file setup.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, SSR Application, TypeScript Configuration, Project Initialization, Server-Side Rendering, Client-Side Interaction, Composition API"}]]},"version":""},{"id":46,"title":"Environmental Requirements","content":"#\n\nThis document outlines the environmental requirements for using this framework,\nincluding Node.js environment and browser compatibility.\n\n\nNode.js Environment#\n\nThe framework requires Node.js version >= 22.6, primarily to support TypeScript\ntype imports (via the --experimental-strip-types flag) without additional\ncompilation steps.\n\n\nBrowser Compatibility#\n\nThe framework is built in compatibility mode by default to support a wider range\nof browsers. However, to achieve full browser compatibility, you need to\nmanually add the es-module-shims dependency.\n\n\nCompatibility Mode (Default)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nAccording to Can I Use statistics, the browser coverage in compatibility mode\nreaches 96.81%.\n\n\nNative Support Mode#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nNative support mode offers the following advantages:\n\n * Zero runtime overhead, no additional module loader required\n * Native browser parsing, faster execution speed\n * Better code splitting and on-demand loading capabilities\n\nAccording to Can I Use statistics, the browser coverage in native support mode\nreaches 93.5%.\n\n\nEnabling Compatibility Support#\n\nImportant Note\n\nAlthough the framework is built in compatibility mode by default, to achieve\nfull support for older browsers, you need to add the es-module-shims dependency\nto your project.\n\nAdd the following script to your HTML file:\n\n\n\nBest Practices\n 1. Production Environment Recommendations:\n    * Deploy es-module-shims to your own server\n    * Ensure resource loading stability and access speed\n    * Avoid potential security risks\n 2. Performance Considerations:\n    * Compatibility mode incurs a slight performance overhead\n    * Decide whether to enable it based on the browser distribution of your\n      target user base","routePath":"/en/guide/start/environment","lang":"en","toc":[{"text":"Node.js Environment","id":"nodejs-environment","depth":2,"charIndex":141},{"text":"Browser Compatibility","id":"browser-compatibility","depth":2,"charIndex":338},{"text":"Compatibility Mode (Default)","id":"compatibility-mode-default","depth":3,"charIndex":563},{"text":"Native Support Mode","id":"native-support-mode","depth":3,"charIndex":770},{"text":"Enabling Compatibility Support","id":"enabling-compatibility-support","depth":3,"charIndex":1199}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Compatibility Guide","description":"Detailed introduction to the environmental requirements of the Gez framework, including Node.js version requirements and browser compatibility instructions, helping developers properly configure their development environment.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, Browser Compatibility, TypeScript, es-module-shims, Environment Configuration"}]]},"version":""},{"id":47,"title":"Quick Start","content":"#\n\n\nProject Initialization#\n\nTo create and initialize a new Gez project, follow these steps:\n\n\n\n\nFramework Version Selection#\n\nThe Gez framework offers multiple technology stack versions, each optimized for\ndifferent application scenarios. Choose the appropriate version based on your\nproject requirements:\n\n\nHTML#\n\nIdeal for projects pursuing a minimalist architecture:\n\n * Zero external dependencies, ready to use out of the box\n * Native JavaScript development experience\n * Suitable for building static websites and lightweight applications\n * Supports progressive feature expansion\n\nView HTML Version Documentation\n\n\nVue2#\n\nDesigned for enterprise-level application development:\n\n * Full TypeScript support\n * Rich ecosystem of third-party components\n * Mature development toolchain\n * Proven stability in production environments\n\nView Vue2 Version Documentation\n\n\nVue3#\n\nTailored for modern web application development:\n\n * Proxy-based reactivity system\n * Composition API support\n * Improved runtime performance\n * Smaller bundle size\n\nView Vue3 Version Documentation\n\n\nPreact+HTM#\n\nPerfect for projects prioritizing lightweight and high performance:\n\n * Minimal runtime size (3KB)\n * Native JavaScript template syntax\n * React-compatible API\n * Excellent performance\n\nView Preact+HTM Version Documentation\n\n\nAI-Assisted Development#\n\nThe Gez framework provides AI-assisted development capabilities to significantly\nenhance development efficiency:\n\n 1. Select the appropriate framework version documentation\n 2. Provide the documentation content to the AI assistant\n 3. The AI will automatically generate the project skeleton and configuration\n    files\n\nTip\n\nAI-assisted development not only speeds up project initialization but also\nensures that the project structure adheres to best practices.","routePath":"/en/guide/start/getting-started","lang":"en","toc":[{"text":"Project Initialization","id":"project-initialization","depth":2,"charIndex":3},{"text":"Framework Version Selection","id":"framework-version-selection","depth":2,"charIndex":96},{"text":"HTML","id":"html","depth":3,"charIndex":308},{"text":"Vue2","id":"vue2","depth":3,"charIndex":621},{"text":"Vue3","id":"vue3","depth":3,"charIndex":869},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1076},{"text":"AI-Assisted Development","id":"ai-assisted-development","depth":2,"charIndex":1315}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Quick Start Guide","description":"A quick start guide for the Gez framework, helping you set up a project from scratch, including project initialization, framework version selection, and AI-assisted development.","head":[["meta",{"name":"keywords","content":"Gez framework, Quick Start, Project Initialization, Vue Development, HTML Development, AI Assistance"}]]},"version":""},{"id":48,"title":"Introduction","content":"#\n\n\nProject Background#\n\nGez is a modern micro-frontend framework based on ECMAScript Modules (ESM),\nfocusing on building high-performance, scalable server-side rendering (SSR)\napplications. As the third-generation product of the Genesis project, Gez has\ncontinuously innovated during its technological evolution:\n\n * v1.0: Implemented on-demand loading of remote components based on HTTP\n   requests\n * v2.0: Achieved application integration based on Webpack Module Federation\n * v3.0: Redesigned the Module Linking system based on native browser ESM\n\n\nTechnical Background#\n\nIn the development of micro-frontend architecture, traditional solutions mainly\nface the following limitations:\n\n\nChallenges of Existing Solutions#\n\n * Performance Bottlenecks: Runtime dependency injection and JavaScript sandbox\n   proxies introduce significant performance overhead\n * Isolation Mechanisms: Custom sandbox environments struggle to match the\n   native module isolation capabilities of browsers\n * Build Complexity: Build tool modifications for dependency sharing increase\n   project maintenance costs\n * Deviation from Standards: Special deployment strategies and runtime\n   processing mechanisms deviate from modern web development standards\n * Ecosystem Limitations: Framework coupling and custom APIs restrict technology\n   stack choices\n\n\nTechnological Innovations#\n\nGez provides a new solution based on modern web standards:\n\n * Native Module System: Utilizes native browser ESM and Import Maps for\n   dependency management, offering faster parsing and execution speeds\n * Standard Isolation Mechanism: Reliable application isolation based on\n   ECMAScript module scope\n * Open Technology Stack: Supports seamless integration with any modern frontend\n   framework\n * Optimized Development Experience: Provides intuitive development patterns and\n   comprehensive debugging capabilities\n * Extreme Performance Optimization: Achieves zero runtime overhead through\n   native capabilities, combined with intelligent caching strategies\n\nTIP\n\nGez focuses on building high-performance, easily extensible micro-frontend\ninfrastructure, particularly suitable for large-scale server-side rendering\napplication scenarios.\n\n\nTechnical Specifications#\n\n\nEnvironment Dependencies#\n\nPlease refer to the Environment Requirements documentation for detailed browser\nand Node.js environment requirements.\n\n\nCore Technology Stack#\n\n * Dependency Management: Uses Import Maps for module mapping, with\n   es-module-shims providing compatibility support\n * Build System: Based on Rspack's module-import for handling external\n   dependencies\n * Development Toolchain: Supports ESM hot updates and native TypeScript\n   execution\n\n\nFramework Positioning#\n\nGez differs from Next.js or Nuxt.js, focusing on providing micro-frontend\ninfrastructure:\n\n * Module Linking System: Implements efficient and reliable module import/export\n * Server-side Rendering: Provides flexible SSR implementation mechanisms\n * Type System Support: Integrates complete TypeScript type definitions\n * Framework Neutrality: Supports integration with mainstream frontend\n   frameworks\n\n\nArchitecture Design#\n\n\nCentralized Dependency Management#\n\n * Unified Dependency Source: Centralized third-party dependency management\n * Automated Distribution: Global automatic synchronization of dependency\n   updates\n * Version Consistency: Precise dependency version control\n\n\nModular Design#\n\n * Separation of Concerns: Decouples business logic from infrastructure\n * Plugin Mechanism: Supports flexible module composition and replacement\n * Standard Interfaces: Standardized inter-module communication protocols\n\n\nPerformance Optimization#\n\n * Zero Overhead Principle: Maximizes the use of native browser capabilities\n * Intelligent Caching: Content hash-based precise caching strategy\n * On-demand Loading: Fine-grained code splitting and dependency management\n\n\nProject Maturity#\n\nThrough nearly 5 years of iterative evolution (v1.0 to v3.0), Gez has been fully\nvalidated in enterprise environments. It currently supports the stable operation\nof dozens of business projects and continues to drive the modernization of\ntechnology stacks. The framework's stability, reliability, and performance\nadvantages have been thoroughly tested in practice, providing a reliable\ntechnical foundation for large-scale application development.","routePath":"/en/guide/start/introduction","lang":"en","toc":[{"text":"Project Background","id":"project-background","depth":2,"charIndex":3},{"text":"Technical Background","id":"technical-background","depth":2,"charIndex":553},{"text":"Challenges of Existing Solutions","id":"challenges-of-existing-solutions","depth":3,"charIndex":690},{"text":"Technological Innovations","id":"technological-innovations","depth":3,"charIndex":1335},{"text":"Technical Specifications","id":"technical-specifications","depth":2,"charIndex":2209},{"text":"Environment Dependencies","id":"environment-dependencies","depth":3,"charIndex":2237},{"text":"Core Technology Stack","id":"core-technology-stack","depth":3,"charIndex":2384},{"text":"Framework Positioning","id":"framework-positioning","depth":2,"charIndex":2702},{"text":"Architecture Design","id":"architecture-design","depth":2,"charIndex":3131},{"text":"Centralized Dependency Management","id":"centralized-dependency-management","depth":3,"charIndex":3154},{"text":"Modular Design","id":"modular-design","depth":3,"charIndex":3412},{"text":"Performance Optimization","id":"performance-optimization","depth":3,"charIndex":3651},{"text":"Project Maturity","id":"project-maturity","depth":2,"charIndex":3901}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Overview and Technological Innovations","description":"Gain an in-depth understanding of the project background, technological evolution, and core advantages of the Gez micro-frontend framework. Explore modern server-side rendering solutions based on ESM.","head":[["meta",{"property":"keywords","content":"Gez, Micro-frontend, ESM, Server-side Rendering, SSR, Technological Innovation, Module Federation"}]]},"version":""}]