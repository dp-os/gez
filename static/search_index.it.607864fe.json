[{"id":125,"title":"@gez/rspack-vue","content":"#\n\nIl pacchetto Rspack Vue fornisce un set di API per creare e configurare\napplicazioni Rspack basate sul framework Vue, supportando lo sviluppo di\ncomponenti Vue, la costruzione e il rendering lato server.\n\n\nInstallazione#\n\nInstalla @gez/rspack-vue come dipendenza di sviluppo utilizzando il gestore di\npacchetti:\n\n\nEsportazione dei tipi#\n\n\nBuildTarget#\n\n\n\nTipo di ambiente di costruzione, che definisce l'ambiente di destinazione per la\ncostruzione dell'applicazione, utilizzato per configurare ottimizzazioni e\nfunzionalità specifiche durante il processo di costruzione:\n\n * node: Costruisce il codice per l'esecuzione in ambiente Node.js\n * client: Costruisce il codice per l'esecuzione in ambiente browser\n * server: Costruisce il codice per l'esecuzione in ambiente server\n\n\nRspackAppConfigContext#\n\n\n\nInterfaccia del contesto di configurazione dell'applicazione Rspack, che\nfornisce informazioni contestuali accessibili nelle funzioni di hook di\nconfigurazione:\n\n * gez: Istanza del framework Gez\n * buildTarget: Obiettivo di costruzione corrente (client/server/node)\n * config: Oggetto di configurazione Rspack\n * options: Opzioni di configurazione dell'applicazione\n\n\nRspackAppOptions#\n\n\n\nInterfaccia delle opzioni di configurazione dell'applicazione Rspack:\n\n * css: Modalità di output CSS, opzioni 'css' (file separato) o 'style' (stile\n   inline)\n * loaders: Configurazione personalizzata dei loader\n * styleLoader: Opzioni di configurazione per style-loader\n * cssLoader: Opzioni di configurazione per css-loader\n * target: Configurazione della compatibilità degli obiettivi di costruzione\n * definePlugin: Definizione di costanti globali\n * config: Funzione di hook di configurazione\n\n\nRspackHtmlAppOptions#\n\nEredita da RspackAppOptions, utilizzato per configurare opzioni specifiche per\nle applicazioni HTML.\n\n\nEsportazione delle funzioni#\n\n\ncreateRspackApp#\n\n\n\nCrea un'istanza standard di un'applicazione Rspack.\n\nParametri:\n\n * gez: Istanza del framework Gez\n * options: Opzioni di configurazione dell'applicazione Rspack\n\nValore restituito:\n\n * Restituisce una Promise che si risolve nell'istanza dell'applicazione creata\n\n\ncreateRspackHtmlApp#\n\n\n\nCrea un'istanza di un'applicazione Rspack di tipo HTML.\n\nParametri:\n\n * gez: Istanza del framework Gez\n * options: Opzioni di configurazione dell'applicazione HTML\n\nValore restituito:\n\n * Restituisce una Promise che si risolve nell'istanza dell'applicazione HTML\n   creata\n\n\nEsportazione delle costanti#\n\n\nRSPACK_LOADER#\n\n\n\nOggetto di mappatura degli identificatori dei loader integrati in Rspack, che\nfornisce costanti per i nomi dei loader più comuni:\n\n * builtinSwcLoader: Loader SWC integrato in Rspack, utilizzato per elaborare\n   file TypeScript/JavaScript\n * lightningcssLoader: Loader lightningcss integrato in Rspack, utilizzato per\n   elaborare file CSS con un compilatore ad alte prestazioni\n * styleLoader: Loader utilizzato per iniettare CSS nel DOM\n * cssLoader: Loader utilizzato per analizzare file CSS e gestire la\n   modularizzazione CSS\n * lessLoader: Loader utilizzato per compilare file Less in CSS\n * styleResourcesLoader: Loader utilizzato per importare automaticamente risorse\n   di stile globali (come variabili, mixins)\n * workerRspackLoader: Loader utilizzato per elaborare file Web Worker\n\nUtilizzando queste costanti, è possibile fare riferimento ai loader integrati\nnella configurazione, evitando di inserire manualmente stringhe:\n\n\n\nNote:\n\n * Questi loader sono già integrati in Rspack e non richiedono installazioni\n   aggiuntive\n * Quando si configura un loader personalizzato, è possibile utilizzare queste\n   costanti per sostituire l'implementazione predefinita del loader\n * Alcuni loader (come builtinSwcLoader) hanno opzioni di configurazione\n   specifiche, consultare la documentazione di configurazione pertinente\n\n\nEsportazione dei moduli#\n\n\nrspack#\n\nRiesporta tutti i contenuti del pacchetto @rspack/core, fornendo funzionalità\ncomplete del core di Rspack.","routePath":"/it/api/app/rspack-vue","lang":"it","toc":[{"text":"Installazione","id":"installazione","depth":2,"charIndex":208},{"text":"Esportazione dei tipi","id":"esportazione-dei-tipi","depth":2,"charIndex":316},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":341},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":780},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1176},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1699},{"text":"Esportazione delle funzioni","id":"esportazione-delle-funzioni","depth":2,"charIndex":1825},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1856},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":2141},{"text":"Esportazione delle costanti","id":"esportazione-delle-costanti","depth":2,"charIndex":2440},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2471},{"text":"Esportazione dei moduli","id":"esportazione-dei-moduli","depth":2,"charIndex":3822},{"text":"rspack","id":"rspack","depth":3,"charIndex":3849}],"domain":"","frontmatter":{"titleSuffix":"Strumento di costruzione Vue per il framework Gez","description":"Lo strumento di costruzione dedicato a Vue per il framework Gez, che fornisce supporto completo per la creazione di applicazioni Vue 2/3, inclusi lo sviluppo di componenti, il rendering SSR e l'ottimizzazione delle prestazioni.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, strumento di costruzione, sviluppo di componenti, rendering lato server, ottimizzazione delle prestazioni"}]]},"version":""},{"id":126,"title":"@gez/rspack","content":"#\n\nIl pacchetto Rspack fornisce un set di API per creare e configurare applicazioni\nRspack, supportando la costruzione e lo sviluppo di applicazioni standard e\nHTML.\n\n\nInstallazione#\n\nInstalla le dipendenze di sviluppo @gez/rspack utilizzando un gestore di\npacchetti:\n\n\nEsportazione dei Tipi#\n\n\nBuildTarget#\n\n\n\nTipo di ambiente di costruzione, definisce l'ambiente di destinazione per la\ncostruzione dell'applicazione, utilizzato per configurare ottimizzazioni e\nfunzionalità specifiche durante il processo di costruzione:\n\n * node: Costruisce codice per l'esecuzione in ambiente Node.js\n * client: Costruisce codice per l'esecuzione in ambiente browser\n * server: Costruisce codice per l'esecuzione in ambiente server\n\n\nRspackAppConfigContext#\n\n\n\nInterfaccia del contesto di configurazione dell'applicazione Rspack, fornisce\ninformazioni di contesto accessibili nelle funzioni di hook di configurazione:\n\n * gez: Istanza del framework Gez\n * buildTarget: Obiettivo di costruzione corrente (client/server/node)\n * config: Oggetto di configurazione Rspack\n * options: Opzioni di configurazione dell'applicazione\n\n\nRspackAppOptions#\n\n\n\nInterfaccia delle opzioni di configurazione dell'applicazione Rspack:\n\n * css: Modalità di output CSS, opzioni 'css' (file separato) o 'style' (stili\n   inline)\n * loaders: Configurazione personalizzata dei loader\n * styleLoader: Opzioni di configurazione per style-loader\n * cssLoader: Opzioni di configurazione per css-loader\n * target: Configurazione della compatibilità degli obiettivi di costruzione\n * definePlugin: Definizione di costanti globali\n * config: Funzione di hook di configurazione\n\n\nRspackHtmlAppOptions#\n\nEredita da RspackAppOptions, utilizzato per configurare opzioni specifiche per\napplicazioni HTML.\n\n\nEsportazione delle Funzioni#\n\n\ncreateRspackApp#\n\n\n\nCrea un'istanza di applicazione Rspack standard.\n\nParametri:\n\n * gez: Istanza del framework Gez\n * options: Opzioni di configurazione dell'applicazione Rspack\n\nValore di ritorno:\n\n * Restituisce una Promise che si risolve nell'istanza dell'applicazione creata\n\n\ncreateRspackHtmlApp#\n\n\n\nCrea un'istanza di applicazione Rspack di tipo HTML.\n\nParametri:\n\n * gez: Istanza del framework Gez\n * options: Opzioni di configurazione dell'applicazione HTML\n\nValore di ritorno:\n\n * Restituisce una Promise che si risolve nell'istanza dell'applicazione HTML\n   creata\n\n\nEsportazione delle Costanti#\n\n\nRSPACK_LOADER#\n\n\n\nOggetto di mappatura degli identificatori dei loader integrati in Rspack,\nfornisce costanti di nome per i loader comuni:\n\n * builtinSwcLoader: Loader SWC integrato in Rspack, utilizzato per elaborare\n   file TypeScript/JavaScript\n * lightningcssLoader: Loader lightningcss integrato in Rspack, utilizzato per\n   elaborare file CSS con un compilatore ad alte prestazioni\n * styleLoader: Loader utilizzato per iniettare CSS nel DOM\n * cssLoader: Loader utilizzato per analizzare file CSS e gestire la\n   modularizzazione CSS\n * lessLoader: Loader utilizzato per compilare file Less in CSS\n * styleResourcesLoader: Loader utilizzato per importare automaticamente risorse\n   di stile globali (come variabili, mixins)\n * workerRspackLoader: Loader utilizzato per elaborare file Web Worker\n\nUtilizzando queste costanti è possibile fare riferimento ai loader integrati\nnella configurazione, evitando di digitare manualmente le stringhe:\n\n\n\nNote:\n\n * Questi loader sono già integrati in Rspack e non richiedono installazioni\n   aggiuntive\n * Nella configurazione personalizzata dei loader, è possibile utilizzare queste\n   costanti per sostituire l'implementazione predefinita dei loader\n * Alcuni loader (come builtinSwcLoader) hanno opzioni di configurazione\n   specifiche, fare riferimento alla documentazione di configurazione pertinente\n\n\nEsportazione dei Moduli#\n\n\nrspack#\n\nRiesporta tutti i contenuti del pacchetto @rspack/core, fornendo funzionalità\ncomplete del core di Rspack.","routePath":"/it/api/app/rspack","lang":"it","toc":[{"text":"Installazione","id":"installazione","depth":2,"charIndex":167},{"text":"Esportazione dei Tipi","id":"esportazione-dei-tipi","depth":2,"charIndex":269},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":294},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":720},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1112},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1635},{"text":"Esportazione delle Funzioni","id":"esportazione-delle-funzioni","depth":2,"charIndex":1758},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1789},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":2071},{"text":"Esportazione delle Costanti","id":"esportazione-delle-costanti","depth":2,"charIndex":2367},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2398},{"text":"Esportazione dei Moduli","id":"esportazione-dei-moduli","depth":2,"charIndex":3752},{"text":"rspack","id":"rspack","depth":3,"charIndex":3779}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rspack Build Tool","description":"Lo strumento di costruzione Rspack del framework Gez offre capacità di costruzione ad alte prestazioni, supportando lo sviluppo e la costruzione di applicazioni standard e HTML, con vari processori di risorse e configurazioni di ottimizzazione integrate.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, strumento di costruzione, costruzione di applicazioni, applicazione HTML, TypeScript, CSS, elaborazione risorse, ottimizzazione delle prestazioni"}]]},"version":""},{"id":127,"title":"App","content":"#\n\nApp è l'astrazione dell'applicazione del framework Gez, che fornisce\nun'interfaccia unificata per gestire il ciclo di vita dell'applicazione, le\nrisorse statiche e il rendering lato server.\n\n\n\n\nDefinizione dei tipi#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Tipo: Middleware\n\nMiddleware per la gestione delle risorse statiche.\n\nAmbiente di sviluppo:\n\n * Gestisce le richieste di risorse statiche dal codice sorgente\n * Supporta la compilazione in tempo reale e l'aggiornamento a caldo (hot\n   reload)\n * Utilizza una strategia di cache no-cache\n\nAmbiente di produzione:\n\n * Gestisce le risorse statiche dopo la build\n * Supporta la cache a lungo termine per file immutabili (.final.xxx)\n * Strategia di caricamento delle risorse ottimizzata\n\n\n\nrender#\n\n * Tipo: (options?: RenderContextOptions) => Promise\n\nFunzione di rendering lato server. Fornisce implementazioni diverse in base\nall'ambiente di esecuzione:\n\n * Ambiente di produzione (start): Carica il file di ingresso del server dopo la\n   build (entry.server) ed esegue il rendering\n * Ambiente di sviluppo (dev): Carica il file di ingresso del server dal codice\n   sorgente ed esegue il rendering\n\n\n\nbuild#\n\n * Tipo: () => Promise\n\nFunzione di build per l'ambiente di produzione. Utilizzata per il bundling e\nl'ottimizzazione delle risorse. Restituisce true in caso di successo, false in\ncaso di fallimento.\n\ndestroy#\n\n * Tipo: () => Promise\n\nFunzione di pulizia delle risorse. Utilizzata per chiudere il server,\ndisconnettere le connessioni, ecc. Restituisce true in caso di successo, false\nin caso di fallimento.","routePath":"/it/api/core/app","lang":"it","toc":[{"text":"Definizione dei tipi","id":"definizione-dei-tipi","depth":2,"charIndex":196},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":228},{"text":"render","id":"render","depth":4,"charIndex":730},{"text":"build","id":"build","depth":4,"charIndex":1144},{"text":"destroy","id":"destroy","depth":4,"charIndex":1353}],"domain":"","frontmatter":{"titleSuffix":"Interfaccia astratta dell'applicazione del framework Gez","description":"Descrizione dettagliata dell'interfaccia App del framework Gez, inclusa la gestione del ciclo di vita dell'applicazione, la gestione delle risorse statiche e il rendering lato server, per aiutare gli sviluppatori a comprendere e utilizzare le funzionalità principali dell'applicazione.","head":[["meta",{"property":"keywords","content":"Gez, App, astrazione applicazione, ciclo di vita, risorse statiche, rendering lato server, API"}]]},"version":""},{"id":128,"title":"Gez","content":"#\n\n\nIntroduzione#\n\nGez è un framework per applicazioni web ad alte prestazioni basato su Rspack,\nche fornisce una gestione completa del ciclo di vita dell'applicazione, la\ngestione delle risorse statiche e le capacità di rendering lato server.\n\n\nDefinizioni di tipo#\n\n\nRuntimeTarget#\n\n * Definizione di tipo:\n\n\n\nTipi di ambiente di runtime dell'applicazione:\n\n * client: Eseguito nell'ambiente del browser, supporta operazioni DOM e API del\n   browser\n * server: Eseguito nell'ambiente Node.js, supporta funzionalità del file system\n   e del server\n\n\nImportMap#\n\n * Definizione di tipo:\n\n\n\nTipo di mappatura delle importazioni dei moduli ES.\n\nSpecifierMap#\n\n * Definizione di tipo:\n\n\n\nTipo di mappatura degli identificatori dei moduli, utilizzato per definire le\nrelazioni di mappatura dei percorsi di importazione dei moduli.\n\nScopesMap#\n\n * Definizione di tipo:\n\n\n\nTipo di mappatura degli ambiti, utilizzato per definire le relazioni di\nmappatura delle importazioni dei moduli in ambiti specifici.\n\n\nCOMMAND#\n\n * Definizione di tipo:\n\n\n\nEnumerazione dei tipi di comando:\n\n * dev: Comando per l'ambiente di sviluppo, avvia il server di sviluppo con\n   supporto per l'aggiornamento in tempo reale\n * build: Comando di build, genera gli artefatti di build per l'ambiente di\n   produzione\n * preview: Comando di anteprima, avvia un server di anteprima locale\n * start: Comando di avvio, esegue il server per l'ambiente di produzione\n\n\nOpzioni dell'istanza#\n\nDefinisce le opzioni di configurazione core del framework Gez.\n\n\n\nroot#\n\n * Tipo: string\n * Valore predefinito: process.cwd()\n\nPercorso della directory radice del progetto. Può essere un percorso assoluto o\nrelativo, i percorsi relativi vengono risolti rispetto alla directory di lavoro\ncorrente.\n\nisProd#\n\n * Tipo: boolean\n * Valore predefinito: process.env.NODE_ENV === 'production'\n\nIdentificatore dell'ambiente.\n\n * true: Ambiente di produzione\n * false: Ambiente di sviluppo\n\nbasePathPlaceholder#\n\n * Tipo: string | false\n * Valore predefinito: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nConfigurazione del segnaposto per il percorso base. Utilizzato per sostituire\ndinamicamente il percorso base delle risorse durante il runtime. Impostare su\nfalse per disabilitare questa funzionalità.\n\nmodules#\n\n * Tipo: ModuleConfig\n\nOpzioni di configurazione dei moduli. Utilizzato per configurare le regole di\nrisoluzione dei moduli del progetto, inclusi alias dei moduli, dipendenze\nesterne, ecc.\n\npacks#\n\n * Tipo: PackConfig\n\nOpzioni di configurazione del packaging. Utilizzato per impacchettare gli\nartefatti di build in pacchetti software .tgz standard npm.\n\ndevApp#\n\n * Tipo: (gez: Gez) => Promise\n\nFunzione di creazione dell'applicazione per l'ambiente di sviluppo. Utilizzato\nsolo nell'ambiente di sviluppo, per creare un'istanza dell'applicazione per il\nserver di sviluppo.\n\n\n\nserver#\n\n * Tipo: (gez: Gez) => Promise\n\nFunzione di configurazione dell'avvio del server. Utilizzato per configurare e\navviare il server HTTP, utilizzabile sia in ambiente di sviluppo che di\nproduzione.\n\n\n\npostBuild#\n\n * Tipo: (gez: Gez) => Promise\n\nFunzione di post-elaborazione della build. Eseguita dopo il completamento della\nbuild del progetto, può essere utilizzata per:\n\n * Eseguire ulteriori elaborazioni delle risorse\n * Operazioni di deployment\n * Generazione di file statici\n * Invio di notifiche di build\n\n\nProprietà dell'istanza#\n\n\nname#\n\n * Tipo: string\n * Sola lettura: true\n\nNome del modulo corrente, derivato dalla configurazione del modulo.\n\n\nvarName#\n\n * Tipo: string\n * Sola lettura: true\n\nNome di variabile JavaScript valido generato dal nome del modulo.\n\n\nroot#\n\n * Tipo: string\n * Sola lettura: true\n\nPercorso assoluto della directory radice del progetto. Se il root configurato è\nun percorso relativo, viene risolto rispetto alla directory di lavoro corrente.\n\n\nisProd#\n\n * Tipo: boolean\n * Sola lettura: true\n\nDetermina se l'ambiente corrente è di produzione. Utilizza in priorità l'opzione\nisProd dalla configurazione, se non configurato, determina in base a\nprocess.env.NODE_ENV.\n\n\nbasePath#\n\n * Tipo: string\n * Sola lettura: true\n * Eccezione: NotReadyError - Quando il framework non è inizializzato\n\nOttiene il percorso base del modulo con barre iniziali e finali. Il formato\nrestituito è /${name}/, dove name è derivato dalla configurazione del modulo.\n\n\nbasePathPlaceholder#\n\n * Tipo: string\n * Sola lettura: true\n\nOttiene il segnaposto per la sostituzione dinamica del percorso base durante il\nruntime. Può essere disabilitato tramite configurazione.\n\n\nmiddleware#\n\n * Tipo: Middleware\n * Sola lettura: true\n\nOttiene il middleware per la gestione delle risorse statiche. Fornisce\nimplementazioni diverse in base all'ambiente:\n\n * Ambiente di sviluppo: Supporta la compilazione in tempo reale del codice\n   sorgente e l'aggiornamento in tempo reale\n * Ambiente di produzione: Supporta la cache a lungo termine delle risorse\n   statiche\n\n\n\n\nrender#\n\n * Tipo: (options?: RenderContextOptions) => Promise\n * Sola lettura: true\n\nOttiene la funzione di rendering lato server. Fornisce implementazioni diverse\nin base all'ambiente:\n\n * Ambiente di sviluppo: Supporta l'aggiornamento in tempo reale e l'anteprima\n   in tempo reale\n * Ambiente di produzione: Fornisce prestazioni di rendering ottimizzate\n\n\n\n\nCOMMAND#\n\n * Tipo: typeof COMMAND\n * Sola lettura: true\n\nOttiene la definizione del tipo di enumerazione dei comandi.\n\n\nmoduleConfig#\n\n * Tipo: ParsedModuleConfig\n * Sola lettura: true\n * Eccezione: NotReadyError - Quando il framework non è inizializzato\n\nOttiene le informazioni complete di configurazione del modulo corrente, inclusa\nla risoluzione dei moduli, la configurazione degli alias, ecc.\n\n\npackConfig#\n\n * Tipo: ParsedPackConfig\n * Sola lettura: true\n * Eccezione: NotReadyError - Quando il framework non è inizializzato\n\nOttiene la configurazione relativa al packaging del modulo corrente, inclusi i\npercorsi di output, l'elaborazione di package.json, ecc.\n\n\nMetodi dell'istanza#\n\n\nconstructor()#\n\n * Parametri:\n   * options?: GezOptions - Opzioni di configurazione del framework\n * Valore restituito: Gez\n\nCrea un'istanza del framework Gez.\n\n\n\n\ninit()#\n\n * Parametri: command: COMMAND\n * Valore restituito: Promise\n * Eccezioni:\n   * Error: Quando si tenta di inizializzare più volte\n   * NotReadyError: Quando si accede a un'istanza non inizializzata\n\nInizializza l'istanza del framework Gez. Esegue i seguenti flussi di\ninizializzazione core:\n\n 1. Analisi della configurazione del progetto (package.json, configurazione del\n    modulo, configurazione del packaging, ecc.)\n 2. Creazione dell'istanza dell'applicazione (ambiente di sviluppo o produzione)\n 3. Esecuzione dei metodi del ciclo di vita in base al comando\n\nAttenzione\n * L'inizializzazione ripetuta genera un errore\n * L'accesso a un'istanza non inizializzata genera NotReadyError\n\n\n\n\ndestroy()#\n\n * Valore restituito: Promise\n\nDistrugge l'istanza del framework Gez, eseguendo operazioni di pulizia delle\nrisorse e chiusura delle connessioni. Utilizzato principalmente per:\n\n * Chiudere il server di sviluppo\n * Pulire file temporanei e cache\n * Rilasciare risorse di sistema\n\n\n\n\nbuild()#\n\n * Valore restituito: Promise\n\nEsegue il processo di build dell'applicazione, inclusa:\n\n * Compilazione del codice sorgente\n * Generazione degli artefatti di build per l'ambiente di produzione\n * Ottimizzazione e compressione del codice\n * Generazione del manifest delle risorse\n\nAttenzione\n\nLa chiamata su un'istanza del framework non inizializzata genera NotReadyError\n\n\n\n\nserver()#\n\n * Valore restituito: Promise\n * Eccezione: NotReadyError - Quando il framework non è inizializzato\n\nAvvia il server HTTP e configura l'istanza del server. Chiamato nei seguenti\ncicli di vita:\n\n * Ambiente di sviluppo (dev): Avvia il server di sviluppo, fornendo\n   aggiornamento in tempo reale\n * Ambiente di produzione (start): Avvia il server di produzione, fornendo\n   prestazioni di livello produzione\n\n\n\n\npostBuild()#\n\n * Valore restituito: Promise\n\nEsegue la logica di post-elaborazione della build, utilizzata per:\n\n * Generare file HTML statici\n * Elaborare gli artefatti di build\n * Eseguire operazioni di deployment\n * Inviare notifiche di build\n\n\n\n\nresolvePath#\n\nRisolve i percorsi del progetto, convertendo i percorsi relativi in percorsi\nassoluti.\n\n * Parametri:\n   \n   * projectPath: ProjectPath - Tipo di percorso del progetto\n   * ...args: string[] - Frammenti di percorso\n\n * Valore restituito: string - Percorso assoluto risolto\n\n * Esempio:\n\n\n\n\nwriteSync()#\n\nScrive in modo sincrono il contenuto di un file.\n\n * Parametri:\n   \n   * filepath: string - Percorso assoluto del file\n   * data: any - Dati da scrivere, possono essere stringhe, Buffer o oggetti\n\n * Valore restituito: boolean - Indica se la scrittura è avvenuta con successo\n\n * Esempio:\n\n\n\n\nreadJsonSync()#\n\nLegge e analizza in modo sincrono un file JSON.\n\n * Parametri:\n   \n   * filename: string - Percorso assoluto del file JSON\n\n * Valore restituito: any - Oggetto JSON analizzato\n\n * Eccezione: Generata quando il file non esiste o il formato JSON è errato\n\n * Esempio:\n\n\n\n\nreadJson()#\n\nLegge e analizza in modo asincrono un file JSON.\n\n * Parametri:\n   \n   * filename: string - Percorso assoluto del file JSON\n\n * Valore restituito: Promise - Oggetto JSON analizzato\n\n * Eccezione: Generata quando il file non esiste o il formato JSON è errato\n\n * Esempio:\n\n\n\n\ngetManifestList()#\n\nOttiene l'elenco dei manifest di build.\n\n * Parametri:\n   \n   * target: RuntimeTarget - Tipo di ambiente di destinazione\n     * 'client': Ambiente client\n     * 'server': Ambiente server\n\n * Valore restituito: Promise - Elenco di manifest di build in sola lettura\n\n * Eccezione: Generata quando l'istanza del framework non è inizializzata\n\nQuesto metodo è utilizzato per ottenere l'elenco dei manifest di build per\nl'ambiente di destinazione specificato, con le seguenti funzionalità:\n\n 1. Gestione della cache\n    * Utilizza un meccanismo di cache interno per evitare caricamenti ripetuti\n    * ","routePath":"/it/api/core/gez","lang":"it","toc":[{"text":"Introduzione","id":"introduzione","depth":2,"charIndex":3},{"text":"Definizioni di tipo","id":"definizioni-di-tipo","depth":2,"charIndex":245},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":268},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":550},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":642},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":827},{"text":"COMMAND","id":"command","depth":3,"charIndex":1001},{"text":"Opzioni dell'istanza","id":"opzioni-dellistanza","depth":2,"charIndex":1432},{"text":"root","id":"root","depth":4,"charIndex":1521},{"text":"isProd","id":"isprod","depth":4,"charIndex":1753},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1936},{"text":"modules","id":"modules","depth":4,"charIndex":2238},{"text":"packs","id":"packs","depth":4,"charIndex":2438},{"text":"devApp","id":"devapp","depth":4,"charIndex":2602},{"text":"server","id":"server","depth":4,"charIndex":2824},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":3031},{"text":"Proprietà dell'istanza","id":"proprietà-dellistanza","depth":2,"charIndex":3344},{"text":"name","id":"name","depth":3,"charIndex":3370},{"text":"varName","id":"varname","depth":3,"charIndex":3486},{"text":"root","id":"root-1","depth":3,"charIndex":3603},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3811},{"text":"basePath","id":"basepath","depth":3,"charIndex":4034},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":4310},{"text":"middleware","id":"middleware","depth":3,"charIndex":4510},{"text":"render","id":"render","depth":3,"charIndex":4896},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":5257},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":5377},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":5658},{"text":"Metodi dell'istanza","id":"metodi-dellistanza","depth":2,"charIndex":5928},{"text":"constructor()","id":"constructor","depth":3,"charIndex":5951},{"text":"init()","id":"init","depth":3,"charIndex":6115},{"text":"destroy()","id":"destroy","depth":3,"charIndex":6817},{"text":"build()","id":"build","depth":3,"charIndex":7112},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":8169},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":8473},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":8780},{"text":"readJson()","id":"readjson","depth":3,"charIndex":9067},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":9355}],"domain":"","frontmatter":{"titleSuffix":"Riferimento API delle classi core del framework","description":"Documentazione dettagliata delle API delle classi core del framework Gez, inclusa la gestione del ciclo di vita dell'applicazione, la gestione delle risorse statiche e le capacità di rendering lato server, per aiutare gli sviluppatori a comprendere a fondo le funzionalità core del framework.","head":[["meta",{"property":"keywords","content":"Gez, API, gestione ciclo di vita, risorse statiche, rendering lato server, Rspack, framework per applicazioni web"}]]},"version":""},{"id":129,"title":"ManifestJson","content":"#\n\nmanifest.json è un file di manifestazione generato durante il processo di build\ndel framework Gez, utilizzato per registrare le informazioni sugli artefatti di\nbuild del servizio. Fornisce un'interfaccia unificata per gestire gli artefatti\ndi build, i file esportati e le statistiche sulle dimensioni delle risorse.\n\n\n\n\nDefinizione dei tipi#\n\n\nManifestJson#\n\n\n\nname#\n\n * Tipo: string\n\nNome del servizio, derivato dalla configurazione GezOptions.name.\n\nexports#\n\n * Tipo: Record\n\nMapping dei file esportati, dove la chiave è il percorso del file sorgente e il\nvalore è il percorso del file dopo la build.\n\nbuildFiles#\n\n * Tipo: string[]\n\nElenco completo dei file degli artefatti di build, che include tutti i percorsi\ndei file generati.\n\nchunks#\n\n * Tipo: Record\n\nRelazione tra i file sorgente e gli artefatti compilati, dove la chiave è il\npercorso del file sorgente e il valore sono le informazioni di compilazione.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Tipo: string\n\nPercorso del file JS compilato per il file sorgente corrente.\n\ncss#\n\n * Tipo: string[]\n\nElenco dei percorsi dei file CSS associati al file sorgente corrente.\n\nresources#\n\n * Tipo: string[]\n\nElenco dei percorsi delle altre risorse associate al file sorgente corrente.\n\nsizes#\n\n * Tipo: ManifestJsonChunkSizes\n\nInformazioni sulle dimensioni degli artefatti di build.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Tipo: number\n\nDimensione del file JS (in byte).\n\ncss#\n\n * Tipo: number\n\nDimensione del file CSS (in byte).\n\nresource#\n\n * Tipo: number\n\nDimensione delle risorse (in byte).","routePath":"/it/api/core/manifest-json","lang":"it","toc":[{"text":"Definizione dei tipi","id":"definizione-dei-tipi","depth":2,"charIndex":322},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":363},{"text":"exports","id":"exports","depth":4,"charIndex":454},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":607},{"text":"chunks","id":"chunks","depth":4,"charIndex":739},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":921},{"text":"js","id":"js","depth":4,"charIndex":944},{"text":"css","id":"css","depth":4,"charIndex":1029},{"text":"resources","id":"resources","depth":4,"charIndex":1125},{"text":"sizes","id":"sizes","depth":4,"charIndex":1234},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1333},{"text":"js","id":"js-1","depth":4,"charIndex":1360},{"text":"css","id":"css-1","depth":4,"charIndex":1417},{"text":"resource","id":"resource","depth":4,"charIndex":1476}],"domain":"","frontmatter":{"titleSuffix":"Riferimento del file di manifestazione del framework Gez","description":"Descrizione dettagliata della struttura del file di manifestazione (manifest.json) del framework Gez, inclusa la gestione degli artefatti di build, il mapping dei file esportati e le funzionalità di statistica delle risorse, per aiutare gli sviluppatori a comprendere e utilizzare il sistema di build.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, Manifestazione di build, Gestione delle risorse, Artefatti di build, Mapping dei file, API"}]]},"version":""},{"id":130,"title":"ModuleConfig","content":"#\n\nModuleConfig fornisce la funzionalità di configurazione dei moduli per il\nframework Gez, utilizzata per definire le regole di importazione/esportazione\ndei moduli, la configurazione degli alias e le dipendenze esterne.\n\n\nDefinizione dei tipi#\n\n\nPathType#\n\n * Definizione del tipo:\n\n\n\nEnumerazione dei tipi di percorso dei moduli:\n\n * npm: indica le dipendenze presenti in node_modules\n * root: indica i file presenti nella directory radice del progetto\n\n\nModuleConfig#\n\n * Definizione del tipo:\n\n\n\nInterfaccia di configurazione dei moduli, utilizzata per definire\nl'esportazione, l'importazione e la configurazione delle dipendenze esterne del\nservizio.\n\nexports#\n\nLista di configurazione delle esportazioni, che espone unità di codice\nspecifiche (come componenti, funzioni di utilità, ecc.) dal servizio in formato\nESM.\n\nSupporta due tipi:\n\n * root:*: esporta i file sorgente, ad esempio: 'root:src/components/button.vue'\n * npm:*: esporta dipendenze di terze parti, ad esempio: 'npm:vue'\n\nimports#\n\nMappatura di configurazione delle importazioni, che configura i moduli remoti da\nimportare e i loro percorsi locali.\n\nLa configurazione varia in base al metodo di installazione:\n\n * Installazione da sorgente (Workspace, Git): deve puntare alla directory dist\n * Installazione da pacchetto (Link, server statico, repository privato, File):\n   punta direttamente alla directory del pacchetto\n\nexternals#\n\nMappatura delle dipendenze esterne, che configura le dipendenze esterne da\nutilizzare, solitamente provenienti da moduli remoti.\n\nEsempio:\n\n\n\n\nParsedModuleConfig#\n\n * Definizione del tipo:\n\n\n\nConfigurazione dei moduli analizzata, che converte la configurazione originale\ndei moduli in un formato interno standardizzato:\n\nname#\n\nNome del servizio corrente\n\n * Utilizzato per identificare il modulo e generare i percorsi di importazione\n\nroot#\n\nPercorso della directory radice del servizio corrente\n\n * Utilizzato per risolvere i percorsi relativi e la posizione degli artefatti\n   di build\n\nexports#\n\nLista di configurazione delle esportazioni\n\n * name: percorso di esportazione originale, ad esempio: 'npm:vue' o\n   'root:src/components'\n * type: tipo di percorso (npm o root)\n * importName: nome di importazione, formato: '${serviceName}/${type}/${path}'\n * exportName: percorso di esportazione, relativo alla directory radice del\n   servizio\n * exportPath: percorso effettivo del file\n * externalName: nome della dipendenza esterna, utilizzato come identificatore\n   quando altri servizi importano questo modulo\n\nimports#\n\nLista di configurazione delle importazioni\n\n * name: nome del servizio esterno\n * localPath: percorso di archiviazione locale, utilizzato per memorizzare gli\n   artefatti di build del modulo esterno\n\nexternals#\n\nMappatura delle dipendenze esterne\n\n * Mappa i percorsi di importazione del modulo alla posizione effettiva del\n   modulo\n * match: espressione regolare utilizzata per corrispondere alle istruzioni di\n   importazione\n * import: percorso effettivo del modulo","routePath":"/it/api/core/module-config","lang":"it","toc":[{"text":"Definizione dei tipi","id":"definizione-dei-tipi","depth":2,"charIndex":223},{"text":"PathType","id":"pathtype","depth":3,"charIndex":247},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":657},{"text":"imports","id":"imports","depth":4,"charIndex":993},{"text":"externals","id":"externals","depth":4,"charIndex":1394},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1549},{"text":"name","id":"name","depth":4,"charIndex":1727},{"text":"root","id":"root","depth":4,"charIndex":1842},{"text":"exports","id":"exports-1","depth":4,"charIndex":1996},{"text":"imports","id":"imports-1","depth":4,"charIndex":2521},{"text":"externals","id":"externals-1","depth":4,"charIndex":2731}],"domain":"","frontmatter":{"titleSuffix":"Riferimento API per la configurazione dei moduli del framework Gez","description":"Descrizione dettagliata dell'interfaccia di configurazione ModuleConfig del framework Gez, incluse le regole di importazione/esportazione dei moduli, la configurazione degli alias e la gestione delle dipendenze esterne, per aiutare gli sviluppatori a comprendere a fondo il sistema modulare del framework.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, configurazione moduli, importazione/esportazione moduli, dipendenze esterne, configurazione alias, gestione dipendenze, framework per applicazioni web"}]]},"version":""},{"id":131,"title":"PackConfig","content":"#\n\nPackConfig è un'interfaccia di configurazione per il packaging dei pacchetti,\nutilizzata per impacchettare gli artefatti di build di un servizio in un\npacchetto standard npm in formato .tgz.\n\n * Standardizzazione: Utilizza il formato di packaging .tgz standard di npm\n * Completezza: Include tutti i file necessari come il codice sorgente del\n   modulo, le dichiarazioni di tipo e i file di configurazione\n * Compatibilità: Completamente compatibile con l'ecosistema npm, supporta\n   flussi di lavoro standard di gestione dei pacchetti\n\n\nDefinizione del tipo#\n\n\n\n\nPackConfig#\n\nenable#\n\nAbilita o disabilita la funzionalità di packaging. Se abilitata, gli artefatti\ndi build verranno impacchettati in un pacchetto npm standard in formato .tgz.\n\n * Tipo: boolean\n * Valore predefinito: false\n\noutputs#\n\nSpecifica il percorso di output del file del pacchetto. Supporta le seguenti\nmodalità di configurazione:\n\n * string: Un singolo percorso di output, ad esempio 'dist/versions/my-app.tgz'\n * string[]: Più percorsi di output, per generare più versioni\n   contemporaneamente\n * boolean: Se true, utilizza il percorso predefinito\n   'dist/client/versions/latest.tgz'\n\npackageJson#\n\nFunzione di callback per personalizzare il contenuto di package.json. Viene\nchiamata prima del packaging per personalizzare il contenuto di package.json.\n\n * Parametri:\n   * gez: Gez - Istanza di Gez\n   * pkg: any - Contenuto originale di package.json\n * Valore restituito: Promise - Contenuto modificato di package.json\n\nUtilizzi comuni:\n\n * Modificare il nome e la versione del pacchetto\n * Aggiungere o aggiornare le dipendenze\n * Aggiungere campi personalizzati\n * Configurare informazioni relative alla pubblicazione\n\nEsempio:\n\n\n\nonBefore#\n\nFunzione di callback per le operazioni preliminari al packaging.\n\n * Parametri:\n   * gez: Gez - Istanza di Gez\n   * pkg: Record - Contenuto di package.json\n * Valore restituito: Promise\n\nUtilizzi comuni:\n\n * Aggiungere file aggiuntivi (README, LICENSE, ecc.)\n * Eseguire test o verifiche di build\n * Generare documentazione o metadati\n * Pulire file temporanei\n\nEsempio:\n\n\n\nonAfter#\n\nFunzione di callback per le operazioni successive al packaging. Viene chiamata\ndopo la generazione del file .tgz, per elaborare gli artefatti di packaging.\n\n * Parametri:\n   * gez: Gez - Istanza di Gez\n   * pkg: Record - Contenuto di package.json\n   * file: Buffer - Contenuto del file impacchettato\n * Valore restituito: Promise\n\nUtilizzi comuni:\n\n * Pubblicare su un repository npm (pubblico o privato)\n * Caricare su un server di risorse statiche\n * Gestire il controllo delle versioni\n * Attivare flussi CI/CD\n\nEsempio:\n\n\n\n\nEsempio di utilizzo#\n\n","routePath":"/it/api/core/pack-config","lang":"it","toc":[{"text":"Definizione del tipo","id":"definizione-del-tipo","depth":2,"charIndex":540},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":579},{"text":"outputs","id":"outputs","depth":4,"charIndex":793},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":1166},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1715},{"text":"onAfter","id":"onafter","depth":4,"charIndex":2100},{"text":"Esempio di utilizzo","id":"esempio-di-utilizzo","depth":2,"charIndex":2638}],"domain":"","frontmatter":{"titleSuffix":"Riferimento API per la configurazione del packaging del framework Gez","description":"Descrizione dettagliata dell'interfaccia di configurazione PackConfig del framework Gez, incluse le regole di packaging dei pacchetti, la configurazione dell'output e gli hook del ciclo di vita, per aiutare gli sviluppatori a implementare flussi di build standardizzati.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, packaging di pacchetti, configurazione di build, hook del ciclo di vita, configurazione del packaging, framework per applicazioni web"}]]},"version":""},{"id":132,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/it/api/core/render-context","lang":"it","toc":[{"text":"Definizioni di tipo","id":"definizioni-di-tipo","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Opzioni dell'istanza","id":"opzioni-dellistanza","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Proprietà dell'istanza","id":"proprietà-dellistanza","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Metodi dell'istanza","id":"metodi-dellistanza","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1},{"text":"importmap()","id":"importmap","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Riferimento API del contesto di rendering del framework Gez","description":"Descrizione dettagliata della classe principale RenderContext del framework Gez, inclusi il controllo del rendering, la gestione delle risorse, la sincronizzazione dello stato e il controllo del routing, per aiutare gli sviluppatori a implementare il rendering lato server in modo efficiente.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, rendering lato server, contesto di rendering, sincronizzazione dello stato, gestione delle risorse, framework per applicazioni web"}]]},"version":""},{"id":133,"title":"Dalla condivisione dei componenti alla modularità nativa: il percorso evolutivo del framework micro-frontend Gez","content":"Dalla condivisione dei componenti alla modularità nativa: il percorso evolutivo\ndel framework micro-frontend Gez#\n\n\nContesto del progetto#\n\nNegli ultimi anni, l'architettura micro-frontend ha cercato di trovare la strada\ngiusta. Tuttavia, abbiamo assistito a varie soluzioni tecniche complesse che,\nattraverso stratificazioni e isolamenti artificiali, cercano di simulare un\nmondo ideale di micro-frontend. Queste soluzioni hanno portato a un pesante\ncarico sulle prestazioni, rendendo lo sviluppo semplice complesso e i processi\nstandard oscuri.\n\n\nLimitazioni delle soluzioni tradizionali#\n\nNella pratica dell'architettura micro-frontend, abbiamo riscontrato numerose\nlimitazioni delle soluzioni tradizionali:\n\n * Perdita di prestazioni: l'iniezione delle dipendenze a runtime, il proxy\n   della sandbox JS, ogni operazione consuma preziose risorse di prestazioni\n * Isolamento fragile: l'ambiente sandbox creato artificialmente non può mai\n   raggiungere le capacità di isolamento nativo del browser\n * Complessità di build: per gestire le dipendenze, è necessario modificare gli\n   strumenti di build, rendendo i progetti semplici difficili da mantenere\n * Regole personalizzate: strategie di distribuzione speciali, elaborazione a\n   runtime, ogni passo si allontana dai processi standard di sviluppo moderno\n * Limitazioni dell'ecosistema: accoppiamento con il framework, API\n   personalizzate, costringendo la scelta tecnologica a legarsi a un ecosistema\n   specifico\n\nQuesti problemi sono emersi in modo particolarmente evidente in un progetto\naziendale del 2019. All'epoca, un grande prodotto è stato suddiviso in una\ndozzina di sottosistemi aziendali indipendenti, che dovevano condividere un set\ndi componenti di base e aziendali. La soluzione iniziale basata su pacchetti npm\nper la condivisione dei componenti ha rivelato gravi problemi di efficienza di\nmanutenzione: quando un componente condiviso veniva aggiornato, tutti i\nsottosistemi che dipendevano da quel componente dovevano passare attraverso un\nprocesso completo di build e distribuzione.\n\n\nEvoluzione tecnologica#\n\n\nv1.0: Esplorazione dei componenti remoti#\n\nPer risolvere i problemi di efficienza nella condivisione dei componenti, Gez\nv1.0 ha introdotto un meccanismo di componenti RemoteView basato sul protocollo\nHTTP. Questa soluzione ha implementato l'assemblaggio dinamico del codice tra\nservizi attraverso richieste runtime, risolvendo con successo il problema delle\nlunghe catene di dipendenze di build. Tuttavia, a causa della mancanza di un\nmeccanismo standardizzato di comunicazione runtime, la sincronizzazione dello\nstato e il passaggio di eventi tra servizi rimanevano un collo di bottiglia.\n\n\nv2.0: Tentativo di Module Federation#\n\nNella versione v2.0, abbiamo adottato la tecnologia Module Federation di Webpack\n5.0. Questa tecnologia, attraverso un meccanismo unificato di caricamento dei\nmoduli e un contenitore runtime, ha migliorato significativamente l'efficienza\ndella collaborazione tra servizi. Tuttavia, nella pratica su larga scala, il\nmeccanismo chiuso di implementazione di Module Federation ha portato nuove\nsfide: difficoltà nella gestione precisa delle versioni delle dipendenze,\nspecialmente nell'unificazione delle dipendenze condivise tra più servizi,\nspesso si verificavano conflitti di versione e anomalie runtime.\n\n\nAbbracciare la nuova era di ESM#\n\nNella pianificazione della versione v3.0, abbiamo osservato attentamente le\ntendenze di sviluppo dell'ecosistema frontend, scoprendo che i progressi nelle\ncapacità native del browser hanno portato nuove possibilità all'architettura\nmicro-frontend:\n\n\nSistema di moduli standardizzato#\n\nCon il supporto completo dei principali browser per ES Modules e la maturazione\ndella specifica Import Maps, lo sviluppo frontend è entrato in una vera era di\nmodularità. Secondo le statistiche di Can I Use, il supporto nativo per ESM nei\nprincipali browser (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) ha\nraggiunto il 93.5%, offrendoci i seguenti vantaggi:\n\n * Gestione delle dipendenze standardizzata: Import Maps fornisce la capacità di\n   risolvere le dipendenze dei moduli a livello di browser, senza bisogno di\n   complesse iniezioni runtime\n * Ottimizzazione del caricamento delle risorse: il meccanismo di cache nativo\n   dei moduli del browser migliora significativamente l'efficienza del\n   caricamento delle risorse\n * Semplificazione del processo di build: il modello di sviluppo basato su ESM\n   rende i processi di build per l'ambiente di sviluppo e produzione più\n   coerenti\n\nInoltre, attraverso il supporto della modalità di compatibilità (Chrome >= 87,\nEdge >= 88, Firefox >= 78, Safari >= 14), possiamo aumentare ulteriormente la\ncopertura del browser al 96.81%, permettendoci di mantenere alte prestazioni\nsenza sacrificare il supporto per i browser più vecchi.\n\n\nProgressi nelle prestazioni e nell'isolamento#\n\nIl sistema di moduli nativo porta non solo standardizzazione, ma anche un\nmiglioramento qualitativo nelle prestazioni e nell'isolamento:\n\n * Zero overhead runtime: addio ai proxy sandbox JavaScript e alle iniezioni\n   runtime delle soluzioni micro-frontend tradizionali\n * Meccanismo di isolamento affidabile: il rigoroso ambito dei moduli ESM\n   fornisce naturalmente la capacità di isolamento più affidabile\n * Gestione precisa delle dipendenze: l'analisi statica delle importazioni rende\n   le relazioni di dipendenza più chiare e il controllo delle versioni più\n   preciso\n\n\nScelta degli strumenti di build#\n\nNell'implementazione della soluzione tecnologica, la scelta degli strumenti di\nbuild è stata un punto decisionale cruciale. Dopo quasi un anno di ricerca e\npratica, la nostra scelta ha attraversato la seguente evoluzione:\n\n 1. Esplorazione di Vite\n    \n    * Vantaggi: server di sviluppo basato su ESM, offre un'esperienza di\n      sviluppo estrema\n    * Sfide: le differenze di build tra ambiente di sviluppo e produzione\n      portano a una certa incertezza\n\n 2. Conferma di Rspack\n    \n    * Vantaggi prestazionali: compilazione ad alte prestazioni basata su Rust,\n      migliora significativamente la velocità di build\n    * Supporto dell'ecosistema: alta compatibilità con l'ecosistema Webpack,\n      riduce i costi di migrazione\n    * Supporto ESM: attraverso la pratica del progetto Rslib, ha verificato\n      l'affidabilità nella build ESM\n\nQuesta decisione ci ha permesso di mantenere un'esperienza di sviluppo\neccellente, ottenendo al contempo un supporto più stabile per l'ambiente di\nproduzione. Basandoci sulla combinazione di ESM e Rspack, abbiamo finalmente\ncostruito una soluzione micro-frontend ad alte prestazioni e a bassa invasività.\n\n\nProspettive future#\n\nNel piano di sviluppo futuro, il framework Gez si concentrerà su tre direzioni\nprincipali:\n\n\nOttimizzazione approfondita di Import Maps#\n\n * Gestione dinamica delle dipendenze: implementazione di uno scheduling\n   intelligente delle versioni delle dipendenze a runtime, risolvendo i\n   conflitti di dipendenza tra più applicazioni\n * Strategie di pre-caricamento: pre-caricamento intelligente basato\n   sull'analisi delle route, migliorando l'efficienza del caricamento delle\n   risorse\n * Ottimizzazione della build: generazione automatica della configurazione\n   Import Maps ottimale, riducendo i costi di configurazione manuale per gli\n   sviluppatori\n\n\nSoluzione di routing indipendente dal framework#\n\n * Astrazione unificata del routing: progettazione di un'interfaccia di routing\n   indipendente dal framework, supportando framework principali come Vue, React\n * Routing delle micro-applicazioni: implementazione del collegamento delle\n   route tra applicazioni, mantenendo la coerenza tra URL e stato\n   dell'applicazione\n * Middleware di routing: fornitura di un meccanismo di middleware estensibile,\n   supportando il controllo degli accessi, le transizioni di pagina, ecc.\n\n\nMigliori pratiche per la comunicazione tra framework#\n\n * Applicazione di esempio: fornitura di un esempio completo di comunicazione\n   tra framework, coprendo framework principali come Vue, React, Preact\n * Sincronizzazione dello stato: soluzione di condivisione dello stato leggera\n   basata su ESM\n * Event bus: meccanismo standardizzato di comunicazione degli eventi,\n   supportando la comunicazione disaccoppiata tra applicazioni\n\nAttraverso queste ottimizzazioni ed estensioni, ci aspettiamo che Gez diventi\nuna soluzione micro-frontend più completa e facile da usare, offrendo agli\nsviluppatori una migliore esperienza di sviluppo e una maggiore efficienza.","routePath":"/it/blog/birth-of-gez","lang":"it","toc":[{"text":"Contesto del progetto","id":"contesto-del-progetto","depth":2,"charIndex":115},{"text":"Limitazioni delle soluzioni tradizionali","id":"limitazioni-delle-soluzioni-tradizionali","depth":3,"charIndex":548},{"text":"Evoluzione tecnologica","id":"evoluzione-tecnologica","depth":2,"charIndex":2062},{"text":"v1.0: Esplorazione dei componenti remoti","id":"v10-esplorazione-dei-componenti-remoti","depth":3,"charIndex":2088},{"text":"v2.0: Tentativo di Module Federation","id":"v20-tentativo-di-module-federation","depth":3,"charIndex":2681},{"text":"Abbracciare la nuova era di ESM","id":"abbracciare-la-nuova-era-di-esm","depth":2,"charIndex":3326},{"text":"Sistema di moduli standardizzato","id":"sistema-di-moduli-standardizzato","depth":3,"charIndex":3610},{"text":"Progressi nelle prestazioni e nell'isolamento","id":"progressi-nelle-prestazioni-e-nellisolamento","depth":3,"charIndex":4843},{"text":"Scelta degli strumenti di build","id":"scelta-degli-strumenti-di-build","depth":3,"charIndex":5470},{"text":"Prospettive future","id":"prospettive-future","depth":2,"charIndex":6660},{"text":"Ottimizzazione approfondita di Import Maps","id":"ottimizzazione-approfondita-di-import-maps","depth":3,"charIndex":6774},{"text":"Soluzione di routing indipendente dal framework","id":"soluzione-di-routing-indipendente-dal-framework","depth":3,"charIndex":7338},{"text":"Migliori pratiche per la comunicazione tra framework","id":"migliori-pratiche-per-la-comunicazione-tra-framework","depth":3,"charIndex":7867}],"domain":"","frontmatter":{"titleSuffix":"Dalle difficoltà del micro-frontend all'innovazione ESM: il percorso evolutivo del framework Gez","description":"Approfondisci il percorso evolutivo del framework Gez, dalle difficoltà dell'architettura micro-frontend tradizionale alle innovazioni basate su ESM, condividendo esperienze pratiche su ottimizzazione delle prestazioni, gestione delle dipendenze e scelta degli strumenti di build.","head":[["meta",{"property":"keywords","content":"Gez, framework micro-frontend, ESM, Import Maps, Rspack, Module Federation, gestione delle dipendenze, ottimizzazione delle prestazioni, evoluzione tecnologica, rendering lato server"}]],"sidebar":false},"version":""},{"id":134,"title":"Blog del team","content":"#\n\nBenvenuti nel blog tecnico del team Gez! Qui condividiamo esperienze,\ninnovazioni tecnologiche e best practice relative allo sviluppo di framework.\n\n\nArticoli recenti#\n\n * 2025-02-25 Dalla condivisione di componenti alla modularità nativa: il\n   percorso evolutivo del framework Gez per micro-frontend\n   \n   > Esplora il percorso evolutivo del framework Gez, dalla condivisione\n   > tradizionale di componenti alla modularità nativa basata su ESM.\n   > Condividiamo esperienze pratiche su ottimizzazione delle prestazioni,\n   > gestione delle dipendenze e scelta degli strumenti di build.","routePath":"/it/blog/","lang":"it","toc":[{"text":"Articoli recenti","id":"articoli-recenti","depth":2,"charIndex":152}],"domain":"","frontmatter":{"titleSuffix":"Blog del team Gez","description":"Blog tecnico del team Gez, condivisione di esperienze di sviluppo di framework, best practice e innovazioni tecnologiche.","head":[["meta",{"property":"keywords","content":"Gez, blog del team, condivisione tecnica, best practice, esperienze di sviluppo"}]],"sidebar":false},"version":""},{"id":135,"title":"Alias di percorso","content":"#\n\nL'alias di percorso (Path Alias) è un meccanismo di mappatura dei percorsi di\nimportazione dei moduli che consente agli sviluppatori di utilizzare\nidentificatori brevi e semantici al posto dei percorsi completi dei moduli. In\nGez, il meccanismo degli alias di percorso offre i seguenti vantaggi:\n\n * Semplificazione dei percorsi di importazione: Utilizza alias semantici al\n   posto di percorsi relativi lunghi, migliorando la leggibilità del codice\n * Evitare annidamenti profondi: Elimina le difficoltà di manutenzione causate\n   da riferimenti a directory multilivello (ad esempio ../../../../)\n * Sicurezza dei tipi: Integrazione completa con il sistema di tipi di\n   TypeScript, fornendo completamento del codice e controllo dei tipi\n * Ottimizzazione della risoluzione dei moduli: Migliora le prestazioni di\n   risoluzione dei moduli attraverso mappature predefinite dei percorsi\n\n\nMeccanismo degli alias predefiniti#\n\nGez utilizza un meccanismo automatico di alias basato sul nome del servizio\n(Service Name), un design che privilegia le convenzioni rispetto alla\nconfigurazione, con le seguenti caratteristiche:\n\n * Configurazione automatica: Genera automaticamente alias basati sul campo name\n   in package.json, senza necessità di configurazione manuale\n * Uniformità delle convenzioni: Garantisce che tutti i moduli del servizio\n   seguano una nomenclatura e un riferimento coerenti\n * Supporto dei tipi: In combinazione con il comando npm run build:dts, genera\n   automaticamente file di dichiarazione dei tipi, consentendo la deduzione dei\n   tipi tra servizi\n * Prevedibilità: Consente di dedurre il percorso di riferimento del modulo dal\n   nome del servizio, riducendo i costi di manutenzione\n\n\nConfigurazione#\n\n\nConfigurazione di package.json#\n\nIn package.json, il nome del servizio viene definito tramite il campo name, che\nfungerà da prefisso predefinito per l'alias del servizio:\n\n\n\n\nConfigurazione di tsconfig.json#\n\nAffinché TypeScript possa risolvere correttamente i percorsi degli alias, è\nnecessario configurare la mappatura paths in tsconfig.json:\n\n\n\n\nEsempi di utilizzo#\n\n\nImportazione di moduli interni al servizio#\n\n\n\n\nImportazione di moduli da altri servizi#\n\n\n\nBest practice\n * Preferire l'uso di percorsi con alias rispetto ai percorsi relativi\n * Mantenere i percorsi con alias semantici e coerenti\n * Evitare l'uso di troppi livelli di directory nei percorsi con alias\n\n\n\n\nImportazione tra servizi#\n\nDopo aver configurato il collegamento dei moduli (Module Link), è possibile\nimportare moduli da altri servizi nello stesso modo:\n\n\n\n\nAlias personalizzati#\n\nPer pacchetti di terze parti o scenari speciali, è possibile definire alias\npersonalizzati tramite il file di configurazione di Gez:\n\n\n\nAvvertenze\n 1. Per i moduli di business, si consiglia di utilizzare sempre il meccanismo\n    degli alias predefiniti per mantenere la coerenza del progetto\n 2. Gli alias personalizzati sono principalmente utilizzati per gestire esigenze\n    speciali di pacchetti di terze parti o per ottimizzare l'esperienza di\n    sviluppo\n 3. L'uso eccessivo di alias personalizzati potrebbe compromettere la\n    manutenibilità del codice e l'ottimizzazione della build","routePath":"/it/guide/essentials/alias","lang":"it","toc":[{"text":"Meccanismo degli alias predefiniti","id":"meccanismo-degli-alias-predefiniti","depth":2,"charIndex":890},{"text":"Configurazione","id":"configurazione","depth":2,"charIndex":1713},{"text":"Configurazione di package.json","id":"configurazione-di-packagejson","depth":3,"charIndex":1731},{"text":"Configurazione di tsconfig.json","id":"configurazione-di-tsconfigjson","depth":3,"charIndex":1906},{"text":"Esempi di utilizzo","id":"esempi-di-utilizzo","depth":2,"charIndex":2080},{"text":"Importazione di moduli interni al servizio","id":"importazione-di-moduli-interni-al-servizio","depth":3,"charIndex":2102},{"text":"Importazione di moduli da altri servizi","id":"importazione-di-moduli-da-altri-servizi","depth":3,"charIndex":2150},{"text":"Importazione tra servizi","id":"importazione-tra-servizi","depth":3,"charIndex":2409},{"text":"Alias personalizzati","id":"alias-personalizzati","depth":3,"charIndex":2569}],"domain":"","frontmatter":{"titleSuffix":"Guida alla mappatura dei percorsi di importazione dei moduli del framework Gez","description":"Descrizione dettagliata del meccanismo degli alias di percorso nel framework Gez, inclusi la semplificazione dei percorsi di importazione, l'evitare annidamenti profondi, la sicurezza dei tipi e l'ottimizzazione della risoluzione dei moduli, per aiutare gli sviluppatori a migliorare la manutenibilità del codice.","head":[["meta",{"property":"keywords","content":"Gez, Alias di percorso, Path Alias, TypeScript, Importazione di moduli, Mappatura dei percorsi, Manutenibilità del codice"}]]},"version":""},{"id":136,"title":"Percorso di base","content":"#\n\nIl percorso di base (Base Path) è il prefisso del percorso di accesso alle\nrisorse statiche (come JavaScript, CSS, immagini, ecc.) all'interno di\nun'applicazione. In Gez, una configurazione appropriata del percorso di base è\nfondamentale per i seguenti scenari:\n\n * Distribuzione multi-ambiente: supporta l'accesso alle risorse in diversi\n   ambienti come sviluppo, test e produzione\n * Distribuzione multi-regione: adatta le esigenze di distribuzione in cluster\n   in diverse regioni o paesi\n * Distribuzione CDN: consente la distribuzione e l'accelerazione globale delle\n   risorse statiche\n\n\nMeccanismo del percorso predefinito#\n\nGez utilizza un meccanismo di generazione automatica del percorso basato sul\nnome del servizio. Per impostazione predefinita, il framework legge il campo\nname nel file package.json del progetto per generare il percorso di base delle\nrisorse statiche: /your-app-name/.\n\n\n\nQuesto design basato su convenzioni piuttosto che su configurazioni offre i\nseguenti vantaggi:\n\n * Coerenza: garantisce che tutte le risorse statiche utilizzino un percorso di\n   accesso uniforme\n * Prevedibilità: il percorso di accesso alle risorse può essere dedotto dal\n   campo name nel package.json\n * Manutenibilità: non richiede configurazioni aggiuntive, riducendo i costi di\n   manutenzione\n\n\nConfigurazione dinamica del percorso#\n\nNei progetti reali, spesso è necessario distribuire lo stesso codice in ambienti\no regioni diversi. Gez supporta la configurazione dinamica del percorso di base,\nconsentendo all'applicazione di adattarsi a diversi scenari di distribuzione.\n\n\nCasi d'uso#\n\nDistribuzione in sottodirectory#\n\n\n\nDistribuzione con domini indipendenti#\n\n\n\n\nMetodo di configurazione#\n\nAttraverso il parametro base del metodo gez.render(), è possibile impostare\ndinamicamente il percorso di base in base al contesto della richiesta:\n\n","routePath":"/it/guide/essentials/base-path","lang":"it","toc":[{"text":"Meccanismo del percorso predefinito","id":"meccanismo-del-percorso-predefinito","depth":2,"charIndex":597},{"text":"Configurazione dinamica del percorso","id":"configurazione-dinamica-del-percorso","depth":2,"charIndex":1308},{"text":"Casi d'uso","id":"casi-duso","depth":3,"charIndex":1589},{"text":"Distribuzione in sottodirectory","id":"distribuzione-in-sottodirectory","depth":4,"charIndex":1602},{"text":"Distribuzione con domini indipendenti","id":"distribuzione-con-domini-indipendenti","depth":4,"charIndex":1638},{"text":"Metodo di configurazione","id":"metodo-di-configurazione","depth":3,"charIndex":1681}],"domain":"","frontmatter":{"titleSuffix":"Guida alla configurazione del percorso delle risorse statiche nel framework Gez","description":"Descrizione dettagliata della configurazione del percorso di base nel framework Gez, inclusa la distribuzione in più ambienti, la distribuzione CDN e l'impostazione del percorso di accesso alle risorse, per aiutare gli sviluppatori a gestire in modo flessibile le risorse statiche.","head":[["meta",{"property":"keywords","content":"Gez, Percorso di base, Base Path, CDN, Risorse statiche, Distribuzione multi-ambiente, Gestione delle risorse"}]]},"version":""},{"id":137,"title":"Rendering lato client","content":"\n${rc.importmap()} // Mappa delle importazioni ${rc.moduleEntry()} // Modulo di\ningresso ${rc.modulePreload()} // Precarga dei moduli","routePath":"/it/guide/essentials/csr","lang":"it","toc":[{"text":"Casi d'uso","id":"casi-duso","depth":2,"charIndex":-1},{"text":"Configurazione","id":"configurazione","depth":2,"charIndex":-1},{"text":"Configurazione del template HTML","id":"configurazione-del-template-html","depth":3,"charIndex":-1},{"text":"Generazione di HTML statico","id":"generazione-di-html-statico","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Guida all'implementazione del rendering lato client con il framework Gez","description":"Una guida dettagliata sul meccanismo di rendering lato client del framework Gez, inclusa la costruzione statica, le strategie di distribuzione e le migliori pratiche, per aiutare gli sviluppatori a implementare un rendering front-end efficiente in ambienti senza server.","head":[["meta",{"property":"keywords","content":"Gez, Rendering lato client, CSR, Costruzione statica, Rendering front-end, Distribuzione senza server, Ottimizzazione delle prestazioni"}]]},"version":""},{"id":138,"title":"Collegamento moduli","content":"#\n\nIl framework Gez fornisce un meccanismo completo di collegamento moduli per\ngestire la condivisione del codice e le relazioni di dipendenza tra i servizi.\nQuesto meccanismo è implementato sulla base della specifica ESM (ECMAScript\nModule) e supporta l'esportazione e l'importazione di moduli a livello di codice\nsorgente, oltre a una completa gestione delle dipendenze.\n\n\nConcetti chiave#\n\nEsportazione moduli#\n\nL'esportazione di moduli è il processo di esporre unità di codice specifiche\n(come componenti, funzioni di utilità, ecc.) da un servizio in formato ESM. Sono\nsupportati due tipi di esportazione:\n\n * Esportazione codice sorgente: esportazione diretta dei file di codice\n   sorgente del progetto\n * Esportazione dipendenze: esportazione dei pacchetti di dipendenze di terze\n   parti utilizzati dal progetto\n\nImportazione moduli#\n\nL'importazione di moduli è il processo di riferimento a unità di codice\nesportate da altri servizi all'interno di un servizio. Sono supportati diversi\nmetodi di installazione:\n\n * Installazione codice sorgente: adatta per ambienti di sviluppo, supporta\n   modifiche in tempo reale e aggiornamento a caldo\n * Installazione pacchetto: adatta per ambienti di produzione, utilizza\n   direttamente i prodotti di build\n\n\nMeccanismo di precaricamento#\n\nPer ottimizzare le prestazioni dei servizi, Gez implementa un meccanismo\nintelligente di precaricamento moduli:\n\n 1. Analisi dipendenze\n    \n    * Analisi delle relazioni di dipendenza tra i componenti durante la build\n    * Identificazione dei moduli core sul percorso critico\n    * Determinazione della priorità di caricamento dei moduli\n\n 2. Strategia di caricamento\n    \n    * Caricamento immediato: moduli core sul percorso critico\n    * Caricamento differito: moduli di funzionalità non critiche\n    * Caricamento su richiesta: moduli con rendering condizionale\n\n 3. Ottimizzazione risorse\n    \n    * Strategia intelligente di suddivisione del codice\n    * Gestione della cache a livello di modulo\n    * Compilazione e bundling su richiesta\n\n\nEsportazione moduli#\n\n\nConfigurazione#\n\nConfigurare i moduli da esportare in entry.node.ts:\n\n\n\nLa configurazione di esportazione supporta due tipi:\n\n * root:*: esportazione file sorgente, percorso relativo alla root del progetto\n * npm:*: esportazione dipendenze di terze parti, specificando direttamente il\n   nome del pacchetto\n\n\nImportazione moduli#\n\n\nConfigurazione#\n\nConfigurare i moduli da importare in entry.node.ts:\n\n\n\nDescrizione delle opzioni di configurazione:\n\n 1. imports: configura il percorso locale dei moduli remoti\n    \n    * Installazione codice sorgente: punta alla directory dei prodotti di build\n      (dist)\n    * Installazione pacchetto: punta direttamente alla directory del pacchetto\n\n 2. externals: configura le dipendenze esterne\n    \n    * Utilizzato per condividere le dipendenze dai moduli remoti\n    * Evita il rebundling delle stesse dipendenze\n    * Supporta la condivisione di dipendenze tra più moduli\n\n\nMetodi di installazione#\n\nInstallazione codice sorgente#\n\nAdatta per ambienti di sviluppo, supporta modifiche in tempo reale e\naggiornamento a caldo.\n\n 1. Modalità Workspace Consigliata per progetti Monorepo:\n\n\n\n 2. Modalità Link Utilizzata per il debug locale:\n\n\n\nInstallazione pacchetto#\n\nAdatta per ambienti di produzione, utilizza direttamente i prodotti di build.\n\n 1. NPM Registry Installazione tramite npm registry:\n\n\n\n 2. Server statico Installazione tramite protocollo HTTP/HTTPS:\n\n\n\n\nCostruzione pacchetti#\n\n\nConfigurazione#\n\nConfigurare le opzioni di build in entry.node.ts:\n\n\n\n\nProdotti della build#\n\n\n\n\nProcesso di pubblicazione#\n\n\n\n\nBest practice#\n\n\nConfigurazione ambiente di sviluppo#\n\n * Gestione dipendenze\n   \n   * Utilizzare la modalità Workspace o Link per installare le dipendenze\n   * Gestione centralizzata delle versioni delle dipendenze\n   * Evitare l'installazione duplicata delle stesse dipendenze\n\n * Esperienza di sviluppo\n   \n   * Abilitare la funzionalità di aggiornamento a caldo\n   * Configurare una strategia di precaricamento adeguata\n   * Ottimizzare la velocità di build\n\n\nConfigurazione ambiente di produzione#\n\n * Strategia di deploy\n   \n   * Utilizzare NPM Registry o server statici\n   * Garantire l'integrità dei prodotti di build\n   * Implementare meccanismi di rilascio graduale\n\n * Ottimizzazione prestazioni\n   \n   * Configurare correttamente il precaricamento delle risorse\n   * Ottimizzare l'ordine di caricamento dei moduli\n   * Implementare strategie di caching efficaci\n\n\nGestione versioni#\n\n * Standard versioni\n   \n   * Seguire le specifiche di versionamento semantico\n   * Mantenere un changelog dettagliato\n   * Eseguire test di compatibilità delle versioni\n\n * Aggiornamento dipendenze\n   \n   * Aggiornare tempestivamente i pacchetti di dipendenza\n   * Eseguire audit di sicurezza periodici\n   * Mantenere la coerenza delle versioni delle dipendenze\n\n","routePath":"/it/guide/essentials/module-link","lang":"it","toc":[{"text":"Concetti chiave","id":"concetti-chiave","depth":3,"charIndex":374},{"text":"Esportazione moduli","id":"esportazione-moduli","depth":4,"charIndex":392},{"text":"Importazione moduli","id":"importazione-moduli","depth":4,"charIndex":820},{"text":"Meccanismo di precaricamento","id":"meccanismo-di-precaricamento","depth":3,"charIndex":1257},{"text":"Esportazione moduli","id":"esportazione-moduli-1","depth":2,"charIndex":2037},{"text":"Configurazione","id":"configurazione","depth":3,"charIndex":2060},{"text":"Importazione moduli","id":"importazione-moduli-1","depth":2,"charIndex":2369},{"text":"Configurazione","id":"configurazione-1","depth":3,"charIndex":2392},{"text":"Metodi di installazione","id":"metodi-di-installazione","depth":3,"charIndex":2977},{"text":"Installazione codice sorgente","id":"installazione-codice-sorgente","depth":4,"charIndex":3003},{"text":"Installazione pacchetto","id":"installazione-pacchetto","depth":4,"charIndex":3242},{"text":"Costruzione pacchetti","id":"costruzione-pacchetti","depth":2,"charIndex":3471},{"text":"Configurazione","id":"configurazione-2","depth":3,"charIndex":3496},{"text":"Prodotti della build","id":"prodotti-della-build","depth":3,"charIndex":3567},{"text":"Processo di pubblicazione","id":"processo-di-pubblicazione","depth":3,"charIndex":3593},{"text":"Best practice","id":"best-practice","depth":2,"charIndex":3624},{"text":"Configurazione ambiente di sviluppo","id":"configurazione-ambiente-di-sviluppo","depth":3,"charIndex":3641},{"text":"Configurazione ambiente di produzione","id":"configurazione-ambiente-di-produzione","depth":3,"charIndex":4088},{"text":"Gestione versioni","id":"gestione-versioni","depth":3,"charIndex":4500}],"domain":"","frontmatter":{"titleSuffix":"Meccanismo di condivisione del codice tra servizi nel framework Gez","description":"Descrizione dettagliata del meccanismo di collegamento dei moduli nel framework Gez, inclusa la condivisione del codice tra servizi, la gestione delle dipendenze e l'implementazione della specifica ESM, per aiutare gli sviluppatori a costruire applicazioni microfrontend efficienti.","head":[["meta",{"property":"keywords","content":"Gez, Collegamento moduli, Module Link, ESM, Condivisione codice, Gestione dipendenze, Microfrontend"}]]},"version":""},{"id":139,"title":"Contesto di Rendering","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/it/guide/essentials/render-context","lang":"it","toc":[{"text":"Modalità di utilizzo","id":"modalità-di-utilizzo","depth":2,"charIndex":-1},{"text":"Funzionalità principali","id":"funzionalità-principali","depth":2,"charIndex":-1},{"text":"Raccolta delle dipendenze","id":"raccolta-delle-dipendenze","depth":3,"charIndex":-1},{"text":"Raccolta su richiesta","id":"raccolta-su-richiesta","depth":4,"charIndex":-1},{"text":"Gestione automatica","id":"gestione-automatica","depth":4,"charIndex":-1},{"text":"Ottimizzazione delle prestazioni","id":"ottimizzazione-delle-prestazioni","depth":4,"charIndex":-1},{"text":"Iniezione delle risorse","id":"iniezione-delle-risorse","depth":3,"charIndex":-1},{"text":"Ordine di iniezione delle risorse","id":"ordine-di-iniezione-delle-risorse","depth":3,"charIndex":-1},{"text":"Flusso di rendering completo","id":"flusso-di-rendering-completo","depth":2,"charIndex":-1},{"text":"Funzionalità avanzate","id":"funzionalità-avanzate","depth":2,"charIndex":-1},{"text":"Configurazione del percorso di base","id":"configurazione-del-percorso-di-base","depth":3,"charIndex":-1},{"text":"Modalità di mappatura delle importazioni","id":"modalità-di-mappatura-delle-importazioni","depth":3,"charIndex":-1},{"text":"Configurazione della funzione di ingresso","id":"configurazione-della-funzione-di-ingresso","depth":3,"charIndex":-1},{"text":"Best practice","id":"best-practice","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Meccanismo di rendering lato server del framework Gez","description":"Descrizione dettagliata del meccanismo del contesto di rendering (RenderContext) del framework Gez, inclusa la gestione delle risorse, la generazione di HTML e il sistema di moduli ESM, per aiutare gli sviluppatori a comprendere e utilizzare le funzionalità di rendering lato server.","head":[["meta",{"property":"keywords","content":"Gez, contesto di rendering, RenderContext, SSR, rendering lato server, ESM, gestione delle risorse"}]]},"version":""},{"id":140,"title":"Rspack","content":"#\n\nGez è basato sul sistema di costruzione Rspack, sfruttando appieno le capacità\ndi costruzione ad alte prestazioni di Rspack. Questo documento illustra il ruolo\ne le funzionalità principali di Rspack all'interno del framework Gez.\n\n\nCaratteristiche#\n\nRspack è il sistema di costruzione principale del framework Gez e offre le\nseguenti caratteristiche chiave:\n\n * Costruzione ad alte prestazioni: Motore di costruzione implementato in Rust,\n   che fornisce una velocità di compilazione estremamente rapida, migliorando\n   significativamente la velocità di costruzione di progetti di grandi\n   dimensioni.\n * Ottimizzazione dell'esperienza di sviluppo: Supporta funzionalità di sviluppo\n   moderne come l'aggiornamento a caldo (HMR) e la compilazione incrementale,\n   offrendo un'esperienza di sviluppo fluida.\n * Costruzione multi-ambiente: Configurazione di costruzione unificata che\n   supporta ambienti client, server e Node.js, semplificando il flusso di\n   sviluppo multi-piattaforma.\n * Ottimizzazione delle risorse: Capacità integrate di elaborazione e\n   ottimizzazione delle risorse, supportando funzionalità come la suddivisione\n   del codice, Tree Shaking e la compressione delle risorse.\n\n\nCostruzione dell'applicazione#\n\nIl sistema di costruzione Rspack di Gez è progettato in modo modulare e include\nprincipalmente i seguenti moduli principali:\n\n\n@gez/rspack#\n\nModulo di costruzione di base, che fornisce le seguenti capacità principali:\n\n * Configurazione di costruzione unificata: Fornisce una gestione standardizzata\n   della configurazione di costruzione, supportando configurazioni\n   multi-ambiente.\n * Elaborazione delle risorse: Capacità integrate di elaborazione di risorse\n   come TypeScript, CSS e immagini.\n * Ottimizzazione della costruzione: Fornisce funzionalità di ottimizzazione\n   delle prestazioni come la suddivisione del codice e Tree Shaking.\n * Server di sviluppo: Integra un server di sviluppo ad alte prestazioni,\n   supportando HMR.\n\n\n@gez/rspack-vue#\n\nModulo di costruzione dedicato al framework Vue, che fornisce:\n\n * Compilazione dei componenti Vue: Supporta la compilazione efficiente dei\n   componenti Vue 2/3.\n * Ottimizzazione SSR: Ottimizzazioni specifiche per scenari di rendering lato\n   server.\n * Miglioramenti per lo sviluppo: Funzionalità specifiche per migliorare\n   l'ambiente di sviluppo Vue.\n\n\nFlusso di costruzione#\n\nIl flusso di costruzione di Gez è suddiviso principalmente nelle seguenti fasi:\n\n 1. Inizializzazione della configurazione\n    \n    * Caricamento della configurazione del progetto\n    * Fusione della configurazione predefinita e della configurazione utente\n    * Adeguamento della configurazione in base alle variabili d'ambiente\n\n 2. Compilazione delle risorse\n    \n    * Analisi delle dipendenze del codice sorgente\n    * Conversione di vari tipi di risorse (TypeScript, CSS, ecc.)\n    * Gestione delle importazioni ed esportazioni dei moduli\n\n 3. Elaborazione dell'ottimizzazione\n    \n    * Esecuzione della suddivisione del codice\n    * Applicazione di Tree Shaking\n    * Compressione del codice e delle risorse\n\n 4. Generazione dell'output\n    \n    * Generazione dei file di destinazione\n    * Output della mappatura delle risorse\n    * Generazione del report di costruzione\n\n\nBest Practice#\n\n\nOttimizzazione dell'ambiente di sviluppo#\n\n * Configurazione della compilazione incrementale: Configurare correttamente\n   l'opzione cache per accelerare la velocità di costruzione sfruttando la\n   cache.\n * Ottimizzazione HMR: Configurare in modo mirato l'ambito dell'aggiornamento a\n   caldo per evitare aggiornamenti non necessari dei moduli.\n * Ottimizzazione dell'elaborazione delle risorse: Utilizzare configurazioni\n   appropriate dei loader per evitare elaborazioni ripetute.\n\n\nOttimizzazione dell'ambiente di produzione#\n\n * Strategia di suddivisione del codice: Configurare correttamente splitChunks\n   per ottimizzare il caricamento delle risorse.\n * Compressione delle risorse: Abilitare configurazioni di compressione\n   appropriate per bilanciare il tempo di costruzione e le dimensioni dei\n   prodotti.\n * Ottimizzazione della cache: Utilizzare strategie di hash dei contenuti e\n   cache a lungo termine per migliorare le prestazioni di caricamento.\n\n\nEsempio di configurazione#\n\n\n\nTIP\n\nPer ulteriori dettagli sulle API e le opzioni di configurazione, consultare la\ndocumentazione API di Rspack.","routePath":"/it/guide/essentials/rspack","lang":"it","toc":[{"text":"Caratteristiche","id":"caratteristiche","depth":2,"charIndex":234},{"text":"Costruzione dell'applicazione","id":"costruzione-dellapplicazione","depth":2,"charIndex":1202},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1361},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1975},{"text":"Flusso di costruzione","id":"flusso-di-costruzione","depth":2,"charIndex":2352},{"text":"Best Practice","id":"best-practice","depth":2,"charIndex":3258},{"text":"Ottimizzazione dell'ambiente di sviluppo","id":"ottimizzazione-dellambiente-di-sviluppo","depth":3,"charIndex":3275},{"text":"Ottimizzazione dell'ambiente di produzione","id":"ottimizzazione-dellambiente-di-produzione","depth":3,"charIndex":3761},{"text":"Esempio di configurazione","id":"esempio-di-configurazione","depth":2,"charIndex":4242}],"domain":"","frontmatter":{"titleSuffix":"Motore di costruzione ad alte prestazioni del framework Gez","description":"Un'analisi approfondita del sistema di costruzione Rspack del framework Gez, incluse le funzionalità principali come la compilazione ad alte prestazioni, la costruzione multi-ambiente, l'ottimizzazione delle risorse, per aiutare gli sviluppatori a costruire applicazioni Web moderne efficienti e affidabili.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, sistema di costruzione, compilazione ad alte prestazioni, aggiornamento a caldo, costruzione multi-ambiente, Tree Shaking, suddivisione del codice, SSR, ottimizzazione delle risorse, efficienza di sviluppo, strumenti di costruzione"}]]},"version":""},{"id":141,"title":"Standard e specifiche","content":"#\n\nGez è un moderno framework SSR che adotta una struttura di progetto\nstandardizzata e un meccanismo di risoluzione dei percorsi per garantire\ncoerenza e manutenibilità del progetto negli ambienti di sviluppo e produzione.\n\n\nSpecifiche della struttura del progetto#\n\n\nStruttura delle directory standard#\n\n\n\nInformazioni aggiuntive\n * gez.name deriva dal campo name di package.json\n * dist/package.json deriva da package.json nella directory root\n * La directory dist viene archiviata solo quando packs.enable è impostato su\n   true\n\n\nSpecifiche dei file di ingresso#\n\n\nentry.client.ts#\n\nIl file di ingresso lato client è responsabile di:\n\n * Inizializzazione dell'applicazione: configurazione delle impostazioni di base\n   dell'applicazione lato client\n * Gestione delle rotte: gestione delle rotte e della navigazione lato client\n * Gestione dello stato: memorizzazione e aggiornamento dello stato lato client\n * Gestione delle interazioni: gestione degli eventi utente e delle interazioni\n   dell'interfaccia\n\n\nentry.server.ts#\n\nIl file di ingresso lato server è responsabile di:\n\n * Rendering lato server: esecuzione del processo di rendering SSR\n * Generazione HTML: costruzione della struttura iniziale della pagina\n * Pre-fetching dei dati: gestione del recupero dei dati lato server\n * Iniezione dello stato: trasferimento dello stato dal server al client\n * Ottimizzazione SEO: ottimizzazione della pagina per i motori di ricerca\n\n\nentry.node.ts#\n\nIl file di ingresso del server Node.js è responsabile di:\n\n * Configurazione del server: impostazione dei parametri del server HTTP\n * Gestione delle rotte: gestione delle regole di routing lato server\n * Integrazione dei middleware: configurazione dei middleware del server\n * Gestione dell'ambiente: gestione delle variabili d'ambiente e delle\n   configurazioni\n * Gestione delle richieste e risposte: gestione delle richieste e risposte HTTP\n\n\nSpecifiche dei file di configurazione#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/it/guide/essentials/std","lang":"it","toc":[{"text":"Specifiche della struttura del progetto","id":"specifiche-della-struttura-del-progetto","depth":2,"charIndex":225},{"text":"Struttura delle directory standard","id":"struttura-delle-directory-standard","depth":3,"charIndex":268},{"text":"Specifiche dei file di ingresso","id":"specifiche-dei-file-di-ingresso","depth":2,"charIndex":534},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":569},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":1013},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1440},{"text":"Specifiche dei file di configurazione","id":"specifiche-dei-file-di-configurazione","depth":2,"charIndex":1903},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1944},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1962}],"domain":"","frontmatter":{"titleSuffix":"Guida alla struttura e alle specifiche del progetto Gez","description":"Una guida dettagliata alla struttura standard del progetto Gez, alle specifiche dei file di ingresso e alle configurazioni, per aiutare gli sviluppatori a costruire applicazioni SSR standardizzate e mantenibili.","head":[["meta",{"property":"keywords","content":"Gez, struttura del progetto, file di ingresso, specifiche di configurazione, framework SSR, TypeScript, standard di progetto, standard di sviluppo"}]]},"version":""},{"id":142,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/it/guide/frameworks/html","lang":"it","toc":[{"text":"Struttura del progetto","id":"struttura-del-progetto","depth":2,"charIndex":-1},{"text":"Configurazione del progetto","id":"configurazione-del-progetto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Struttura del codice sorgente","id":"struttura-del-codice-sorgente","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Esecuzione del progetto","id":"esecuzione-del-progetto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Esempio di applicazione HTML SSR con il framework Gez","description":"Costruisci da zero un'applicazione HTML SSR basata su Gez, dimostrando l'uso di base del framework attraverso un esempio pratico, inclusa l'inizializzazione del progetto, la configurazione HTML e l'impostazione dei file di ingresso.","head":[["meta",{"property":"keywords","content":"Gez, HTML, Applicazione SSR, Configurazione TypeScript, Inizializzazione progetto, Rendering lato server, Interazione lato client"}]]},"version":""},{"id":143,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/it/guide/frameworks/preact-htm","lang":"it","toc":[{"text":"Struttura del progetto","id":"struttura-del-progetto","depth":2,"charIndex":-1},{"text":"Configurazione del progetto","id":"configurazione-del-progetto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Struttura del codice sorgente","id":"struttura-del-codice-sorgente","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Esecuzione del progetto","id":"esecuzione-del-progetto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Esempio di applicazione Preact+HTM SSR con il framework Gez","description":"Impara a creare un'applicazione Preact+HTM SSR basata su Gez da zero. Questo tutorial mostra l'uso di base del framework, inclusa l'inizializzazione del progetto, la configurazione di Preact e l'impostazione dei file di ingresso.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, Applicazione SSR, Configurazione TypeScript, Inizializzazione progetto, Rendering lato server, Interazione lato client"}]]},"version":""},{"id":144,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/it/guide/frameworks/vue2","lang":"it","toc":[{"text":"Struttura del progetto","id":"struttura-del-progetto","depth":2,"charIndex":-1},{"text":"Configurazione del progetto","id":"configurazione-del-progetto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Struttura del codice sorgente","id":"struttura-del-codice-sorgente","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Esecuzione del progetto","id":"esecuzione-del-progetto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Esempio di applicazione Vue2 SSR con il framework Gez","description":"Impara a creare un'applicazione Vue2 SSR basata su Gez da zero, con un esempio pratico che mostra l'uso di base del framework, inclusa l'inizializzazione del progetto, la configurazione di Vue2 e l'impostazione dei file di ingresso.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, Applicazione SSR, Configurazione TypeScript, Inizializzazione progetto, Rendering lato server, Interazione lato client"}]]},"version":""},{"id":145,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/it/guide/frameworks/vue3","lang":"it","toc":[{"text":"Struttura del progetto","id":"struttura-del-progetto","depth":2,"charIndex":-1},{"text":"Configurazione del progetto","id":"configurazione-del-progetto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Struttura del codice sorgente","id":"struttura-del-codice-sorgente","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Esecuzione del progetto","id":"esecuzione-del-progetto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Esempio di applicazione Vue3 SSR con il framework Gez","description":"Costruisci da zero un'applicazione Vue3 SSR basata su Gez. Questo tutorial mostra l'uso di base del framework, inclusa l'inizializzazione del progetto, la configurazione di Vue3 e l'impostazione dei file di ingresso.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, Applicazione SSR, Configurazione TypeScript, Inizializzazione progetto, Rendering lato server, Interazione lato client, API composizionale"}]]},"version":""},{"id":146,"title":"Requisiti ambientali","content":"#\n\nQuesto documento descrive i requisiti ambientali necessari per utilizzare questo\nframework, inclusi l'ambiente Node.js e la compatibilità del browser.\n\n\nAmbiente Node.js#\n\nIl framework richiede Node.js versione >= 22.6, principalmente per supportare\nl'importazione di tipi TypeScript (tramite il flag --experimental-strip-types),\nsenza la necessità di ulteriori passaggi di compilazione.\n\n\nCompatibilità del browser#\n\nIl framework utilizza per impostazione predefinita una modalità di costruzione\ncompatibile, per supportare una gamma più ampia di browser. Tuttavia, è\nimportante notare che per ottenere un supporto completo alla compatibilità del\nbrowser, è necessario aggiungere manualmente la dipendenza es-module-shims.\n\n\nModalità compatibile (predefinita)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nSecondo le statistiche di Can I Use, la copertura del browser in modalità\ncompatibile raggiunge il 96.81%.\n\n\nModalità di supporto nativo#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nLa modalità di supporto nativo offre i seguenti vantaggi:\n\n * Nessun sovraccarico di runtime, senza la necessità di ulteriori caricatori di\n   moduli\n * Analisi nativa del browser, con velocità di esecuzione più rapida\n * Migliore capacità di suddivisione del codice e caricamento su richiesta\n\nSecondo le statistiche di Can I Use, la copertura del browser in modalità di\nsupporto nativo raggiunge il 93.5%.\n\n\nAbilitare il supporto compatibile#\n\nNota importante\n\nSebbene il framework utilizzi per impostazione predefinita una modalità di\ncostruzione compatibile, per ottenere un supporto completo ai browser più\nvecchi, è necessario aggiungere la dipendenza es-module-shims al progetto.\n\nAggiungere il seguente script nel file HTML:\n\n\n\nBest practice\n 1. Raccomandazioni per l'ambiente di produzione:\n    * Distribuire es-module-shims su un server proprio\n    * Garantire la stabilità e la velocità di accesso delle risorse\n    * Evitare potenziali rischi di sicurezza\n 2. Considerazioni sulle prestazioni:\n    * La modalità compatibile comporta un leggero sovraccarico delle prestazioni\n    * È possibile decidere se abilitarla in base alla distribuzione del browser\n      del gruppo di utenti target","routePath":"/it/guide/start/environment","lang":"it","toc":[{"text":"Ambiente Node.js","id":"ambiente-nodejs","depth":2,"charIndex":155},{"text":"Compatibilità del browser","id":"compatibilità-del-browser","depth":2,"charIndex":392},{"text":"Modalità compatibile (predefinita)","id":"modalità-compatibile-predefinita","depth":3,"charIndex":728},{"text":"Modalità di supporto nativo","id":"modalità-di-supporto-nativo","depth":3,"charIndex":954},{"text":"Abilitare il supporto compatibile","id":"abilitare-il-supporto-compatibile","depth":3,"charIndex":1477}],"domain":"","frontmatter":{"titleSuffix":"Guida alla compatibilità del framework Gez","description":"Descrizione dettagliata dei requisiti ambientali del framework Gez, inclusi i requisiti di versione di Node.js e le specifiche di compatibilità del browser, per aiutare gli sviluppatori a configurare correttamente l'ambiente di sviluppo.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, Compatibilità browser, TypeScript, es-module-shims, Configurazione ambiente"}]]},"version":""},{"id":147,"title":"Guida Rapida","content":"#\n\n\nInizializzazione del Progetto#\n\nPer creare e inizializzare un nuovo progetto Gez, segui questi passaggi:\n\n\n\n\nScelta della Versione del Framework#\n\nIl framework Gez offre diverse versioni per stack tecnologici, ciascuna\nottimizzata per diversi scenari di applicazione. Scegli la versione più adatta\nin base alle esigenze del tuo progetto:\n\n\nHTML#\n\nIdeale per progetti che richiedono un'architettura minimalista:\n\n * Nessuna dipendenza esterna, pronto all'uso\n * Esperienza di sviluppo con JavaScript nativo\n * Adatto per la costruzione di siti web statici e applicazioni leggere\n * Supporto per l'estensione progressiva delle funzionalità\n\nConsulta la documentazione dettagliata per la versione HTML\n\n\nVue2#\n\nAdatto per lo sviluppo di applicazioni aziendali:\n\n * Supporto completo per TypeScript\n * Ampio ecosistema di componenti di terze parti\n * Strumenti di sviluppo maturi\n * Stabilità verificata in ambienti di produzione\n\nConsulta la documentazione dettagliata per la versione Vue2\n\n\nVue3#\n\nAdatto per lo sviluppo di applicazioni web moderne:\n\n * Sistema reattivo basato su Proxy\n * Supporto per API composizionali\n * Migliori prestazioni a runtime\n * Volume di pacchetto ridotto\n\nConsulta la documentazione dettagliata per la versione Vue3\n\n\nPreact+HTM#\n\nAdatto per progetti che richiedono leggerezza e alte prestazioni:\n\n * Volume di runtime estremamente ridotto (3KB)\n * Sintassi di template JavaScript nativa\n * API compatibile con React\n * Eccellenti prestazioni\n\nConsulta la documentazione dettagliata per la versione Preact+HTM\n\n\nSviluppo Assistito da AI#\n\nIl framework Gez offre capacità di sviluppo assistito da AI, che possono\nmigliorare significativamente l'efficienza dello sviluppo:\n\n 1. Seleziona la documentazione della versione del framework più adatta\n 2. Fornisci il contenuto della documentazione all'assistente AI\n 3. L'AI genererà automaticamente lo scheletro del progetto e i file di\n    configurazione\n\nSuggerimento\n\nLo sviluppo assistito da AI non solo accelera l'inizializzazione del progetto,\nma garantisce anche che la struttura del progetto sia conforme alle migliori\npratiche.","routePath":"/it/guide/start/getting-started","lang":"it","toc":[{"text":"Inizializzazione del Progetto","id":"inizializzazione-del-progetto","depth":2,"charIndex":3},{"text":"Scelta della Versione del Framework","id":"scelta-della-versione-del-framework","depth":2,"charIndex":112},{"text":"HTML","id":"html","depth":3,"charIndex":343},{"text":"Vue2","id":"vue2","depth":3,"charIndex":704},{"text":"Vue3","id":"vue3","depth":3,"charIndex":992},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1251},{"text":"Sviluppo Assistito da AI","id":"sviluppo-assistito-da-ai","depth":2,"charIndex":1545}],"domain":"","frontmatter":{"titleSuffix":"Guida rapida al framework Gez","description":"Guida rapida al framework Gez per iniziare da zero a creare un progetto, inclusa l'inizializzazione del progetto, la scelta della versione del framework e lo sviluppo assistito da AI.","head":[["meta",{"name":"keywords","content":"framework Gez, guida rapida, inizializzazione progetto, sviluppo Vue, sviluppo HTML, sviluppo assistito da AI"}]]},"version":""},{"id":148,"title":"Introduzione","content":"#\n\n\nContesto del Progetto#\n\nGez è un framework moderno per micro-frontend basato su ECMAScript Modules\n(ESM), focalizzato sulla costruzione di applicazioni ad alte prestazioni e\nscalabili con rendering lato server (SSR). Come terza generazione del progetto\nGenesis, Gez ha innovato continuamente durante il suo sviluppo tecnologico:\n\n * v1.0: Implementazione del caricamento on-demand dei componenti remoti basato\n   su richieste HTTP\n * v2.0: Integrazione delle applicazioni basata su Webpack Module Federation\n * v3.0: Ridisegno del sistema di collegamento dei moduli basato su ESM nativo\n   del browser\n\n\nContesto Tecnologico#\n\nNell'evoluzione dell'architettura a micro-frontend, le soluzioni tradizionali\npresentano principalmente le seguenti limitazioni:\n\n\nSfide delle Soluzioni Esistenti#\n\n * Colli di bottiglia delle prestazioni: L'iniezione delle dipendenze a runtime\n   e il proxy delle sandbox JavaScript comportano un significativo sovraccarico\n   delle prestazioni\n * Meccanismi di isolamento: Le sandbox personalizzate faticano a raggiungere le\n   capacità di isolamento dei moduli nativi del browser\n * Complessità di costruzione: Le modifiche agli strumenti di build per\n   condividere le dipendenze aumentano i costi di manutenzione del progetto\n * Deviazione dagli standard: Strategie di distribuzione speciali e meccanismi\n   di elaborazione a runtime divergono dagli standard moderni di sviluppo web\n * Limitazioni dell'ecosistema: L'accoppiamento del framework e le API\n   personalizzate limitano la scelta dello stack tecnologico\n\n\nInnovazione Tecnologica#\n\nGez, basandosi sugli standard web moderni, offre una nuova soluzione:\n\n * Sistema di moduli nativo: Utilizza ESM nativo del browser e Import Maps per\n   la gestione delle dipendenze, garantendo una velocità di analisi ed\n   esecuzione superiore\n * Meccanismo di isolamento standard: Isolamento affidabile delle applicazioni\n   basato sull'ambito dei moduli ECMAScript\n * Stack tecnologico aperto: Supporta l'integrazione senza soluzione di\n   continuità di qualsiasi framework frontend moderno\n * Ottimizzazione dell'esperienza di sviluppo: Fornisce modalità di sviluppo\n   intuitive e capacità di debug complete\n * Ottimizzazione delle prestazioni estreme: Zero sovraccarico a runtime grazie\n   alle capacità native, con strategie di caching intelligenti\n\nTIP\n\nGez si concentra sulla creazione di infrastrutture per micro-frontend ad alte\nprestazioni e facilmente estendibili, particolarmente adatte per applicazioni di\nrendering lato server su larga scala.\n\n\nSpecifiche Tecniche#\n\n\nDipendenze dell'Ambiente#\n\nFai riferimento alla documentazione sui requisiti dell'ambiente per i dettagli\nsui requisiti del browser e di Node.js.\n\n\nStack Tecnologico Principale#\n\n * Gestione delle dipendenze: Utilizza Import Maps per il mapping dei moduli,\n   con supporto di compatibilità fornito da es-module-shims\n * Sistema di build: Basato su Rspack per la gestione delle dipendenze esterne\n   con module-import\n * Toolchain di sviluppo: Supporta aggiornamenti a caldo ESM ed esecuzione\n   nativa di TypeScript\n\n\nPosizionamento del Framework#\n\nGez è diverso da Next.js o Nuxt.js, concentrandosi invece sulla fornitura di\ninfrastrutture per micro-frontend:\n\n * Sistema di collegamento dei moduli: Implementa un'importazione ed\n   esportazione dei moduli efficiente e affidabile\n * Rendering lato server: Fornisce meccanismi flessibili per l'implementazione\n   SSR\n * Supporto del sistema di tipi: Integra definizioni di tipo TypeScript complete\n * Neutralità del framework: Supporta l'integrazione con i principali framework\n   frontend\n\n\nProgettazione dell'Architettura#\n\n\nGestione Centralizzata delle Dipendenze#\n\n * Fonte unica delle dipendenze: Gestione centralizzata delle dipendenze di\n   terze parti\n * Distribuzione automatica: Sincronizzazione globale automatica degli\n   aggiornamenti delle dipendenze\n * Coerenza delle versioni: Controllo preciso delle versioni delle dipendenze\n\n\nProgettazione Modulare#\n\n * Separazione delle responsabilità: Disaccoppiamento della logica di business\n   dall'infrastruttura\n * Meccanismo dei plugin: Supporta la combinazione e la sostituzione flessibile\n   dei moduli\n * Interfacce standard: Protocolli di comunicazione standardizzati tra i moduli\n\n\nOttimizzazione delle Prestazioni#\n\n * Principio di zero sovraccarico: Massimizzazione dell'utilizzo delle capacità\n   native del browser\n * Caching intelligente: Strategie di caching precise basate sull'hash del\n   contenuto\n * Caricamento on-demand: Gestione fine delle dipendenze e suddivisione del\n   codice\n\n\nMaturità del Progetto#\n\nGez, attraverso quasi 5 anni di evoluzione iterativa (dalla v1.0 alla v3.0), è\nstato ampiamente validato in ambienti aziendali. Attualmente supporta decine di\nprogetti aziendali in esecuzione stabile e continua a promuovere l'aggiornamento\ndello stack tecnologico. La stabilità, l'affidabilità e i vantaggi prestazionali\ndel framework sono stati ampiamente testati nella pratica, fornendo una base\ntecnica affidabile per lo sviluppo di applicazioni su larga scala.","routePath":"/it/guide/start/introduction","lang":"it","toc":[{"text":"Contesto del Progetto","id":"contesto-del-progetto","depth":2,"charIndex":3},{"text":"Contesto Tecnologico","id":"contesto-tecnologico","depth":2,"charIndex":607},{"text":"Sfide delle Soluzioni Esistenti","id":"sfide-delle-soluzioni-esistenti","depth":3,"charIndex":761},{"text":"Innovazione Tecnologica","id":"innovazione-tecnologica","depth":3,"charIndex":1552},{"text":"Specifiche Tecniche","id":"specifiche-tecniche","depth":2,"charIndex":2539},{"text":"Dipendenze dell'Ambiente","id":"dipendenze-dellambiente","depth":3,"charIndex":2562},{"text":"Stack Tecnologico Principale","id":"stack-tecnologico-principale","depth":3,"charIndex":2710},{"text":"Posizionamento del Framework","id":"posizionamento-del-framework","depth":2,"charIndex":3080},{"text":"Progettazione dell'Architettura","id":"progettazione-dellarchitettura","depth":2,"charIndex":3605},{"text":"Gestione Centralizzata delle Dipendenze","id":"gestione-centralizzata-delle-dipendenze","depth":3,"charIndex":3640},{"text":"Progettazione Modulare","id":"progettazione-modulare","depth":3,"charIndex":3958},{"text":"Ottimizzazione delle Prestazioni","id":"ottimizzazione-delle-prestazioni","depth":3,"charIndex":4261},{"text":"Maturità del Progetto","id":"maturità-del-progetto","depth":2,"charIndex":4574}],"domain":"","frontmatter":{"titleSuffix":"Panoramica del Framework Gez e Innovazione Tecnologica","description":"Approfondisci il contesto del progetto, l'evoluzione tecnologica e i vantaggi principali del framework Gez per micro-frontend, esplorando soluzioni moderne di rendering lato server basate su ESM.","head":[["meta",{"property":"keywords","content":"Gez, micro-frontend, ESM, rendering lato server, SSR, innovazione tecnologica, module federation"}]]},"version":""}]