[{"id":200,"title":"@gez/rspack-vue","content":"#\n\nO pacote Rspack Vue fornece um conjunto de APIs para criar e configurar\naplicativos Rspack baseados no framework Vue, com suporte para desenvolvimento\nde componentes Vue, construção e renderização no servidor.\n\n\nInstalação#\n\nInstale a dependência de desenvolvimento @gez/rspack-vue usando um gerenciador\nde pacotes:\n\n\nExportação de tipos#\n\n\nBuildTarget#\n\n\n\nTipo de ambiente de construção, define o ambiente de destino para a construção\ndo aplicativo, usado para configurar otimizações e funcionalidades específicas\ndurante o processo de construção:\n\n * node: Constrói código para execução em ambiente Node.js\n * client: Constrói código para execução em navegadores\n * server: Constrói código para execução em servidores\n\n\nRspackAppConfigContext#\n\n\n\nInterface de contexto de configuração do aplicativo Rspack, fornece informações\nde contexto que podem ser acessadas em funções de hook de configuração:\n\n * gez: Instância do framework Gez\n * buildTarget: Ambiente de construção atual (client/server/node)\n * config: Objeto de configuração do Rspack\n * options: Opções de configuração do aplicativo\n\n\nRspackAppOptions#\n\n\n\nInterface de opções de configuração do aplicativo Rspack:\n\n * css: Método de saída do CSS, opções 'css' (arquivo separado) ou 'style'\n   (estilos inline)\n * loaders: Configuração personalizada de loaders\n * styleLoader: Opções de configuração do style-loader\n * cssLoader: Opções de configuração do css-loader\n * target: Configuração de compatibilidade do ambiente de construção\n * definePlugin: Definição de constantes globais\n * config: Função de hook de configuração\n\n\nRspackHtmlAppOptions#\n\nHerdado de RspackAppOptions, usado para configurar opções específicas de\naplicativos HTML.\n\n\nExportação de funções#\n\n\ncreateRspackApp#\n\n\n\nCria uma instância padrão de aplicativo Rspack.\n\nParâmetros:\n\n * gez: Instância do framework Gez\n * options: Opções de configuração do aplicativo Rspack\n\nRetorno:\n\n * Retorna uma Promise que resolve para a instância do aplicativo criado\n\n\ncreateRspackHtmlApp#\n\n\n\nCria uma instância de aplicativo Rspack do tipo HTML.\n\nParâmetros:\n\n * gez: Instância do framework Gez\n * options: Opções de configuração do aplicativo HTML\n\nRetorno:\n\n * Retorna uma Promise que resolve para a instância do aplicativo HTML criado\n\n\nExportação de constantes#\n\n\nRSPACK_LOADER#\n\n\n\nObjeto de mapeamento de identificadores de loaders internos do Rspack,\nfornecendo constantes de nomes de loaders comumente usados:\n\n * builtinSwcLoader: Loader SWC interno do Rspack, usado para processar arquivos\n   TypeScript/JavaScript\n * lightningcssLoader: Loader lightningcss interno do Rspack, usado para\n   processar arquivos CSS com compilação de alto desempenho\n * styleLoader: Loader usado para injetar CSS no DOM\n * cssLoader: Loader usado para analisar arquivos CSS e lidar com modularização\n   de CSS\n * lessLoader: Loader usado para compilar arquivos Less em CSS\n * styleResourcesLoader: Loader usado para importar automaticamente recursos de\n   estilo globais (como variáveis, mixins)\n * workerRspackLoader: Loader usado para processar arquivos Web Worker\n\nUsar essas constantes permite referenciar loaders internos na configuração,\nevitando a digitação manual de strings:\n\n\n\nObservações:\n\n * Esses loaders já estão embutidos no Rspack, não sendo necessário instalá-los\n   separadamente\n * Ao configurar loaders personalizados, essas constantes podem ser usadas para\n   substituir a implementação padrão do loader\n * Alguns loaders (como builtinSwcLoader) possuem opções de configuração\n   específicas, consulte a documentação correspondente\n\n\nExportação de módulos#\n\n\nrspack#\n\nReexporta todo o conteúdo do pacote @rspack/core, fornecendo funcionalidades\ncompletas do núcleo do Rspack.","routePath":"/pt/api/app/rspack-vue","lang":"pt","toc":[{"text":"Instalação","id":"instalação","depth":2,"charIndex":214},{"text":"Exportação de tipos","id":"exportação-de-tipos","depth":2,"charIndex":320},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":343},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":724},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1100},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1593},{"text":"Exportação de funções","id":"exportação-de-funções","depth":2,"charIndex":1709},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1734},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1993},{"text":"Exportação de constantes","id":"exportação-de-constantes","depth":2,"charIndex":2265},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2293},{"text":"Exportação de módulos","id":"exportação-de-módulos","depth":2,"charIndex":3570},{"text":"rspack","id":"rspack","depth":3,"charIndex":3595}],"domain":"","frontmatter":{"titleSuffix":"Ferramenta de construção Vue do framework Gez","description":"Ferramenta de construção especializada em Vue para o framework Gez, oferecendo suporte completo para construção de aplicativos Vue 2/3, incluindo desenvolvimento de componentes, renderização SSR e otimização de desempenho.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, ferramenta de construção, desenvolvimento de componentes, renderização no servidor, otimização de desempenho"}]]},"version":""},{"id":201,"title":"@gez/rspack","content":"#\n\nO pacote Rspack fornece um conjunto de APIs para criar e configurar aplicativos\nRspack, suportando a construção e desenvolvimento de aplicativos padrão e\naplicativos HTML.\n\n\nInstalação#\n\nInstale a dependência de desenvolvimento @gez/rspack usando um gerenciador de\npacotes:\n\n\nExportação de tipos#\n\n\nBuildTarget#\n\n\n\nTipo de ambiente de destino de construção, define o ambiente de destino para o\nqual o aplicativo será construído, usado para configurar otimizações e\nfuncionalidades específicas durante o processo de construção:\n\n * node: Código executado no ambiente Node.js\n * client: Código executado no ambiente do navegador\n * server: Código executado no ambiente do servidor\n\n\nRspackAppConfigContext#\n\n\n\nInterface de contexto de configuração do aplicativo Rspack, fornece informações\nde contexto que podem ser acessadas em funções de gancho de configuração:\n\n * gez: Instância do framework Gez\n * buildTarget: Destino de construção atual (client/server/node)\n * config: Objeto de configuração do Rspack\n * options: Opções de configuração do aplicativo\n\n\nRspackAppOptions#\n\n\n\nInterface de opções de configuração do aplicativo Rspack:\n\n * css: Método de saída do CSS, opções 'css' (arquivo separado) ou 'style'\n   (estilos inline)\n * loaders: Configuração personalizada de loaders\n * styleLoader: Opções de configuração do style-loader\n * cssLoader: Opções de configuração do css-loader\n * target: Configuração de compatibilidade do destino de construção\n * definePlugin: Definição de constantes globais\n * config: Função de gancho de configuração\n\n\nRspackHtmlAppOptions#\n\nHerdado de RspackAppOptions, usado para configurar opções específicas de\naplicativos HTML.\n\n\nExportação de funções#\n\n\ncreateRspackApp#\n\n\n\nCria uma instância de aplicativo Rspack padrão.\n\nParâmetros:\n\n * gez: Instância do framework Gez\n * options: Opções de configuração do aplicativo Rspack\n\nRetorno:\n\n * Retorna uma Promise que resolve para a instância do aplicativo criado\n\n\ncreateRspackHtmlApp#\n\n\n\nCria uma instância de aplicativo Rspack do tipo HTML.\n\nParâmetros:\n\n * gez: Instância do framework Gez\n * options: Opções de configuração do aplicativo HTML\n\nRetorno:\n\n * Retorna uma Promise que resolve para a instância do aplicativo HTML criado\n\n\nExportação de constantes#\n\n\nRSPACK_LOADER#\n\n\n\nObjeto de mapeamento de identificadores de loaders integrados do Rspack, fornece\nconstantes de nomes de loaders comumente usados:\n\n * builtinSwcLoader: Loader SWC integrado do Rspack, usado para processar\n   arquivos TypeScript/JavaScript\n * lightningcssLoader: Loader lightningcss integrado do Rspack, usado para\n   processar arquivos CSS com compilação de alto desempenho\n * styleLoader: Loader usado para injetar CSS no DOM\n * cssLoader: Loader usado para analisar arquivos CSS e processar modularização\n   de CSS\n * lessLoader: Loader usado para compilar arquivos Less em CSS\n * styleResourcesLoader: Loader usado para importar automaticamente recursos de\n   estilo globais (como variáveis, mixins)\n * workerRspackLoader: Loader usado para processar arquivos de Web Worker\n\nUsar essas constantes permite referenciar loaders integrados na configuração,\nevitando a digitação manual de strings:\n\n\n\nObservações:\n\n * Esses loaders já estão integrados no Rspack, não sendo necessário instalá-los\n   separadamente\n * Ao configurar loaders personalizados, essas constantes podem ser usadas para\n   substituir a implementação padrão do loader\n * Alguns loaders (como builtinSwcLoader) têm opções de configuração\n   específicas, consulte a documentação de configuração correspondente\n\n\nExportação de módulos#\n\n\nrspack#\n\nReexporta todo o conteúdo do pacote @rspack/core, fornecendo todas as\nfuncionalidades principais do Rspack.","routePath":"/pt/api/app/rspack","lang":"pt","toc":[{"text":"Instalação","id":"instalação","depth":2,"charIndex":176},{"text":"Exportação de tipos","id":"exportação-de-tipos","depth":2,"charIndex":278},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":301},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":683},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1060},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1554},{"text":"Exportação de funções","id":"exportação-de-funções","depth":2,"charIndex":1670},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1695},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1954},{"text":"Exportação de constantes","id":"exportação-de-constantes","depth":2,"charIndex":2226},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2254},{"text":"Exportação de módulos","id":"exportação-de-módulos","depth":2,"charIndex":3552},{"text":"rspack","id":"rspack","depth":3,"charIndex":3577}],"domain":"","frontmatter":{"titleSuffix":"Ferramenta de construção Rspack do framework Gez","description":"A ferramenta de construção Rspack do framework Gez oferece capacidades de construção de aplicativos de alto desempenho, suportando o desenvolvimento e construção de aplicativos padrão e aplicativos HTML, com diversos processadores de recursos e configurações de otimização integrados.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Ferramenta de construção, Construção de aplicativos, Aplicativo HTML, TypeScript, CSS, Processamento de recursos, Otimização de desempenho"}]]},"version":""},{"id":202,"title":"App","content":"#\n\nApp é a abstração de aplicação do framework Gez, fornecendo uma interface\nunificada para gerenciar o ciclo de vida do aplicativo, recursos estáticos e\nrenderização do lado do servidor.\n\n\n\n\nDefinição de tipos#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Tipo: Middleware\n\nMiddleware de manipulação de recursos estáticos.\n\nAmbiente de desenvolvimento:\n\n * Processa solicitações de recursos estáticos do código-fonte\n * Suporta compilação em tempo real e atualização a quente (hot reload)\n * Usa política de cache no-cache\n\nAmbiente de produção:\n\n * Processa recursos estáticos após a construção\n * Suporta cache de longo prazo para arquivos imutáveis (.final.xxx)\n * Estratégia otimizada de carregamento de recursos\n\n\n\nrender#\n\n * Tipo: (options?: RenderContextOptions) => Promise\n\nFunção de renderização do lado do servidor. Fornece implementações diferentes\ndependendo do ambiente de execução:\n\n * Ambiente de produção (start): Carrega o arquivo de entrada do servidor após a\n   construção (entry.server) e executa a renderização\n * Ambiente de desenvolvimento (dev): Carrega o arquivo de entrada do servidor\n   do código-fonte e executa a renderização\n\n\n\nbuild#\n\n * Tipo: () => Promise\n\nFunção de construção para o ambiente de produção. Usada para empacotamento e\notimização de recursos. Retorna true em caso de sucesso na construção, false em\ncaso de falha.\n\ndestroy#\n\n * Tipo: () => Promise\n\nFunção de limpeza de recursos. Usada para fechar o servidor, desconectar\nconexões, etc. Retorna true em caso de sucesso na limpeza, false em caso de\nfalha.","routePath":"/pt/api/core/app","lang":"pt","toc":[{"text":"Definição de tipos","id":"definição-de-tipos","depth":2,"charIndex":191},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":221},{"text":"render","id":"render","depth":4,"charIndex":701},{"text":"build","id":"build","depth":4,"charIndex":1140},{"text":"destroy","id":"destroy","depth":4,"charIndex":1345}],"domain":"","frontmatter":{"titleSuffix":"Interface de abstração de aplicação do framework Gez","description":"Detalha a interface App do framework Gez, incluindo gerenciamento do ciclo de vida do aplicativo, manipulação de recursos estáticos e renderização do lado do servidor, ajudando os desenvolvedores a entender e usar as funcionalidades principais do aplicativo.","head":[["meta",{"property":"keywords","content":"Gez, App, abstração de aplicação, ciclo de vida, recursos estáticos, renderização do lado do servidor, API"}]]},"version":""},{"id":203,"title":"Gez","content":"#\n\n\nIntrodução#\n\nGez é um framework de aplicação Web de alto desempenho baseado no Rspack, que\noferece gerenciamento completo do ciclo de vida do aplicativo, manipulação de\nrecursos estáticos e capacidade de renderização no lado do servidor.\n\n\nDefinições de Tipos#\n\n\nRuntimeTarget#\n\n * Definição de Tipo:\n\n\n\nTipos de ambiente de execução do aplicativo:\n\n * client: Executa no ambiente do navegador, suporta operações DOM e APIs do\n   navegador\n * server: Executa no ambiente Node.js, suporta sistema de arquivos e\n   funcionalidades do lado do servidor\n\n\nImportMap#\n\n * Definição de Tipo:\n\n\n\nTipo de mapeamento de importação de módulos ES.\n\nSpecifierMap#\n\n * Definição de Tipo:\n\n\n\nTipo de mapeamento de identificadores de módulos, usado para definir o\nmapeamento de caminhos de importação de módulos.\n\nScopesMap#\n\n * Definição de Tipo:\n\n\n\nTipo de mapeamento de escopo, usado para definir o mapeamento de importação de\nmódulos em escopos específicos.\n\n\nCOMMAND#\n\n * Definição de Tipo:\n\n\n\nEnumeração de tipos de comandos:\n\n * dev: Comando de ambiente de desenvolvimento, inicia o servidor de\n   desenvolvimento com suporte a atualização em tempo real\n * build: Comando de construção, gera os artefatos de construção para o ambiente\n   de produção\n * preview: Comando de pré-visualização, inicia o servidor de pré-visualização\n   local\n * start: Comando de inicialização, executa o servidor de produção\n\n\nOpções de Instância#\n\nDefine as opções de configuração principais do framework Gez.\n\n\n\nroot#\n\n * Tipo: string\n * Valor Padrão: process.cwd()\n\nCaminho do diretório raiz do projeto. Pode ser um caminho absoluto ou relativo,\ncaminhos relativos são resolvidos com base no diretório de trabalho atual.\n\nisProd#\n\n * Tipo: boolean\n * Valor Padrão: process.env.NODE_ENV === 'production'\n\nIdentificador de ambiente.\n\n * true: Ambiente de produção\n * false: Ambiente de desenvolvimento\n\nbasePathPlaceholder#\n\n * Tipo: string | false\n * Valor Padrão: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nConfiguração do espaço reservado para o caminho base. Usado para substituir\ndinamicamente o caminho base dos recursos em tempo de execução. Definir como\nfalse desativa essa funcionalidade.\n\nmodules#\n\n * Tipo: ModuleConfig\n\nOpções de configuração de módulos. Usado para configurar as regras de resolução\nde módulos do projeto, incluindo aliases de módulos, dependências externas, etc.\n\npacks#\n\n * Tipo: PackConfig\n\nOpções de configuração de empacotamento. Usado para empacotar os artefatos de\nconstrução em pacotes npm no formato .tgz.\n\ndevApp#\n\n * Tipo: (gez: Gez) => Promise\n\nFunção de criação de aplicativo para o ambiente de desenvolvimento. Usado apenas\nno ambiente de desenvolvimento, para criar a instância do aplicativo do servidor\nde desenvolvimento.\n\n\n\nserver#\n\n * Tipo: (gez: Gez) => Promise\n\nFunção de configuração de inicialização do servidor. Usado para configurar e\niniciar o servidor HTTP, pode ser usado tanto no ambiente de desenvolvimento\nquanto no de produção.\n\n\n\npostBuild#\n\n * Tipo: (gez: Gez) => Promise\n\nFunção de pós-processamento de construção. Executada após a construção do\nprojeto, pode ser usada para:\n\n * Executar processamento adicional de recursos\n * Operações de implantação\n * Gerar arquivos estáticos\n * Enviar notificações de construção\n\n\nPropriedades da Instância#\n\n\nname#\n\n * Tipo: string\n * Somente Leitura: true\n\nNome do módulo atual, derivado da configuração do módulo.\n\n\nvarName#\n\n * Tipo: string\n * Somente Leitura: true\n\nNome de variável JavaScript válido gerado com base no nome do módulo.\n\n\nroot#\n\n * Tipo: string\n * Somente Leitura: true\n\nCaminho absoluto do diretório raiz do projeto. Se o root configurado for um\ncaminho relativo, ele será resolvido com base no diretório de trabalho atual.\n\n\nisProd#\n\n * Tipo: boolean\n * Somente Leitura: true\n\nDetermina se o ambiente atual é de produção. Prioriza o isProd da configuração,\nse não configurado, usa process.env.NODE_ENV para determinar.\n\n\nbasePath#\n\n * Tipo: string\n * Somente Leitura: true\n * Lança: NotReadyError - Quando o framework não está inicializado\n\nObtém o caminho base do módulo que começa e termina com uma barra. Retorna o\nformato /${name}/, onde name vem da configuração do módulo.\n\n\nbasePathPlaceholder#\n\n * Tipo: string\n * Somente Leitura: true\n\nObtém o espaço reservado para substituição dinâmica do caminho base em tempo de\nexecução. Pode ser desativado pela configuração.\n\n\nmiddleware#\n\n * Tipo: Middleware\n * Somente Leitura: true\n\nObtém o middleware de manipulação de recursos estáticos. Fornece implementações\ndiferentes dependendo do ambiente:\n\n * Ambiente de desenvolvimento: Suporta compilação em tempo real do código-fonte\n   e atualização em tempo real\n * Ambiente de produção: Suporta cache de longo prazo para recursos estáticos\n\n\n\n\nrender#\n\n * Tipo: (options?: RenderContextOptions) => Promise\n * Somente Leitura: true\n\nObtém a função de renderização no lado do servidor. Fornece implementações\ndiferentes dependendo do ambiente:\n\n * Ambiente de desenvolvimento: Suporta atualização em tempo real e\n   pré-visualização em tempo real\n * Ambiente de produção: Fornece desempenho de renderização otimizado\n\n\n\n\nCOMMAND#\n\n * Tipo: typeof COMMAND\n * Somente Leitura: true\n\nObtém a definição do tipo de enumeração de comandos.\n\n\nmoduleConfig#\n\n * Tipo: ParsedModuleConfig\n * Somente Leitura: true\n * Lança: NotReadyError - Quando o framework não está inicializado\n\nObtém as informações completas de configuração do módulo atual, incluindo regras\nde resolução de módulos, configuração de aliases, etc.\n\n\npackConfig#\n\n * Tipo: ParsedPackConfig\n * Somente Leitura: true\n * Lança: NotReadyError - Quando o framework não está inicializado\n\nObtém as configurações relacionadas ao empacotamento do módulo atual, incluindo\ncaminho de saída, processamento de package.json, etc.\n\n\nMétodos da Instância#\n\n\nconstructor()#\n\n * Parâmetros:\n   * options?: GezOptions - Opções de configuração do framework\n * Retorno: Gez\n\nCria uma instância do framework Gez.\n\n\n\n\ninit()#\n\n * Parâmetros: command: COMMAND\n * Retorno: Promise\n * Lança:\n   * Error: Quando há inicialização repetida\n   * NotReadyError: Quando acessado antes da inicialização\n\nInicializa a instância do framework Gez. Executa os seguintes processos\nprincipais de inicialização:\n\n 1. Resolve as configurações do projeto (package.json, configuração de módulos,\n    configuração de empacotamento, etc.)\n 2. Cria a instância do aplicativo (ambiente de desenvolvimento ou produção)\n 3. Executa os métodos do ciclo de vida correspondentes com base no comando\n\nAtenção\n * Lança um erro em caso de inicialização repetida\n * Lança NotReadyError ao acessar uma instância não inicializada\n\n\n\n\ndestroy()#\n\n * Retorno: Promise\n\nDestrói a instância do framework Gez, executa a limpeza de recursos e o\nfechamento de conexões. Principalmente usado para:\n\n * Fechar o servidor de desenvolvimento\n * Limpar arquivos temporários e cache\n * Liberar recursos do sistema\n\n\n\n\nbuild()#\n\n * Retorno: Promise\n\nExecuta o processo de construção do aplicativo, incluindo:\n\n * Compilar o código-fonte\n * Gerar os artefatos de construção para o ambiente de produção\n * Otimizar e comprimir o código\n * Gerar o manifesto de recursos\n\nAtenção\n\nLança NotReadyError se chamado antes da inicialização do framework\n\n\n\n\nserver()#\n\n * Retorno: Promise\n * Lança: NotReadyError - Quando o framework não está inicializado\n\nInicia o servidor HTTP e configura a instância do servidor. Chamado nos\nseguintes ciclos de vida:\n\n * Ambiente de desenvolvimento (dev): Inicia o servidor de desenvolvimento,\n   fornece atualização em tempo real\n * Ambiente de produção (start): Inicia o servidor de produção, fornece\n   desempenho de nível de produção\n\n\n\n\npostBuild()#\n\n * Retorno: Promise\n\nExecuta a lógica de pós-processamento de construção, usada para:\n\n * Gerar arquivos HTML estáticos\n * Processar os artefatos de construção\n * Executar tarefas de implantação\n * Enviar notificações de construção\n\n\n\n\nresolvePath#\n\nResolve o caminho do projeto, convertendo caminhos relativos em absolutos.\n\n * Parâmetros:\n   \n   * projectPath: ProjectPath - Tipo de caminho do projeto\n   * ...args: string[] - Segmentos do caminho\n\n * Retorno: string - Caminho absoluto resolvido\n\n * Exemplo:\n\n\n\n\nwriteSync()#\n\nEscreve o conteúdo do arquivo de forma síncrona.\n\n * Parâmetros:\n   \n   * filepath: string - Caminho absoluto do arquivo\n   * data: any - Dados a serem escritos, podem ser string, Buffer ou objeto\n\n * Retorno: boolean - Indica se a escrita foi bem-sucedida\n\n * Exemplo:\n\n\n\n\nreadJsonSync()#\n\nLê e analisa um arquivo JSON de forma síncrona.\n\n * Parâmetros:\n   \n   * filename: string - Caminho absoluto do arquivo JSON\n\n * Retorno: any - Objeto JSON analisado\n\n * Exceção: Lança uma exceção se o arquivo não existir ou se o formato JSON for\n   inválido\n\n * Exemplo:\n\n\n\n\nreadJson()#\n\nLê e analisa um arquivo JSON de forma assíncrona.\n\n * Parâmetros:\n   \n   * filename: string - Caminho absoluto do arquivo JSON\n\n * Retorno: Promise - Objeto JSON analisado\n\n * Exceção: Lança uma exceção se o arquivo não existir ou se o formato JSON for\n   inválido\n\n * Exemplo:\n\n\n\n\ngetManifestList()#\n\nObtém a lista de manifestos de construção.\n\n * Parâmetros:\n   \n   * target: RuntimeTarget - Tipo de ambiente de destino\n     * 'client': Ambiente do cliente\n     * 'server': Ambiente do servidor\n\n * Retorno: Promise - Lista de manifestos de construção somente leitura\n\n * Exceção: Lança NotReadyError se o framework não estiver inicializado\n\nEste método é usado para obter a lista de manifestos de construção para o\nambiente de destino especificado, incluindo as seguintes funcionalidades:\n\n 1. Gerenciamento de Cache\n    \n    * Usa mecanismo de cache interno para evitar carregamento repetido\n    * Retorna lista de manifestos imutável\n\n 2. Adaptação ao Ambiente\n    \n    * Suporta ambientes do cliente e do servidor\n    * Retorna informações de manifesto correspondentes ao ambiente de destino\n\n 3. Mapeamento de Módulos\n    \n    * Inclui informações de exportação de módulos\n    * Registra dependências de recursos","routePath":"/pt/api/core/gez","lang":"pt","toc":[{"text":"Introdução","id":"introdução","depth":2,"charIndex":3},{"text":"Definições de Tipos","id":"definições-de-tipos","depth":2,"charIndex":243},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":266},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":554},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":640},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":801},{"text":"COMMAND","id":"command","depth":3,"charIndex":951},{"text":"Opções de Instância","id":"opções-de-instância","depth":2,"charIndex":1401},{"text":"root","id":"root","depth":4,"charIndex":1488},{"text":"isProd","id":"isprod","depth":4,"charIndex":1699},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1878},{"text":"modules","id":"modules","depth":4,"charIndex":2163},{"text":"packs","id":"packs","depth":4,"charIndex":2358},{"text":"devApp","id":"devapp","depth":4,"charIndex":2509},{"text":"server","id":"server","depth":4,"charIndex":2735},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":2956},{"text":"Propriedades da Instância","id":"propriedades-da-instância","depth":2,"charIndex":3248},{"text":"name","id":"name","depth":3,"charIndex":3277},{"text":"varName","id":"varname","depth":3,"charIndex":3386},{"text":"root","id":"root-1","depth":3,"charIndex":3510},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3715},{"text":"basePath","id":"basepath","depth":3,"charIndex":3911},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":4170},{"text":"middleware","id":"middleware","depth":3,"charIndex":4365},{"text":"render","id":"render","depth":3,"charIndex":4734},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":5109},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":5224},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":5498},{"text":"Métodos da Instância","id":"métodos-da-instância","depth":2,"charIndex":5766},{"text":"constructor()","id":"constructor","depth":3,"charIndex":5790},{"text":"init()","id":"init","depth":3,"charIndex":5943},{"text":"destroy()","id":"destroy","depth":3,"charIndex":6624},{"text":"build()","id":"build","depth":3,"charIndex":6895},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":7896},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":8176},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":8464},{"text":"readJson()","id":"readjson","depth":3,"charIndex":8757},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":9052}],"domain":"","frontmatter":{"titleSuffix":"Referência da API das Classes Principais do Framework","description":"Detalha a API das classes principais do framework Gez, incluindo gerenciamento do ciclo de vida do aplicativo, manipulação de recursos estáticos e capacidade de renderização no lado do servidor, ajudando os desenvolvedores a entender profundamente as funcionalidades principais do framework.","head":[["meta",{"property":"keywords","content":"Gez, API, Gerenciamento do Ciclo de Vida, Recursos Estáticos, Renderização no Lado do Servidor, Rspack, Framework de Aplicação Web"}]]},"version":""},{"id":204,"title":"ManifestJson","content":"#\n\nO manifest.json é um arquivo de manifesto gerado durante o processo de\nconstrução do framework Gez, usado para registrar informações sobre os artefatos\nde construção do serviço. Ele fornece uma interface unificada para gerenciar\nartefatos de construção, arquivos exportados e estatísticas de tamanho de\nrecursos.\n\n\n\n\nDefinição de Tipos#\n\n\nManifestJson#\n\n\n\nname#\n\n * Tipo: string\n\nNome do serviço, proveniente da configuração GezOptions.name.\n\nexports#\n\n * Tipo: Record\n\nMapeamento de arquivos exportados, onde a chave é o caminho do arquivo de origem\ne o valor é o caminho do arquivo após a construção.\n\nbuildFiles#\n\n * Tipo: string[]\n\nLista completa de arquivos de artefatos de construção, contendo todos os\ncaminhos de arquivos gerados.\n\nchunks#\n\n * Tipo: Record\n\nRelação entre arquivos de origem e artefatos compilados, onde a chave é o\ncaminho do arquivo de origem e o valor são as informações de compilação.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Tipo: string\n\nCaminho do arquivo JS compilado a partir do arquivo de origem atual.\n\ncss#\n\n * Tipo: string[]\n\nLista de caminhos de arquivos CSS associados ao arquivo de origem atual.\n\nresources#\n\n * Tipo: string[]\n\nLista de caminhos de outros arquivos de recursos associados ao arquivo de origem\natual.\n\nsizes#\n\n * Tipo: ManifestJsonChunkSizes\n\nInformações de tamanho dos artefatos de construção.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Tipo: number\n\nTamanho do arquivo JS (em bytes).\n\ncss#\n\n * Tipo: number\n\nTamanho do arquivo CSS (em bytes).\n\nresource#\n\n * Tipo: number\n\nTamanho do arquivo de recurso (em bytes).","routePath":"/pt/api/core/manifest-json","lang":"pt","toc":[{"text":"Definição de Tipos","id":"definição-de-tipos","depth":2,"charIndex":319},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":358},{"text":"exports","id":"exports","depth":4,"charIndex":445},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":606},{"text":"chunks","id":"chunks","depth":4,"charIndex":742},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":917},{"text":"js","id":"js","depth":4,"charIndex":940},{"text":"css","id":"css","depth":4,"charIndex":1032},{"text":"resources","id":"resources","depth":4,"charIndex":1131},{"text":"sizes","id":"sizes","depth":4,"charIndex":1251},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1346},{"text":"js","id":"js-1","depth":4,"charIndex":1373},{"text":"css","id":"css-1","depth":4,"charIndex":1430},{"text":"resource","id":"resource","depth":4,"charIndex":1489}],"domain":"","frontmatter":{"titleSuffix":"Referência do arquivo de manifesto de construção do framework Gez","description":"Detalha a estrutura do arquivo de manifesto de construção (manifest.json) do framework Gez, incluindo gerenciamento de artefatos de construção, mapeamento de arquivos exportados e estatísticas de recursos, ajudando os desenvolvedores a entender e usar o sistema de construção.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, Manifesto de Construção, Gerenciamento de Recursos, Artefatos de Construção, Mapeamento de Arquivos, API"}]]},"version":""},{"id":205,"title":"ModuleConfig","content":"#\n\nO ModuleConfig fornece a funcionalidade de configuração de módulos do framework\nGez, usada para definir regras de importação e exportação de módulos,\nconfiguração de alias e dependências externas.\n\n\nDefinição de Tipos#\n\n\nPathType#\n\n * Definição de Tipo:\n\n\n\nEnumeração de tipos de caminho de módulo:\n\n * npm: Representa dependências no node_modules\n * root: Representa arquivos no diretório raiz do projeto\n\n\nModuleConfig#\n\n * Definição de Tipo:\n\n\n\nInterface de configuração de módulo, usada para definir a exportação, importação\ne configuração de dependências externas do serviço.\n\nexports#\n\nLista de configuração de exportação, expõe unidades de código específicas (como\ncomponentes, funções utilitárias, etc.) no serviço no formato ESM.\n\nSuporta dois tipos:\n\n * root:*: Exporta arquivos de código-fonte, por exemplo:\n   'root:src/components/button.vue'\n * npm:*: Exporta dependências de terceiros, por exemplo: 'npm:vue'\n\nimports#\n\nMapeamento de configuração de importação, configura módulos remotos que precisam\nser importados e seus caminhos locais.\n\nA configuração varia dependendo do método de instalação:\n\n * Instalação de código-fonte (Workspace, Git): Precisa apontar para o diretório\n   dist\n * Instalação de pacote (Link, servidor estático, repositório privado, File):\n   Aponta diretamente para o diretório do pacote\n\nexternals#\n\nMapeamento de dependências externas, configura dependências externas a serem\nusadas, geralmente dependências de módulos remotos.\n\nExemplo:\n\n\n\n\nParsedModuleConfig#\n\n * Definição de Tipo:\n\n\n\nConfiguração de módulo analisada, converte a configuração de módulo original em\num formato interno padronizado:\n\nname#\n\nNome do serviço atual\n\n * Usado para identificar o módulo e gerar caminhos de importação\n\nroot#\n\nCaminho do diretório raiz do serviço atual\n\n * Usado para resolver caminhos relativos e armazenar artefatos de construção\n\nexports#\n\nLista de configuração de exportação\n\n * name: Caminho de exportação original, por exemplo: 'npm:vue' ou\n   'root:src/components'\n * type: Tipo de caminho (npm ou root)\n * importName: Nome de importação, formato: '${serviceName}/${type}/${path}'\n * exportName: Caminho de exportação, relativo ao diretório raiz do serviço\n * exportPath: Caminho real do arquivo\n * externalName: Nome da dependência externa, usado como identificador quando\n   outros serviços importam este módulo\n\nimports#\n\nLista de configuração de importação\n\n * name: Nome do serviço externo\n * localPath: Caminho de armazenamento local, usado para armazenar artefatos de\n   construção de módulos externos\n\nexternals#\n\nMapeamento de dependências externas\n\n * Mapeia caminhos de importação de módulos para a localização real do módulo\n * match: Expressão regular usada para corresponder às instruções de importação\n * import: Caminho real do módulo","routePath":"/pt/api/core/module-config","lang":"pt","toc":[{"text":"Definição de Tipos","id":"definição-de-tipos","depth":2,"charIndex":201},{"text":"PathType","id":"pathtype","depth":3,"charIndex":223},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":584},{"text":"imports","id":"imports","depth":4,"charIndex":926},{"text":"externals","id":"externals","depth":4,"charIndex":1332},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1487},{"text":"name","id":"name","depth":4,"charIndex":1646},{"text":"root","id":"root","depth":4,"charIndex":1743},{"text":"exports","id":"exports-1","depth":4,"charIndex":1873},{"text":"imports","id":"imports-1","depth":4,"charIndex":2362},{"text":"externals","id":"externals-1","depth":4,"charIndex":2557}],"domain":"","frontmatter":{"titleSuffix":"Referência da API de Configuração de Módulos do Framework Gez","description":"Detalha a interface de configuração ModuleConfig do framework Gez, incluindo regras de importação e exportação de módulos, configuração de alias e gerenciamento de dependências externas, ajudando os desenvolvedores a entender profundamente o sistema modular do framework.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, configuração de módulos, importação e exportação de módulos, dependências externas, configuração de alias, gerenciamento de dependências, framework de aplicação web"}]]},"version":""},{"id":206,"title":"PackConfig","content":"#\n\nPackConfig é a interface de configuração de empacotamento de pacotes, usada para\nempacotar os artefatos de construção de um serviço no formato padrão .tgz do\nnpm.\n\n * Padronização: Utiliza o formato de empacotamento .tgz padrão do npm\n * Integridade: Inclui todos os arquivos necessários, como código-fonte do\n   módulo, declarações de tipo e arquivos de configuração\n * Compatibilidade: Totalmente compatível com o ecossistema npm, suportando\n   fluxos de trabalho padrão de gerenciamento de pacotes\n\n\nDefinição de Tipo#\n\n\n\n\nPackConfig#\n\nenable#\n\nHabilita ou desabilita a funcionalidade de empacotamento. Quando habilitado, os\nartefatos de construção são empacotados no formato padrão .tgz do npm.\n\n * Tipo: boolean\n * Valor padrão: false\n\noutputs#\n\nEspecifica o caminho de saída do arquivo do pacote. Suporta as seguintes\nconfigurações:\n\n * string: Um único caminho de saída, por exemplo, 'dist/versions/my-app.tgz'\n * string[]: Múltiplos caminhos de saída, usados para gerar várias versões\n   simultaneamente\n * boolean: Quando true, usa o caminho padrão 'dist/client/versions/latest.tgz'\n\npackageJson#\n\nFunção de callback para personalizar o conteúdo do package.json. Chamada antes\ndo empacotamento, usada para personalizar o conteúdo do package.json.\n\n * Parâmetros:\n   * gez: Gez - Instância do Gez\n   * pkg: any - Conteúdo original do package.json\n * Retorno: Promise - Conteúdo modificado do package.json\n\nUsos comuns:\n\n * Modificar o nome e a versão do pacote\n * Adicionar ou atualizar dependências\n * Adicionar campos personalizados\n * Configurar informações de publicação\n\nExemplo:\n\n\n\nonBefore#\n\nFunção de callback para preparação antes do empacotamento.\n\n * Parâmetros:\n   * gez: Gez - Instância do Gez\n   * pkg: Record - Conteúdo do package.json\n * Retorno: Promise\n\nUsos comuns:\n\n * Adicionar arquivos adicionais (README, LICENSE, etc.)\n * Executar testes ou validações de construção\n * Gerar documentação ou metadados\n * Limpar arquivos temporários\n\nExemplo:\n\n\n\nonAfter#\n\nFunção de callback para processamento após o empacotamento. Chamada após a\ngeração do arquivo .tgz, usada para processar os artefatos de empacotamento.\n\n * Parâmetros:\n   * gez: Gez - Instância do Gez\n   * pkg: Record - Conteúdo do package.json\n   * file: Buffer - Conteúdo do arquivo empacotado\n * Retorno: Promise\n\nUsos comuns:\n\n * Publicar no repositório npm (público ou privado)\n * Fazer upload para um servidor de recursos estáticos\n * Gerenciar versões\n * Disparar fluxos de CI/CD\n\nExemplo:\n\n\n\n\nExemplo de Uso#\n\n","routePath":"/pt/api/core/pack-config","lang":"pt","toc":[{"text":"Definição de Tipo","id":"definição-de-tipo","depth":2,"charIndex":505},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":541},{"text":"outputs","id":"outputs","depth":4,"charIndex":743},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":1095},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1598},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1979},{"text":"Exemplo de Uso","id":"exemplo-de-uso","depth":2,"charIndex":2490}],"domain":"","frontmatter":{"titleSuffix":"Referência da API de Configuração de Empacotamento do Framework Gez","description":"Detalha a interface de configuração PackConfig do framework Gez, incluindo regras de empacotamento de pacotes, configuração de saída e ganchos de ciclo de vida, ajudando os desenvolvedores a implementar fluxos de construção padronizados.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, empacotamento de pacotes, configuração de construção, ganchos de ciclo de vida, configuração de empacotamento, framework de aplicação web"}]]},"version":""},{"id":207,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pt/api/core/render-context","lang":"pt","toc":[{"text":"Definições de Tipo","id":"definições-de-tipo","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Opções de Instância","id":"opções-de-instância","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Propriedades da Instância","id":"propriedades-da-instância","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Métodos da Instância","id":"métodos-da-instância","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1},{"text":"importmap()","id":"importmap","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Referência da API de Contexto de Renderização do Framework Gez","description":"Detalhes sobre a classe principal RenderContext do framework Gez, incluindo controle de renderização, gerenciamento de recursos, sincronização de estado e controle de roteamento, ajudando desenvolvedores a implementar renderização no lado do servidor (SSR) de forma eficiente.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, Renderização no lado do servidor, Contexto de renderização, Sincronização de estado, Gerenciamento de recursos, Framework de aplicação web"}]]},"version":""},{"id":208,"title":"Do compartilhamento de componentes à modularização nativa: A jornada de evolução do framework Gez de micro frontend","content":"Do compartilhamento de componentes à modularização nativa: A jornada de evolução\ndo framework Gez de micro frontend#\n\n\nContexto do Projeto#\n\nNos últimos anos, a arquitetura de micro frontend tem buscado um caminho\ncorreto. No entanto, o que vemos são várias soluções técnicas complexas que usam\ncamadas de encapsulamento e isolamento artificial para simular um mundo ideal de\nmicro frontend. Essas soluções trazem um pesado custo de desempenho, tornando o\ndesenvolvimento simples em algo complexo e os processos padrão em algo obscuro.\n\n\nLimitações das Soluções Tradicionais#\n\nNa prática da arquitetura de micro frontend, percebemos profundamente as várias\nlimitações das soluções tradicionais:\n\n * Perda de desempenho: Injeção de dependências em tempo de execução, proxy de\n   sandbox JS, cada operação consome um desempenho precioso\n * Isolamento frágil: Ambientes de sandbox criados artificialmente nunca\n   alcançam a capacidade de isolamento nativo do navegador\n * Complexidade de construção: Para lidar com as dependências, é necessário\n   modificar as ferramentas de construção, tornando projetos simples difíceis de\n   manter\n * Regras personalizadas: Estratégias de implantação especiais, processamento em\n   tempo de execução, cada passo se desvia do fluxo padrão de desenvolvimento\n   moderno\n * Limitações do ecossistema: Acoplamento de frameworks, APIs personalizadas,\n   limitando a escolha de tecnologias a ecossistemas específicos\n\nEsses problemas foram particularmente evidentes em um projeto corporativo de\ngrande escala em 2019. Na época, um grande produto foi dividido em mais de dez\nsubsistemas de negócios independentes, que precisavam compartilhar um conjunto\nde componentes básicos e de negócios. A solução inicial de compartilhamento de\ncomponentes baseada em pacotes npm revelou sérios problemas de eficiência de\nmanutenção: quando um componente compartilhado era atualizado, todos os\nsubsistemas que dependiam dele precisavam passar por um processo completo de\nconstrução e implantação.\n\n\nEvolução Técnica#\n\n\nv1.0: Explorando Componentes Remotos#\n\nPara resolver o problema de eficiência no compartilhamento de componentes, o Gez\nv1.0 introduziu o mecanismo de componente RemoteView baseado no protocolo HTTP.\nEssa solução implementou a montagem de código sob demanda entre serviços por\nmeio de solicitações dinâmicas em tempo de execução, resolvendo com sucesso o\nproblema da cadeia de dependências de construção excessivamente longa. No\nentanto, devido à falta de um mecanismo padronizado de comunicação em tempo de\nexecução, a sincronização de estado e a passagem de eventos entre serviços ainda\napresentavam gargalos de eficiência.\n\n\nv2.0: Tentativa de Module Federation#\n\nNa versão v2.0, adotamos a tecnologia Module Federation do Webpack 5.0. Essa\ntecnologia, por meio de um mecanismo unificado de carregamento de módulos e\ncontêineres de tempo de execução, melhorou significativamente a eficiência de\ncolaboração entre serviços. No entanto, em práticas em larga escala, o mecanismo\nfechado de implementação do Module Federation trouxe novos desafios: dificuldade\nem gerenciar versões de dependências com precisão, especialmente ao unificar\ndependências compartilhadas entre vários serviços, frequentemente enfrentando\nconflitos de versão e exceções em tempo de execução.\n\n\nAbraçando a Nova Era do ESM#\n\nAo planejar a versão v3.0, observamos profundamente as tendências de\ndesenvolvimento do ecossistema frontend e descobrimos que os avanços nas\ncapacidades nativas do navegador trouxeram novas possibilidades para a\narquitetura de micro frontend:\n\n\nSistema de Módulos Padronizado#\n\nCom o suporte completo dos principais navegadores aos ES Modules e a maturidade\nda especificação Import Maps, o desenvolvimento frontend entrou em uma era\nverdadeiramente modular. De acordo com as estatísticas do Can I Use, a taxa de\nsuporte nativo ao ESM nos principais navegadores (Chrome >= 89, Edge >= 89,\nFirefox >= 108, Safari >= 16.4) atingiu 93,5%, o que nos proporcionou as\nseguintes vantagens:\n\n * Gerenciamento de dependências padronizado: Import Maps oferece a capacidade\n   de resolver dependências de módulos no nível do navegador, sem a necessidade\n   de injeção complexa em tempo de execução\n * Otimização de carregamento de recursos: O mecanismo de cache de módulos\n   nativo do navegador melhora significativamente a eficiência de carregamento\n   de recursos\n * Simplificação do fluxo de construção: O modo de desenvolvimento baseado em\n   ESM torna o fluxo de construção entre ambientes de desenvolvimento e produção\n   mais consistente\n\nAlém disso, com o suporte ao modo de compatibilidade (Chrome >= 87, Edge >= 88,\nFirefox >= 78, Safari >= 14), podemos aumentar ainda mais a cobertura de\nnavegadores para 96,81%, permitindo que mantenhamos alto desempenho sem\nsacrificar o suporte a navegadores antigos.\n\n\nAvanços em Desempenho e Isolamento#\n\nO sistema de módulos nativo trouxe não apenas padronização, mas também melhorias\nsignificativas em desempenho e isolamento:\n\n * Zero custo de tempo de execução: Eliminamos o proxy de sandbox JavaScript e a\n   injeção em tempo de execução das soluções tradicionais de micro frontend\n * Mecanismo de isolamento confiável: O escopo estrito de módulos do ESM fornece\n   naturalmente a capacidade de isolamento mais confiável\n * Gerenciamento preciso de dependências: A análise estática de importações\n   torna as relações de dependência mais claras e o controle de versão mais\n   preciso\n\n\nEscolha da Ferramenta de Construção#\n\nNa implementação da solução técnica, a escolha da ferramenta de construção foi\num ponto de decisão crucial. Após quase um ano de pesquisa e prática técnica,\nnossa escolha passou pela seguinte evolução:\n\n 1. Exploração do Vite\n    \n    * Vantagem: Servidor de desenvolvimento baseado em ESM, proporcionando uma\n      experiência de desenvolvimento excepcional\n    * Desafio: As diferenças de construção entre ambientes de desenvolvimento e\n      produção trouxeram certa incerteza\n\n 2. Estabelecimento do Rspack\n    \n    * Vantagem de desempenho: Compilação de alta performance baseada em Rust,\n      melhorando significativamente a velocidade de construção\n    * Suporte ao ecossistema: Alta compatibilidade com o ecossistema Webpack,\n      reduzindo o custo de migração\n    * Suporte ao ESM: Através da prática do projeto Rslib, validamos sua\n      confiabilidade na construção com ESM\n\nEssa decisão nos permitiu manter a experiência de desenvolvimento enquanto\nobtínhamos suporte mais estável para o ambiente de produção. Com a combinação de\nESM e Rspack, finalmente construímos uma solução de micro frontend de alta\nperformance e baixa intrusividade.\n\n\nPerspectivas Futuras#\n\nNo planejamento futuro, o framework Gez focará em três direções principais:\n\n\nOtimização Profunda do Import Maps#\n\n * Gerenciamento dinâmico de dependências: Implementar agendamento inteligente\n   de versões de dependências em tempo de execução, resolvendo conflitos de\n   dependências entre múltiplas aplicações\n * Estratégia de pré-carregamento: Pré-carregamento inteligente baseado em\n   análise de rotas, melhorando a eficiência de carregamento de recursos\n * Otimização de construção: Gerar automaticamente a configuração ótima do\n   Import Maps, reduzindo o custo de configuração manual dos desenvolvedores\n\n\nSolução de Rota Independente de Framework#\n\n * Abstração unificada de rotas: Projetar uma interface de rota independente de\n   framework, suportando Vue, React e outros frameworks principais\n * Roteamento de micro aplicações: Implementar interligação de rotas entre\n   aplicações, mantendo a consistência entre URL e estado da aplicação\n * Middleware de rota: Fornecer um mecanismo de middleware extensível,\n   suportando controle de acesso, transições de página, etc.\n\n\nMelhores Práticas de Comunicação entre Frameworks#\n\n * Aplicação de exemplo: Fornecer um exemplo completo de comunicação entre\n   frameworks, cobrindo Vue, React, Preact e outros frameworks principais\n * Sincronização de estado: Solução leve de compartilhamento de estado baseada\n   em ESM\n * Barramento de eventos: Mecanismo padronizado de comunicação por eventos,\n   suportando comunicação desacoplada entre aplicações\n\nCom essas otimizações e expansões, esperamos tornar o Gez uma solução de micro\nfrontend mais completa e fácil de usar, proporcionando aos desenvolvedores uma\nmelhor experiência de desenvolvimento e maior eficiência.","routePath":"/pt/blog/birth-of-gez","lang":"pt","toc":[{"text":"Contexto do Projeto","id":"contexto-do-projeto","depth":2,"charIndex":118},{"text":"Limitações das Soluções Tradicionais","id":"limitações-das-soluções-tradicionais","depth":3,"charIndex":537},{"text":"Evolução Técnica","id":"evolução-técnica","depth":2,"charIndex":2015},{"text":"v1.0: Explorando Componentes Remotos","id":"v10-explorando-componentes-remotos","depth":3,"charIndex":2035},{"text":"v2.0: Tentativa de Module Federation","id":"v20-tentativa-de-module-federation","depth":3,"charIndex":2663},{"text":"Abraçando a Nova Era do ESM","id":"abraçando-a-nova-era-do-esm","depth":2,"charIndex":3305},{"text":"Sistema de Módulos Padronizado","id":"sistema-de-módulos-padronizado","depth":3,"charIndex":3581},{"text":"Avanços em Desempenho e Isolamento","id":"avanços-em-desempenho-e-isolamento","depth":3,"charIndex":4842},{"text":"Escolha da Ferramenta de Construção","id":"escolha-da-ferramenta-de-construção","depth":3,"charIndex":5465},{"text":"Perspectivas Futuras","id":"perspectivas-futuras","depth":2,"charIndex":6659},{"text":"Otimização Profunda do Import Maps","id":"otimização-profunda-do-import-maps","depth":3,"charIndex":6760},{"text":"Solução de Rota Independente de Framework","id":"solução-de-rota-independente-de-framework","depth":3,"charIndex":7297},{"text":"Melhores Práticas de Comunicação entre Frameworks","id":"melhores-práticas-de-comunicação-entre-frameworks","depth":3,"charIndex":7768}],"domain":"","frontmatter":{"titleSuffix":"Do dilema do micro frontend à inovação do ESM: A jornada de evolução do framework Gez","description":"Explore em profundidade a evolução do framework Gez, desde os desafios da arquitetura tradicional de micro frontend até as inovações baseadas em ESM, compartilhando práticas técnicas em otimização de desempenho, gerenciamento de dependências e seleção de ferramentas de construção.","head":[["meta",{"property":"keywords","content":"Gez, framework de micro frontend, ESM, Import Maps, Rspack, Module Federation, gerenciamento de dependências, otimização de desempenho, evolução técnica, renderização no lado do servidor"}]],"sidebar":false},"version":""},{"id":209,"title":"Blog da Equipe","content":"#\n\nBem-vindo ao blog técnico da equipe Gez! Aqui, compartilharemos experiências do\nprocesso de desenvolvimento de frameworks, inovações tecnológicas e melhores\npráticas.\n\n\nArtigos Recentes#\n\n * 2025-02-25 Do Compartilhamento de Componentes à Modularização Nativa: A\n   Evolução do Framework de Micro Frontends Gez\n   \n   > Explore a jornada de evolução do framework Gez, desde o compartilhamento\n   > tradicional de componentes até a modularização nativa baseada em ESM.\n   > Compartilhamos práticas técnicas em otimização de desempenho, gerenciamento\n   > de dependências e seleção de ferramentas de construção.","routePath":"/pt/blog/","lang":"pt","toc":[{"text":"Artigos Recentes","id":"artigos-recentes","depth":2,"charIndex":171}],"domain":"","frontmatter":{"titleSuffix":"Blog da Equipe Gez","description":"Blog técnico da equipe Gez, compartilhando experiências de desenvolvimento de frameworks, melhores práticas e inovações tecnológicas.","head":[["meta",{"property":"keywords","content":"Gez, Blog da Equipe, Compartilhamento Técnico, Melhores Práticas, Experiência de Desenvolvimento"}]],"sidebar":false},"version":""},{"id":210,"title":"Alias de Caminho","content":"#\n\nO alias de caminho (Path Alias) é um mecanismo de mapeamento de caminhos de\nimportação de módulos que permite aos desenvolvedores usar identificadores\ncurtos e semânticos no lugar de caminhos completos de módulos. No Gez, o\nmecanismo de alias de caminho oferece as seguintes vantagens:\n\n * Simplificação de caminhos de importação: Uso de aliases semânticos no lugar\n   de caminhos relativos longos, melhorando a legibilidade do código\n * Prevenção de aninhamento profundo: Elimina dificuldades de manutenção\n   causadas por referências de diretórios com múltiplos níveis (como\n   ../../../../)\n * Segurança de tipos: Totalmente integrado ao sistema de tipos do TypeScript,\n   fornecendo autocompletar e verificação de tipos\n * Otimização de resolução de módulos: Melhora o desempenho da resolução de\n   módulos através de mapeamentos de caminhos pré-definidos\n\n\nMecanismo de Alias Padrão#\n\nO Gez adota um mecanismo de alias automático baseado no nome do serviço (Service\nName), com um design que prioriza convenções em vez de configurações,\napresentando as seguintes características:\n\n * Configuração automática: Gera aliases automaticamente com base no campo name\n   do package.json, sem necessidade de configuração manual\n * Padronização unificada: Garante que todos os módulos de serviço sigam uma\n   convenção consistente de nomenclatura e referência\n * Suporte a tipos: Em conjunto com o comando npm run build:dts, gera\n   automaticamente arquivos de declaração de tipos, permitindo inferência de\n   tipos entre serviços\n * Previsibilidade: Permite inferir o caminho de referência do módulo a partir\n   do nome do serviço, reduzindo custos de manutenção\n\n\nConfiguração#\n\n\nConfiguração do package.json#\n\nNo package.json, o nome do serviço é definido pelo campo name, que servirá como\nprefixo padrão para o alias do serviço:\n\n\n\n\nConfiguração do tsconfig.json#\n\nPara que o TypeScript possa resolver corretamente os caminhos de alias, é\nnecessário configurar o mapeamento paths no tsconfig.json:\n\n\n\n\nExemplos de Uso#\n\n\nImportação de Módulos Internos do Serviço#\n\n\n\n\nImportação de Módulos de Outros Serviços#\n\n\n\nBoas Práticas\n * Priorize o uso de caminhos de alias em vez de caminhos relativos\n * Mantenha os caminhos de alias semânticos e consistentes\n * Evite o uso excessivo de níveis de diretórios em caminhos de alias\n\n\n\n\nImportação entre Serviços#\n\nApós configurar o link de módulos (Module Link), é possível importar módulos de\noutros serviços da mesma forma:\n\n\n\n\nAlias Personalizados#\n\nPara pacotes de terceiros ou cenários específicos, é possível definir aliases\npersonalizados através do arquivo de configuração do Gez:\n\n\n\nConsiderações\n 1. Para módulos de negócios, recomenda-se sempre usar o mecanismo de alias\n    padrão para manter a consistência do projeto\n 2. Aliases personalizados são principalmente usados para tratar necessidades\n    específicas de pacotes de terceiros ou otimizar a experiência de\n    desenvolvimento\n 3. O uso excessivo de aliases personalizados pode prejudicar a manutenibilidade\n    do código e a otimização de builds","routePath":"/pt/guide/essentials/alias","lang":"pt","toc":[{"text":"Mecanismo de Alias Padrão","id":"mecanismo-de-alias-padrão","depth":2,"charIndex":864},{"text":"Configuração","id":"configuração","depth":2,"charIndex":1663},{"text":"Configuração do package.json","id":"configuração-do-packagejson","depth":3,"charIndex":1679},{"text":"Configuração do tsconfig.json","id":"configuração-do-tsconfigjson","depth":3,"charIndex":1834},{"text":"Exemplos de Uso","id":"exemplos-de-uso","depth":2,"charIndex":2003},{"text":"Importação de Módulos Internos do Serviço","id":"importação-de-módulos-internos-do-serviço","depth":3,"charIndex":2022},{"text":"Importação de Módulos de Outros Serviços","id":"importação-de-módulos-de-outros-serviços","depth":3,"charIndex":2069},{"text":"Importação entre Serviços","id":"importação-entre-serviços","depth":3,"charIndex":2329},{"text":"Alias Personalizados","id":"alias-personalizados","depth":3,"charIndex":2473}],"domain":"","frontmatter":{"titleSuffix":"Guia de Mapeamento de Caminhos de Importação de Módulos do Framework Gez","description":"Detalha o mecanismo de alias de caminhos do framework Gez, incluindo simplificação de caminhos de importação, prevenção de aninhamento profundo, segurança de tipos e otimização de resolução de módulos, ajudando desenvolvedores a melhorar a manutenibilidade do código.","head":[["meta",{"property":"keywords","content":"Gez, Alias de Caminho, Path Alias, TypeScript, Importação de Módulos, Mapeamento de Caminhos, Manutenibilidade de Código"}]]},"version":""},{"id":211,"title":"Caminho Base","content":"#\n\nO caminho base (Base Path) refere-se ao prefixo do caminho de acesso aos\nrecursos estáticos (como JavaScript, CSS, imagens, etc.) em uma aplicação. No\nGez, a configuração adequada do caminho base é crucial para os seguintes\ncenários:\n\n * Implantação em Múltiplos Ambientes: Suporta o acesso a recursos em diferentes\n   ambientes, como desenvolvimento, teste e produção\n * Implantação em Múltiplas Regiões: Adapta-se às necessidades de implantação em\n   clusters de diferentes regiões ou países\n * Distribuição CDN: Permite a distribuição global e aceleração de recursos\n   estáticos\n\n\nMecanismo de Caminho Padrão#\n\nO Gez utiliza um mecanismo de geração automática de caminho baseado no nome do\nserviço. Por padrão, o framework lê o campo name do arquivo package.json do\nprojeto para gerar o caminho base dos recursos estáticos: /your-app-name/.\n\n\n\nEste design de convenção sobre configuração oferece as seguintes vantagens:\n\n * Consistência: Garante que todos os recursos estáticos usem um caminho de\n   acesso unificado\n * Previsibilidade: O caminho de acesso aos recursos pode ser inferido\n   diretamente pelo campo name do package.json\n * Manutenibilidade: Elimina a necessidade de configurações adicionais,\n   reduzindo custos de manutenção\n\n\nConfiguração Dinâmica de Caminho#\n\nEm projetos reais, frequentemente precisamos implantar o mesmo código em\ndiferentes ambientes ou regiões. O Gez oferece suporte a caminhos base\ndinâmicos, permitindo que a aplicação se adapte a diferentes cenários de\nimplantação.\n\n\nCenários de Uso#\n\nImplantação em Subdiretório#\n\n\n\nImplantação em Domínios Independentes#\n\n\n\n\nMétodo de Configuração#\n\nAtravés do parâmetro base do método gez.render(), você pode definir\ndinamicamente o caminho base de acordo com o contexto da requisição:\n\n","routePath":"/pt/guide/essentials/base-path","lang":"pt","toc":[{"text":"Mecanismo de Caminho Padrão","id":"mecanismo-de-caminho-padrão","depth":2,"charIndex":587},{"text":"Configuração Dinâmica de Caminho","id":"configuração-dinâmica-de-caminho","depth":2,"charIndex":1249},{"text":"Cenários de Uso","id":"cenários-de-uso","depth":3,"charIndex":1516},{"text":"Implantação em Subdiretório","id":"implantação-em-subdiretório","depth":4,"charIndex":1534},{"text":"Implantação em Domínios Independentes","id":"implantação-em-domínios-independentes","depth":4,"charIndex":1566},{"text":"Método de Configuração","id":"método-de-configuração","depth":3,"charIndex":1609}],"domain":"","frontmatter":{"titleSuffix":"Guia de Configuração de Caminho de Recursos Estáticos do Framework Gez","description":"Detalha a configuração do caminho base no framework Gez, incluindo implantação em múltiplos ambientes, distribuição CDN e configuração de caminhos de acesso a recursos, ajudando desenvolvedores a gerenciar recursos estáticos de forma flexível.","head":[["meta",{"property":"keywords","content":"Gez, Caminho Base, Base Path, CDN, Recursos Estáticos, Implantação em Múltiplos Ambientes, Gerenciamento de Recursos"}]]},"version":""},{"id":212,"title":"Renderização no Cliente","content":"\n${rc.importmap()} // Mapeamento de importação ${rc.moduleEntry()} // Módulo de\nentrada ${rc.modulePreload()} // Pré-carregamento de módulos","routePath":"/pt/guide/essentials/csr","lang":"pt","toc":[{"text":"Cenários de Uso","id":"cenários-de-uso","depth":2,"charIndex":-1},{"text":"Configuração","id":"configuração","depth":2,"charIndex":-1},{"text":"Configuração do Modelo HTML","id":"configuração-do-modelo-html","depth":3,"charIndex":-1},{"text":"Geração de HTML Estático","id":"geração-de-html-estático","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Guia de Implementação de Renderização no Cliente do Framework Gez","description":"Detalha o mecanismo de renderização no cliente do framework Gez, incluindo construção estática, estratégias de implantação e melhores práticas, ajudando desenvolvedores a alcançar renderização front-end eficiente em ambientes sem servidor.","head":[["meta",{"property":"keywords","content":"Gez, Renderização no Cliente, CSR, Construção Estática, Renderização Front-end, Implantação sem Servidor, Otimização de Desempenho"}]]},"version":""},{"id":213,"title":"Vinculação de Módulos","content":"#\n\nO framework Gez fornece um mecanismo completo de vinculação de módulos para\ngerenciar o compartilhamento de código e as dependências entre serviços. Este\nmecanismo é implementado com base na especificação ESM (ECMAScript Module),\nsuportando a exportação e importação de módulos em nível de código-fonte, bem\ncomo funcionalidades completas de gerenciamento de dependências.\n\n\nConceitos Principais#\n\nExportação de Módulos#\n\nA exportação de módulos é o processo de expor unidades de código específicas\n(como componentes, funções utilitárias, etc.) de um serviço no formato ESM. São\nsuportados dois tipos de exportação:\n\n * Exportação de Código-Fonte: Exporta diretamente arquivos de código-fonte do\n   projeto\n * Exportação de Dependências: Exporta pacotes de dependências de terceiros\n   usados pelo projeto\n\nImportação de Módulos#\n\nA importação de módulos é o processo de referenciar unidades de código\nexportadas por outros serviços em um serviço. São suportados vários métodos de\ninstalação:\n\n * Instalação de Código-Fonte: Adequado para ambientes de desenvolvimento,\n   suporta modificações em tempo real e atualização a quente (hot update)\n * Instalação de Pacotes: Adequado para ambientes de produção, utiliza\n   diretamente os artefatos de construção\n\n\nMecanismo de Pré-carregamento#\n\nPara otimizar o desempenho dos serviços, o Gez implementa um mecanismo\ninteligente de pré-carregamento de módulos:\n\n 1. Análise de Dependências\n    \n    * Analisa as dependências entre componentes durante a construção\n    * Identifica os módulos principais no caminho crítico\n    * Determina a prioridade de carregamento dos módulos\n\n 2. Estratégia de Carregamento\n    \n    * Carregamento Imediato: Módulos principais no caminho crítico\n    * Carregamento Atrasado: Módulos de funcionalidades não críticas\n    * Carregamento Sob Demanda: Módulos renderizados condicionalmente\n\n 3. Otimização de Recursos\n    \n    * Estratégia inteligente de divisão de código (code splitting)\n    * Gerenciamento de cache em nível de módulo\n    * Compilação e empacotamento sob demanda\n\n\nExportação de Módulos#\n\n\nConfiguração#\n\nConfigure os módulos a serem exportados em entry.node.ts:\n\n\n\nA configuração de exportação suporta dois tipos:\n\n * root:*: Exporta arquivos de código-fonte, com caminho relativo ao diretório\n   raiz do projeto\n * npm:*: Exporta dependências de terceiros, especificando diretamente o nome do\n   pacote\n\n\nImportação de Módulos#\n\n\nConfiguração#\n\nConfigure os módulos a serem importados em entry.node.ts:\n\n\n\nExplicação dos itens de configuração:\n\n 1. imports: Configura o caminho local dos módulos remotos\n    \n    * Instalação de código-fonte: aponta para o diretório de artefatos de\n      construção (dist)\n    * Instalação de pacotes: aponta diretamente para o diretório do pacote\n\n 2. externals: Configura dependências externas\n    \n    * Usado para compartilhar dependências de módulos remotos\n    * Evita empacotamento repetido das mesmas dependências\n    * Suporta compartilhamento de dependências entre vários módulos\n\n\nMétodos de Instalação#\n\nInstalação de Código-Fonte#\n\nAdequado para ambientes de desenvolvimento, suporta modificações em tempo real e\natualização a quente.\n\n 1. Modo Workspace Recomendado para uso em projetos Monorepo:\n\n\n\n 2. Modo Link Usado para depuração local:\n\n\n\nInstalação de Pacotes#\n\nAdequado para ambientes de produção, utiliza diretamente os artefatos de\nconstrução.\n\n 1. Registro NPM Instalação via registro npm:\n\n\n\n 2. Servidor Estático Instalação via protocolo HTTP/HTTPS:\n\n\n\n\nConstrução de Pacotes#\n\n\nConfiguração#\n\nConfigure as opções de construção em entry.node.ts:\n\n\n\n\nArtefatos de Construção#\n\n\n\n\nFluxo de Publicação#\n\n\n\n\nMelhores Práticas#\n\n\nConfiguração de Ambiente de Desenvolvimento#\n\n * Gerenciamento de Dependências\n   \n   * Usar modo Workspace ou Link para instalar dependências\n   * Gerenciar versões de dependências de forma unificada\n   * Evitar instalação repetida das mesmas dependências\n\n * Experiência de Desenvolvimento\n   \n   * Habilitar funcionalidade de atualização a quente\n   * Configurar estratégia de pré-carregamento adequada\n   * Otimizar velocidade de construção\n\n\nConfiguração de Ambiente de Produção#\n\n * Estratégia de Implantação\n   \n   * Usar registro npm ou servidor estático\n   * Garantir integridade dos artefatos de construção\n   * Implementar mecanismo de lançamento gradual (gray release)\n\n * Otimização de Desempenho\n   \n   * Configurar pré-carregamento de recursos de forma adequada\n   * Otimizar ordem de carregamento de módulos\n   * Implementar estratégia de cache eficaz\n\n\nGerenciamento de Versões#\n\n * Padrão de Versões\n   \n   * Seguir a especificação de versionamento semântico\n   * Manter registro detalhado de alterações\n   * Realizar testes de compatibilidade de versões\n\n * Atualização de Dependências\n   \n   * Atualizar pacotes de dependências regularmente\n   * Realizar auditorias de segurança periodicamente\n   * Manter consistência de versões de dependências","routePath":"/pt/guide/essentials/module-link","lang":"pt","toc":[{"text":"Conceitos Principais","id":"conceitos-principais","depth":3,"charIndex":377},{"text":"Exportação de Módulos","id":"exportação-de-módulos","depth":4,"charIndex":400},{"text":"Importação de Módulos","id":"importação-de-módulos","depth":4,"charIndex":809},{"text":"Mecanismo de Pré-carregamento","id":"mecanismo-de-pré-carregamento","depth":3,"charIndex":1260},{"text":"Exportação de Módulos","id":"exportação-de-módulos-1","depth":2,"charIndex":2063},{"text":"Configuração","id":"configuração","depth":3,"charIndex":2088},{"text":"Importação de Módulos","id":"importação-de-módulos-1","depth":2,"charIndex":2405},{"text":"Configuração","id":"configuração-1","depth":3,"charIndex":2430},{"text":"Métodos de Instalação","id":"métodos-de-instalação","depth":3,"charIndex":3026},{"text":"Instalação de Código-Fonte","id":"instalação-de-código-fonte","depth":4,"charIndex":3050},{"text":"Instalação de Pacotes","id":"instalação-de-pacotes","depth":4,"charIndex":3293},{"text":"Construção de Pacotes","id":"construção-de-pacotes","depth":2,"charIndex":3515},{"text":"Configuração","id":"configuração-2","depth":3,"charIndex":3540},{"text":"Artefatos de Construção","id":"artefatos-de-construção","depth":3,"charIndex":3611},{"text":"Fluxo de Publicação","id":"fluxo-de-publicação","depth":3,"charIndex":3640},{"text":"Melhores Práticas","id":"melhores-práticas","depth":2,"charIndex":3665},{"text":"Configuração de Ambiente de Desenvolvimento","id":"configuração-de-ambiente-de-desenvolvimento","depth":3,"charIndex":3686},{"text":"Configuração de Ambiente de Produção","id":"configuração-de-ambiente-de-produção","depth":3,"charIndex":4133},{"text":"Gerenciamento de Versões","id":"gerenciamento-de-versões","depth":3,"charIndex":4556}],"domain":"","frontmatter":{"titleSuffix":"Mecanismo de Compartilhamento de Código entre Serviços do Framework Gez","description":"Detalha o mecanismo de vinculação de módulos do framework Gez, incluindo compartilhamento de código entre serviços, gerenciamento de dependências e implementação da especificação ESM, ajudando desenvolvedores a construir aplicações de micro front-end eficientes.","head":[["meta",{"property":"keywords","content":"Gez, Vinculação de Módulos, Module Link, ESM, Compartilhamento de Código, Gerenciamento de Dependências, Micro Front-end"}]]},"version":""},{"id":214,"title":"Contexto de Renderização","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pt/guide/essentials/render-context","lang":"pt","toc":[{"text":"Modo de Uso","id":"modo-de-uso","depth":2,"charIndex":-1},{"text":"Funcionalidades Principais","id":"funcionalidades-principais","depth":2,"charIndex":-1},{"text":"Coleta de Dependências","id":"coleta-de-dependências","depth":3,"charIndex":-1},{"text":"Coleta Sob Demanda","id":"coleta-sob-demanda","depth":4,"charIndex":-1},{"text":"Processamento Automatizado","id":"processamento-automatizado","depth":4,"charIndex":-1},{"text":"Otimização de Desempenho","id":"otimização-de-desempenho","depth":4,"charIndex":-1},{"text":"Injeção de Recursos","id":"injeção-de-recursos","depth":3,"charIndex":-1},{"text":"Ordem de Injeção de Recursos","id":"ordem-de-injeção-de-recursos","depth":3,"charIndex":-1},{"text":"Fluxo Completo de Renderização","id":"fluxo-completo-de-renderização","depth":2,"charIndex":-1},{"text":"Recursos Avançados","id":"recursos-avançados","depth":2,"charIndex":-1},{"text":"Configuração de Caminho Base","id":"configuração-de-caminho-base","depth":3,"charIndex":-1},{"text":"Modos de Mapeamento de Importação","id":"modos-de-mapeamento-de-importação","depth":3,"charIndex":-1},{"text":"Configuração de Função de Entrada","id":"configuração-de-função-de-entrada","depth":3,"charIndex":-1},{"text":"Melhores Práticas","id":"melhores-práticas","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Mecanismo de Renderização no Lado do Servidor do Framework Gez","description":"Detalhes sobre o mecanismo de contexto de renderização (RenderContext) do framework Gez, incluindo gerenciamento de recursos, geração de HTML e sistema de módulos ESM, para ajudar desenvolvedores a entender e utilizar a funcionalidade de renderização no lado do servidor (SSR).","head":[["meta",{"property":"keywords","content":"Gez, contexto de renderização, RenderContext, SSR, renderização no lado do servidor, ESM, gerenciamento de recursos"}]]},"version":""},{"id":215,"title":"Rspack","content":"#\n\nO Gez é construído com base no sistema de build Rspack, aproveitando ao máximo a\ncapacidade de build de alto desempenho do Rspack. Este documento apresenta o\nposicionamento e as funcionalidades principais do Rspack no framework Gez.\n\n\nFuncionalidades#\n\nO Rspack é o sistema de build central do framework Gez, oferecendo as seguintes\nfuncionalidades-chave:\n\n * Build de Alto Desempenho: Motor de build implementado em Rust, proporcionando\n   velocidade de compilação extremamente rápida, melhorando significativamente a\n   velocidade de build em projetos grandes.\n * Otimização da Experiência de Desenvolvimento: Suporte a atualização a quente\n   (HMR), compilação incremental e outras funcionalidades modernas de\n   desenvolvimento, proporcionando uma experiência de desenvolvimento fluida.\n * Build para Múltiplos Ambientes: Configuração de build unificada para\n   ambientes de cliente (client), servidor (server) e Node.js (node),\n   simplificando o fluxo de desenvolvimento multiplataforma.\n * Otimização de Recursos: Capacidade integrada de processamento e otimização de\n   recursos, com suporte a divisão de código, Tree Shaking, compressão de\n   recursos, entre outros.\n\n\nConstruindo Aplicações#\n\nO sistema de build Rspack do Gez é projetado de forma modular, contendo\nprincipalmente os seguintes módulos centrais:\n\n\n@gez/rspack#\n\nMódulo de build básico, oferecendo as seguintes capacidades principais:\n\n * Configuração de Build Unificada: Gerenciamento padronizado de configurações\n   de build, com suporte a configurações para múltiplos ambientes.\n * Processamento de Recursos: Capacidade integrada de processamento de recursos\n   como TypeScript, CSS, imagens, etc.\n * Otimização de Build: Oferece funcionalidades de otimização de desempenho,\n   como divisão de código e Tree Shaking.\n * Servidor de Desenvolvimento: Integra um servidor de desenvolvimento de alto\n   desempenho, com suporte a HMR.\n\n\n@gez/rspack-vue#\n\nMódulo de build específico para o framework Vue, oferecendo:\n\n * Compilação de Componentes Vue: Suporte à compilação eficiente de componentes\n   Vue 2/3.\n * Otimização para SSR: Otimizações específicas para cenários de renderização no\n   lado do servidor (SSR).\n * Aprimoramentos de Desenvolvimento: Funcionalidades específicas para aprimorar\n   o ambiente de desenvolvimento Vue.\n\n\nFluxo de Build#\n\nO fluxo de build do Gez é dividido principalmente nas seguintes etapas:\n\n 1. Inicialização da Configuração\n    \n    * Carregamento da configuração do projeto\n    * Fusão das configurações padrão com as configurações do usuário\n    * Ajuste da configuração com base em variáveis de ambiente\n\n 2. Compilação de Recursos\n    \n    * Resolução de dependências do código-fonte\n    * Transformação de diversos recursos (TypeScript, CSS, etc.)\n    * Processamento de importações e exportações de módulos\n\n 3. Processamento de Otimização\n    \n    * Execução da divisão de código\n    * Aplicação de Tree Shaking\n    * Compressão de código e recursos\n\n 4. Geração de Saída\n    \n    * Geração de arquivos de destino\n    * Saída de mapeamento de recursos\n    * Geração de relatórios de build\n\n\nMelhores Práticas#\n\n\nOtimização do Ambiente de Desenvolvimento#\n\n * Configuração de Compilação Incremental: Configure adequadamente a opção cache\n   para aproveitar o cache e acelerar o tempo de build.\n * Otimização de HMR: Configure o escopo de atualização a quente de forma\n   direcionada, evitando atualizações desnecessárias de módulos.\n * Otimização de Processamento de Recursos: Use configurações adequadas de\n   loader para evitar processamento repetitivo.\n\n\nOtimização do Ambiente de Produção#\n\n * Estratégia de Divisão de Código: Configure adequadamente splitChunks para\n   otimizar o carregamento de recursos.\n * Compressão de Recursos: Ative configurações de compressão adequadas para\n   equilibrar o tempo de build e o tamanho dos artefatos.\n * Otimização de Cache: Utilize hashes de conteúdo e estratégias de cache de\n   longo prazo para melhorar o desempenho de carregamento.\n\n\nExemplo de Configuração#\n\n\n\nTIP\n\nPara mais detalhes sobre a API e opções de configuração, consulte a Documentação\nda API do Rspack.","routePath":"/pt/guide/essentials/rspack","lang":"pt","toc":[{"text":"Funcionalidades","id":"funcionalidades","depth":2,"charIndex":237},{"text":"Construindo Aplicações","id":"construindo-aplicações","depth":2,"charIndex":1180},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1325},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1911},{"text":"Fluxo de Build","id":"fluxo-de-build","depth":2,"charIndex":2312},{"text":"Melhores Práticas","id":"melhores-práticas","depth":2,"charIndex":3110},{"text":"Otimização do Ambiente de Desenvolvimento","id":"otimização-do-ambiente-de-desenvolvimento","depth":3,"charIndex":3131},{"text":"Otimização do Ambiente de Produção","id":"otimização-do-ambiente-de-produção","depth":3,"charIndex":3576},{"text":"Exemplo de Configuração","id":"exemplo-de-configuração","depth":2,"charIndex":4002}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework - Motor de Build de Alto Desempenho","description":"Análise aprofundada do sistema de build Rspack do framework Gez, incluindo compilação de alto desempenho, build para múltiplos ambientes, otimização de recursos e outras funcionalidades principais, ajudando desenvolvedores a construir aplicações web modernas eficientes e confiáveis.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Sistema de Build, Compilação de Alto Desempenho, Atualização a Quente (HMR), Build para Múltiplos Ambientes, Tree Shaking, Divisão de Código, SSR, Otimização de Recursos, Eficiência de Desenvolvimento, Ferramenta de Build"}]]},"version":""},{"id":216,"title":"Padrões Padrão","content":"#\n\nGez é um framework SSR moderno que adota uma estrutura de projeto padronizada e\nmecanismos de resolução de caminhos para garantir consistência e\nmanutenibilidade em ambientes de desenvolvimento e produção.\n\n\nPadrões de Estrutura de Projeto#\n\n\nEstrutura de Diretórios Padrão#\n\n\n\nConhecimento Adicional\n * gez.name é derivado do campo name no package.json\n * dist/package.json é derivado do package.json na raiz\n * O diretório dist só será arquivado se packs.enable estiver definido como true\n\n\nPadrões de Arquivos de Entrada#\n\n\nentry.client.ts#\n\nO arquivo de entrada do cliente é responsável por:\n\n * Inicializar a aplicação: Configurar as configurações básicas da aplicação do\n   cliente\n * Gerenciar rotas: Lidar com rotas e navegação do cliente\n * Gerenciar estado: Implementar armazenamento e atualização do estado do\n   cliente\n * Processar interações: Gerenciar eventos do usuário e interações da interface\n\n\nentry.server.ts#\n\nO arquivo de entrada do servidor é responsável por:\n\n * Renderização do lado do servidor: Executar o processo de renderização SSR\n * Geração de HTML: Construir a estrutura inicial da página\n * Pré-busca de dados: Lidar com a obtenção de dados no servidor\n * Injeção de estado: Passar o estado do servidor para o cliente\n * Otimização de SEO: Garantir a otimização para motores de busca\n\n\nentry.node.ts#\n\nO arquivo de entrada do servidor Node.js é responsável por:\n\n * Configuração do servidor: Definir parâmetros do servidor HTTP\n * Processamento de rotas: Gerenciar regras de roteamento do servidor\n * Integração de middleware: Configurar middleware do servidor\n * Gerenciamento de ambiente: Lidar com variáveis de ambiente e configurações\n * Resposta a requisições: Processar requisições e respostas HTTP\n\n\nPadrões de Arquivos de Configuração#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/pt/guide/essentials/std","lang":"pt","toc":[{"text":"Padrões de Estrutura de Projeto","id":"padrões-de-estrutura-de-projeto","depth":2,"charIndex":210},{"text":"Estrutura de Diretórios Padrão","id":"estrutura-de-diretórios-padrão","depth":3,"charIndex":245},{"text":"Padrões de Arquivos de Entrada","id":"padrões-de-arquivos-de-entrada","depth":2,"charIndex":495},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":529},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":916},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1322},{"text":"Padrões de Arquivos de Configuração","id":"padrões-de-arquivos-de-configuração","depth":2,"charIndex":1743},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1782},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1800}],"domain":"","frontmatter":{"titleSuffix":"Guia de Estrutura e Padrões de Projeto do Framework Gez","description":"Detalha a estrutura padrão de projeto do framework Gez, especificações de arquivos de entrada e configurações, ajudando desenvolvedores a construir aplicações SSR padronizadas e de fácil manutenção.","head":[["meta",{"property":"keywords","content":"Gez, estrutura de projeto, arquivo de entrada, padrões de configuração, framework SSR, TypeScript, padrões de projeto, padrões de desenvolvimento"}]]},"version":""},{"id":217,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pt/guide/frameworks/html","lang":"pt","toc":[{"text":"Estrutura do Projeto","id":"estrutura-do-projeto","depth":2,"charIndex":-1},{"text":"Configuração do Projeto","id":"configuração-do-projeto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Estrutura do Código-Fonte","id":"estrutura-do-código-fonte","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Executando o Projeto","id":"executando-o-projeto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Exemplo de Aplicação HTML SSR com Gez","description":"Aprenda a criar uma aplicação HTML SSR com Gez do zero. Este tutorial mostra o uso básico do framework, incluindo inicialização do projeto, configuração de HTML e definição de arquivos de entrada.","head":[["meta",{"property":"keywords","content":"Gez, HTML, Aplicação SSR, Configuração TypeScript, Inicialização de Projeto, Renderização no Servidor, Interação no Cliente"}]]},"version":""},{"id":218,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pt/guide/frameworks/preact-htm","lang":"pt","toc":[{"text":"Estrutura do Projeto","id":"estrutura-do-projeto","depth":2,"charIndex":-1},{"text":"Configuração do Projeto","id":"configuração-do-projeto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Estrutura do Código-Fonte","id":"estrutura-do-código-fonte","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Executando o Projeto","id":"executando-o-projeto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Exemplo de Aplicação SSR com Preact+HTM no Framework Gez","description":"Aprenda a criar uma aplicação SSR com Preact+HTM usando o framework Gez desde o início. Este tutorial cobre inicialização do projeto, configuração do Preact e definição de arquivos de entrada.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, Aplicação SSR, Configuração TypeScript, Inicialização de Projeto, Renderização no Servidor, Interação no Cliente"}]]},"version":""},{"id":219,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pt/guide/frameworks/vue2","lang":"pt","toc":[{"text":"Estrutura do Projeto","id":"estrutura-do-projeto","depth":2,"charIndex":-1},{"text":"Configuração do Projeto","id":"configuração-do-projeto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Estrutura do Código-Fonte","id":"estrutura-do-código-fonte","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Executando o Projeto","id":"executando-o-projeto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Exemplo de Aplicação Vue2 SSR com Gez Framework","description":"Aprenda a criar uma aplicação Vue2 SSR do zero usando o Gez Framework. Este guia prático cobre desde a inicialização do projeto até a configuração do Vue2 e arquivos de entrada.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, Aplicação SSR, Configuração TypeScript, Inicialização de Projeto, Renderização no Servidor, Interação no Cliente"}]]},"version":""},{"id":220,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/pt/guide/frameworks/vue3","lang":"pt","toc":[{"text":"Estrutura do Projeto","id":"estrutura-do-projeto","depth":2,"charIndex":-1},{"text":"Configuração do Projeto","id":"configuração-do-projeto","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Estrutura do Código-Fonte","id":"estrutura-do-código-fonte","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Executando o Projeto","id":"executando-o-projeto","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Exemplo de Aplicação Vue3 SSR com Framework Gez","description":"Aprenda a criar uma aplicação Vue3 SSR com Gez do zero. Este tutorial mostra o uso básico do framework, incluindo inicialização do projeto, configuração do Vue3 e definição de arquivos de entrada.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, Aplicação SSR, Configuração TypeScript, Inicialização de Projeto, Renderização no Servidor, Interação no Cliente, API de Composição"}]]},"version":""},{"id":221,"title":"Requisitos de Ambiente","content":"#\n\nEste documento descreve os requisitos de ambiente necessários para usar este\nframework, incluindo o ambiente Node.js e a compatibilidade do navegador.\n\n\nAmbiente Node.js#\n\nO framework requer Node.js versão >= 22.6, principalmente para suportar a\nimportação de tipos TypeScript (através da flag --experimental-strip-types), sem\na necessidade de etapas adicionais de compilação.\n\n\nCompatibilidade do Navegador#\n\nO framework é construído por padrão no modo de compatibilidade para suportar uma\ngama mais ampla de navegadores. No entanto, é importante notar que, para obter\nsuporte completo de compatibilidade do navegador, é necessário adicionar\nmanualmente a dependência es-module-shims.\n\n\nModo de Compatibilidade (Padrão)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nDe acordo com as estatísticas do Can I Use, a cobertura de navegadores no modo\nde compatibilidade é de 96,81%.\n\n\nModo de Suporte Nativo#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nO modo de suporte nativo oferece as seguintes vantagens:\n\n * Zero sobrecarga de tempo de execução, sem a necessidade de carregadores de\n   módulos adicionais\n * Análise nativa pelo navegador, resultando em maior velocidade de execução\n * Melhor capacidade de divisão de código e carregamento sob demanda\n\nDe acordo com as estatísticas do Can I Use, a cobertura de navegadores no modo\nde suporte nativo é de 93,5%.\n\n\nHabilitando Suporte de Compatibilidade#\n\nAviso Importante\n\nEmbora o framework seja construído por padrão no modo de compatibilidade, para\nobter suporte completo a navegadores mais antigos, você precisa adicionar a\ndependência es-module-shims ao seu projeto.\n\nAdicione o seguinte script ao seu arquivo HTML:\n\n\n\nMelhores Práticas\n 1. Recomendações para o ambiente de produção:\n    * Implante o es-module-shims em seu próprio servidor\n    * Garanta a estabilidade e velocidade de carregamento dos recursos\n    * Evite possíveis riscos de segurança\n 2. Considerações de desempenho:\n    * O modo de compatibilidade traz uma pequena sobrecarga de desempenho\n    * Decida se deseja habilitar com base na distribuição de navegadores do seu\n      público-alvo","routePath":"/pt/guide/start/environment","lang":"pt","toc":[{"text":"Ambiente Node.js","id":"ambiente-nodejs","depth":2,"charIndex":155},{"text":"Compatibilidade do Navegador","id":"compatibilidade-do-navegador","depth":2,"charIndex":381},{"text":"Modo de Compatibilidade (Padrão)","id":"modo-de-compatibilidade-padrão","depth":3,"charIndex":690},{"text":"Modo de Suporte Nativo","id":"modo-de-suporte-nativo","depth":3,"charIndex":918},{"text":"Habilitando Suporte de Compatibilidade","id":"habilitando-suporte-de-compatibilidade","depth":3,"charIndex":1442}],"domain":"","frontmatter":{"titleSuffix":"Guia de Compatibilidade do Framework Gez","description":"Detalha os requisitos de ambiente do framework Gez, incluindo requisitos de versão do Node.js e compatibilidade do navegador, ajudando os desenvolvedores a configurar corretamente o ambiente de desenvolvimento.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, Compatibilidade do Navegador, TypeScript, es-module-shims, Configuração do Ambiente"}]]},"version":""},{"id":222,"title":"Início Rápido","content":"#\n\n\nInicialização do Projeto#\n\nPara criar e inicializar um novo projeto Gez, siga os passos abaixo:\n\n\n\n\nSeleção de Versão do Framework#\n\nO Framework Gez oferece várias versões de pilha tecnológica, cada uma otimizada\npara diferentes cenários de aplicação. Escolha a versão adequada de acordo com\nas necessidades do seu projeto:\n\n\nHTML#\n\nIdeal para projetos que buscam uma arquitetura minimalista:\n\n * Zero dependências externas, pronto para uso\n * Experiência de desenvolvimento com JavaScript nativo\n * Adequado para construção de sites estáticos e aplicativos leves\n * Suporte para expansão progressiva de funcionalidades\n\nVer documentação detalhada da versão HTML\n\n\nVue2#\n\nIdeal para desenvolvimento de aplicativos empresariais:\n\n * Suporte completo para TypeScript\n * Ecossistema rico de componentes de terceiros\n * Ferramentas de desenvolvimento maduras\n * Estabilidade comprovada em ambientes de produção\n\nVer documentação detalhada da versão Vue2\n\n\nVue3#\n\nIdeal para desenvolvimento de aplicativos web modernos:\n\n * Sistema reativo baseado em Proxy\n * Suporte para API de composição\n * Melhor desempenho em tempo de execução\n * Volume de pacote menor\n\nVer documentação detalhada da versão Vue3\n\n\nPreact+HTM#\n\nIdeal para projetos que buscam leveza e alto desempenho:\n\n * Volume de tempo de execução extremamente pequeno (3KB)\n * Sintaxe de modelo JavaScript nativo\n * API compatível com React\n * Excelente desempenho\n\nVer documentação detalhada da versão Preact+HTM\n\n\nDesenvolvimento Assistido por IA#\n\nO Framework Gez oferece capacidades de desenvolvimento assistido por IA, que\npodem aumentar significativamente a eficiência do desenvolvimento:\n\n 1. Escolha a documentação da versão do framework adequada\n 2. Forneça o conteúdo da documentação ao assistente de IA\n 3. A IA gerará automaticamente o esqueleto do projeto e os arquivos de\n    configuração\n\nDica\n\nO desenvolvimento assistido por IA não apenas acelera a inicialização do\nprojeto, mas também garante que a estrutura do projeto esteja em conformidade\ncom as melhores práticas.","routePath":"/pt/guide/start/getting-started","lang":"pt","toc":[{"text":"Inicialização do Projeto","id":"inicialização-do-projeto","depth":2,"charIndex":3},{"text":"Seleção de Versão do Framework","id":"seleção-de-versão-do-framework","depth":2,"charIndex":103},{"text":"HTML","id":"html","depth":3,"charIndex":329},{"text":"Vue2","id":"vue2","depth":3,"charIndex":668},{"text":"Vue3","id":"vue3","depth":3,"charIndex":955},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1202},{"text":"Desenvolvimento Assistido por IA","id":"desenvolvimento-assistido-por-ia","depth":2,"charIndex":1473}],"domain":"","frontmatter":{"titleSuffix":"Guia de Início Rápido do Framework Gez","description":"Guia de Início Rápido do Framework Gez, ajudando você a configurar um projeto do zero, incluindo inicialização do projeto, seleção de versão do framework e desenvolvimento assistido por IA.","head":[["meta",{"name":"keywords","content":"Framework Gez, Início Rápido, Inicialização de Projeto, Desenvolvimento Vue, Desenvolvimento HTML, Assistência por IA"}]]},"version":""},{"id":223,"title":"Introdução","content":"#\n\n\nContexto do Projeto#\n\nGez é um framework moderno de micro front-end baseado em ECMAScript Modules\n(ESM), focado na construção de aplicações de renderização no servidor (SSR) de\nalto desempenho e escaláveis. Como a terceira geração do projeto Genesis, Gez\ntem inovado continuamente ao longo de sua evolução técnica:\n\n * v1.0: Implementação de carregamento sob demanda de componentes remotos\n   baseado em requisições HTTP\n * v2.0: Integração de aplicações baseada em Webpack Module Federation\n * v3.0: Redesenho do sistema de vinculação de módulos baseado em ESM nativo do\n   navegador\n\n\nContexto Técnico#\n\nNo desenvolvimento da arquitetura de micro front-end, as soluções tradicionais\nenfrentam principalmente as seguintes limitações:\n\n\nDesafios das Soluções Existentes#\n\n * Gargalos de desempenho: Injeção de dependências em tempo de execução e\n   proxies de sandbox JavaScript trazem sobrecarga significativa de desempenho\n * Mecanismos de isolamento: Ambientes de sandbox desenvolvidos internamente\n   dificilmente alcançam a capacidade de isolamento de módulos nativa do\n   navegador\n * Complexidade de construção: Modificações nas ferramentas de construção para\n   compartilhamento de dependências aumentam os custos de manutenção do projeto\n * Desvio de padrões: Estratégias de implantação especiais e mecanismos de\n   processamento em tempo de execução divergem dos padrões modernos de\n   desenvolvimento web\n * Limitações do ecossistema: Acoplamento de frameworks e APIs personalizadas\n   restringem a escolha de pilhas tecnológicas\n\n\nInovações Técnicas#\n\nGez oferece uma nova solução baseada em padrões web modernos:\n\n * Sistema de módulos nativo: Utiliza ESM nativo do navegador e Import Maps para\n   gerenciamento de dependências, com maior velocidade de análise e execução\n * Mecanismo de isolamento padrão: Isolamento confiável de aplicações baseado no\n   escopo de módulos ECMAScript\n * Pilha tecnológica aberta: Suporte à integração perfeita de qualquer framework\n   front-end moderno\n * Experiência de desenvolvimento otimizada: Oferece um modo de desenvolvimento\n   intuitivo e capacidade completa de depuração\n * Otimização de desempenho máxima: Zero sobrecarga em tempo de execução através\n   de capacidades nativas, combinado com estratégias de cache inteligentes\n\nTIP\n\nGez foca em fornecer infraestrutura de micro front-end de alto desempenho e\nfácil expansão, especialmente adequada para cenários de aplicações de\nrenderização no servidor em larga escala.\n\n\nEspecificações Técnicas#\n\n\nDependências de Ambiente#\n\nConsulte o documento Requisitos de Ambiente para obter detalhes sobre os\nrequisitos de navegador e Node.js.\n\n\nPilha Tecnológica Principal#\n\n * Gerenciamento de dependências: Utiliza Import Maps para mapeamento de\n   módulos, com suporte de compatibilidade fornecido por es-module-shims\n * Sistema de construção: Baseado em module-import do Rspack para tratamento de\n   dependências externas\n * Ferramentas de desenvolvimento: Suporta atualização em tempo real (hot\n   reload) de ESM e execução nativa de TypeScript\n\n\nPosicionamento do Framework#\n\nGez difere de Next.js ou Nuxt.js, focando em fornecer infraestrutura de micro\nfront-end:\n\n * Sistema de vinculação de módulos: Implementa importação e exportação de\n   módulos eficiente e confiável\n * Renderização no servidor: Oferece mecanismos flexíveis de implementação de\n   SSR\n * Suporte a sistema de tipos: Integra definições de tipos TypeScript completas\n * Neutralidade de framework: Suporta integração com frameworks front-end\n   principais\n\n\nDesign de Arquitetura#\n\n\nGerenciamento Centralizado de Dependências#\n\n * Fonte de dependências unificada: Gerenciamento centralizado de dependências\n   de terceiros\n * Distribuição automática: Sincronização global automática de atualizações de\n   dependências\n * Consistência de versão: Controle preciso de versões de dependências\n\n\nDesign Modular#\n\n * Separação de responsabilidades: Desacoplamento de lógica de negócio e\n   infraestrutura\n * Mecanismo de plugins: Suporte à combinação e substituição flexível de módulos\n * Interfaces padronizadas: Protocolo de comunicação padronizado entre módulos\n\n\nOtimização de Desempenho#\n\n * Princípio de zero sobrecarga: Maximiza o uso de capacidades nativas do\n   navegador\n * Cache inteligente: Estratégia de cache precisa baseada em hash de conteúdo\n * Carregamento sob demanda: Gerenciamento refinado de divisão de código e\n   dependências\n\n\nMaturidade do Projeto#\n\nGez, através de quase 5 anos de iteração e evolução (v1.0 a v3.0), foi\namplamente validado em ambientes empresariais. Atualmente, suporta dezenas de\nprojetos de negócios em execução estável, e continua a impulsionar a\nmodernização da pilha tecnológica. A estabilidade, confiabilidade e vantagens de\ndesempenho do framework foram amplamente comprovadas na prática, fornecendo uma\nbase técnica confiável para o desenvolvimento de aplicações em larga escala.","routePath":"/pt/guide/start/introduction","lang":"pt","toc":[{"text":"Contexto do Projeto","id":"contexto-do-projeto","depth":2,"charIndex":3},{"text":"Contexto Técnico","id":"contexto-técnico","depth":2,"charIndex":590},{"text":"Desafios das Soluções Existentes","id":"desafios-das-soluções-existentes","depth":3,"charIndex":740},{"text":"Inovações Técnicas","id":"inovações-técnicas","depth":3,"charIndex":1546},{"text":"Especificações Técnicas","id":"especificações-técnicas","depth":2,"charIndex":2483},{"text":"Dependências de Ambiente","id":"dependências-de-ambiente","depth":3,"charIndex":2510},{"text":"Pilha Tecnológica Principal","id":"pilha-tecnológica-principal","depth":3,"charIndex":2647},{"text":"Posicionamento do Framework","id":"posicionamento-do-framework","depth":2,"charIndex":3054},{"text":"Design de Arquitetura","id":"design-de-arquitetura","depth":2,"charIndex":3537},{"text":"Gerenciamento Centralizado de Dependências","id":"gerenciamento-centralizado-de-dependências","depth":3,"charIndex":3562},{"text":"Design Modular","id":"design-modular","depth":3,"charIndex":3870},{"text":"Otimização de Desempenho","id":"otimização-de-desempenho","depth":3,"charIndex":4140},{"text":"Maturidade do Projeto","id":"maturidade-do-projeto","depth":2,"charIndex":4425}],"domain":"","frontmatter":{"titleSuffix":"Visão Geral e Inovações Técnicas do Framework Gez","description":"Aprofunde-se no contexto do projeto, evolução técnica e vantagens principais do framework de micro front-end Gez, explorando soluções modernas de renderização no lado do servidor baseadas em ESM.","head":[["meta",{"property":"keywords","content":"Gez, micro front-end, ESM, renderização no servidor, SSR, inovação técnica, module federation"}]]},"version":""}]