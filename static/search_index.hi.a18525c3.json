[{"id":100,"title":"@gez/rspack-vue","content":"#\n\nRspack Vue पैकेज Vue फ्रेमवर्क पर आधारित Rspack एप्लिकेशन बनाने और कॉन्फ़िगर\nकरने के लिए एक API सेट प्रदान करता है, जो Vue कंपोनेंट डेवलपमेंट, बिल्ड और\nसर्वर-साइड रेंडरिंग का समर्थन करता है।\n\n\nइंस्टॉलेशन#\n\nपैकेज मैनेजर का उपयोग करके @gez/rspack-vue डेवलपमेंट डिपेंडेंसी इंस्टॉल करें:\n\n\nटाइप एक्सपोर्ट#\n\n\nBuildTarget#\n\n\n\nबिल्ड टार्गेट एनवायरनमेंट टाइप, जो एप्लिकेशन के बिल्ड टार्गेट एनवायरनमेंट को\nपरिभाषित करता है, बिल्ड प्रक्रिया में विशिष्ट ऑप्टिमाइज़ेशन और फीचर्स को\nकॉन्फ़िगर करने के लिए उपयोग किया जाता है:\n\n * node: Node.js एनवायरनमेंट में चलने वाले कोड के लिए बिल्ड करें\n * client: ब्राउज़र एनवायरनमेंट में चलने वाले कोड के लिए बिल्ड करें\n * server: सर्वर एनवायरनमेंट में चलने वाले कोड के लिए बिल्ड करें\n\n\nRspackAppConfigContext#\n\n\n\nRspack एप्लिकेशन कॉन्फ़िगरेशन कॉन्टेक्स्ट इंटरफ़ेस, जो कॉन्फ़िगरेशन हुक फंक्शन\nमें एक्सेस किए जा सकने वाले कॉन्टेक्स्ट जानकारी प्रदान करता है:\n\n * gez: Gez फ्रेमवर्क इंस्टेंस\n * buildTarget: वर्तमान बिल्ड टार्गेट (client/server/node)\n * config: Rspack कॉन्फ़िगरेशन ऑब्जेक्ट\n * options: एप्लिकेशन कॉन्फ़िगरेशन ऑप्शन्स\n\n\nRspackAppOptions#\n\n\n\nRspack एप्लिकेशन कॉन्फ़िगरेशन ऑप्शन्स इंटरफ़ेस:\n\n * css: CSS आउटपुट मोड, 'css' (अलग फाइल) या 'style' (इनलाइन स्टाइल) चुन सकते हैं\n * loaders: कस्टम लोडर कॉन्फ़िगरेशन\n * styleLoader: style-loader कॉन्फ़िगरेशन ऑप्शन्स\n * cssLoader: css-loader कॉन्फ़िगरेशन ऑप्शन्स\n * target: बिल्ड टार्गेट कंपैटिबिलिटी कॉन्फ़िगरेशन\n * definePlugin: ग्लोबल कॉन्स्टेंट डेफिनिशन\n * config: कॉन्फ़िगरेशन हुक फंक्शन\n\n\nRspackHtmlAppOptions#\n\nRspackAppOptions से इनहेरिट करता है, HTML एप्लिकेशन के लिए विशिष्ट ऑप्शन्स को\nकॉन्फ़िगर करने के लिए उपयोग किया जाता है।\n\n\nफंक्शन एक्सपोर्ट#\n\n\ncreateRspackApp#\n\n\n\nएक स्टैंडर्ड Rspack एप्लिकेशन इंस्टेंस बनाएं।\n\nपैरामीटर्स:\n\n * gez: Gez फ्रेमवर्क इंस्टेंस\n * options: Rspack एप्लिकेशन कॉन्फ़िगरेशन ऑप्शन्स\n\nरिटर्न वैल्यू:\n\n * एक Promise रिटर्न करता है, जो बनाए गए एप्लिकेशन इंस्टेंस को रिज़ॉल्व करता है\n\n\ncreateRspackHtmlApp#\n\n\n\nएक HTML टाइप का Rspack एप्लिकेशन इंस्टेंस बनाएं।\n\nपैरामीटर्स:\n\n * gez: Gez फ्रेमवर्क इंस्टेंस\n * options: HTML एप्लिकेशन कॉन्फ़िगरेशन ऑप्शन्स\n\nरिटर्न वैल्यू:\n\n * एक Promise रिटर्न करता है, जो बनाए गए HTML एप्लिकेशन इंस्टेंस को रिज़ॉल्व\n   करता है\n\n\nकॉन्स्टेंट एक्सपोर्ट#\n\n\nRSPACK_LOADER#\n\n\n\nRspack में बिल्ट-इन लोडर आइडेंटिफ़ायर मैपिंग ऑब्जेक्ट, जो सामान्यतः उपयोग किए\nजाने वाले लोडर नाम कॉन्स्टेंट प्रदान करता है:\n\n * builtinSwcLoader: Rspack में बिल्ट-इन SWC लोडर, TypeScript/JavaScript फाइलों\n   को प्रोसेस करने के लिए\n * lightningcssLoader: Rspack में बिल्ट-इन lightningcss लोडर, CSS फाइलों के लिए\n   हाई-परफॉर्मेंस कंपाइलर\n * styleLoader: CSS को DOM में इंजेक्ट करने के लिए लोडर\n * cssLoader: CSS फाइलों को पार्स करने और CSS मॉड्यूलरिटी को हैंडल करने के लिए\n   लोडर\n * lessLoader: Less फाइलों को CSS में कंपाइल करने के लिए लोडर\n * styleResourcesLoader: ग्लोबल स्टाइल रिसोर्सेज (जैसे वेरिएबल्स, mixins) को\n   ऑटो-इम्पोर्ट करने के लिए लोडर\n * workerRspackLoader: Web Worker फाइलों को प्रोसेस करने के लिए लोडर\n\nइन कॉन्स्टेंट्स का उपयोग करके कॉन्फ़िगरेशन में बिल्ट-इन लोडर्स को रेफरेंस किया\nजा सकता है, मैन्युअल स्ट्रिंग टाइपिंग से बचा जा सकता है:\n\n\n\nध्यान दें:\n\n * ये लोडर्स Rspack में पहले से बिल्ट-इन हैं, अतिरिक्त इंस्टॉलेशन की आवश्यकता\n   नहीं है\n * कस्टम लोडर कॉन्फ़िगरेशन करते समय, इन कॉन्स्टेंट्स का उपयोग करके डिफ़ॉल्ट लोडर\n   इम्प्लीमेंटेशन को रिप्लेस किया जा सकता है\n * कुछ लोडर्स (जैसे builtinSwcLoader) के विशिष्ट कॉन्फ़िगरेशन ऑप्शन्स होते हैं,\n   संबंधित कॉन्फ़िगरेशन डॉक्यूमेंटेशन का संदर्भ लें\n\n\nमॉड्यूल एक्सपोर्ट#\n\n\nrspack#\n\n@rspack/core पैकेज की सभी सामग्री को री-एक्सपोर्ट करता है, Rspack कोर फंक्शनलिटी\nप्रदान करता है।","routePath":"/hi/api/app/rspack-vue","lang":"hi","toc":[{"text":"इंस्टॉलेशन","id":"इंस्टॉलेशन","depth":2,"charIndex":195},{"text":"टाइप एक्सपोर्ट","id":"टाइप-एक्सपोर्ट","depth":2,"charIndex":288},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":306},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":715},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1061},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1476},{"text":"फंक्शन एक्सपोर्ट","id":"फंक्शन-एक्सपोर्ट","depth":2,"charIndex":1621},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1641},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1901},{"text":"कॉन्स्टेंट एक्सपोर्ट","id":"कॉन्स्टेंट-एक्सपोर्ट","depth":2,"charIndex":2174},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2198},{"text":"मॉड्यूल एक्सपोर्ट","id":"मॉड्यूल-एक्सपोर्ट","depth":2,"charIndex":3438},{"text":"rspack","id":"rspack","depth":3,"charIndex":3459}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क Vue बिल्ड टूल","description":"Gez फ्रेमवर्क के लिए Vue विशेष बिल्ड टूल, जो Vue 2/3 एप्लिकेशन बिल्ड समर्थन प्रदान करता है, जिसमें कंपोनेंट डेवलपमेंट, SSR रेंडरिंग और परफॉर्मेंस ऑप्टिमाइज़ेशन जैसी सुविधाएं शामिल हैं।","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, बिल्ड टूल, कंपोनेंट डेवलपमेंट, सर्वर-साइड रेंडरिंग, परफॉर्मेंस ऑप्टिमाइज़ेशन"}]]},"version":""},{"id":101,"title":"@gez/rspack","content":"#\n\nRspack पैकेज Rspack एप्लिकेशन बनाने और कॉन्फ़िगर करने के लिए एक API सेट प्रदान\nकरता है, जो स्टैंडर्ड एप्लिकेशन और HTML एप्लिकेशन के बिल्ड और विकास को सपोर्ट\nकरता है।\n\n\nइंस्टॉलेशन#\n\nपैकेज मैनेजर का उपयोग करके @gez/rspack डेवलपमेंट डिपेंडेंसी इंस्टॉल करें:\n\n\nटाइप एक्सपोर्ट#\n\n\nBuildTarget#\n\n\n\nबिल्ड टार्गेट एनवायरनमेंट टाइप, एप्लिकेशन के बिल्ड टार्गेट एनवायरनमेंट को\nपरिभाषित करता है, जिसका उपयोग बिल्ड प्रक्रिया में विशिष्ट ऑप्टिमाइज़ेशन और\nफीचर्स को कॉन्फ़िगर करने के लिए किया जाता है:\n\n * node: Node.js एनवायरनमेंट में चलने वाले कोड के लिए बिल्ड\n * client: ब्राउज़र एनवायरनमेंट में चलने वाले कोड के लिए बिल्ड\n * server: सर्वर एनवायरनमेंट में चलने वाले कोड के लिए बिल्ड\n\n\nRspackAppConfigContext#\n\n\n\nRspack एप्लिकेशन कॉन्फ़िगरेशन कॉन्टेक्स्ट इंटरफ़ेस, कॉन्फ़िगरेशन हुक फ़ंक्शन में\nएक्सेस किए जा सकने वाले कॉन्टेक्स्ट जानकारी प्रदान करता है:\n\n * gez: Gez फ्रेमवर्क इंस्टेंस\n * buildTarget: वर्तमान बिल्ड टार्गेट (client/server/node)\n * config: Rspack कॉन्फ़िगरेशन ऑब्जेक्ट\n * options: एप्लिकेशन कॉन्फ़िगरेशन विकल्प\n\n\nRspackAppOptions#\n\n\n\nRspack एप्लिकेशन कॉन्फ़िगरेशन विकल्प इंटरफ़ेस:\n\n * css: CSS आउटपुट मोड, वैकल्पिक 'css' (अलग फ़ाइल) या 'style' (इनलाइन स्टाइल)\n * loaders: कस्टम लोडर कॉन्फ़िगरेशन\n * styleLoader: style-loader कॉन्फ़िगरेशन विकल्प\n * cssLoader: css-loader कॉन्फ़िगरेशन विकल्प\n * target: बिल्ड टार्गेट कम्पेटिबिलिटी कॉन्फ़िगरेशन\n * definePlugin: ग्लोबल कॉन्स्टेंट डेफ़िनिशन\n * config: कॉन्फ़िगरेशन हुक फ़ंक्शन\n\n\nRspackHtmlAppOptions#\n\nRspackAppOptions से इनहेरिट करता है, HTML एप्लिकेशन के लिए विशिष्ट विकल्प\nकॉन्फ़िगर करने के लिए उपयोग किया जाता है।\n\n\nफ़ंक्शन एक्सपोर्ट#\n\n\ncreateRspackApp#\n\n\n\nएक स्टैंडर्ड Rspack एप्लिकेशन इंस्टेंस बनाता है।\n\nपैरामीटर्स:\n\n * gez: Gez फ्रेमवर्क इंस्टेंस\n * options: Rspack एप्लिकेशन कॉन्फ़िगरेशन विकल्प\n\nरिटर्न वैल्यू:\n\n * एक Promise रिटर्न करता है, जो बनाए गए एप्लिकेशन इंस्टेंस को रिज़ॉल्व करता है\n\n\ncreateRspackHtmlApp#\n\n\n\nएक HTML प्रकार का Rspack एप्लिकेशन इंस्टेंस बनाता है।\n\nपैरामीटर्स:\n\n * gez: Gez फ्रेमवर्क इंस्टेंस\n * options: HTML एप्लिकेशन कॉन्फ़िगरेशन विकल्प\n\nरिटर्न वैल्यू:\n\n * एक Promise रिटर्न करता है, जो बनाए गए HTML एप्लिकेशन इंस्टेंस को रिज़ॉल्व\n   करता है\n\n\nकॉन्स्टेंट एक्सपोर्ट#\n\n\nRSPACK_LOADER#\n\n\n\nRspack में अंतर्निहित लोडर आइडेंटिफ़ायर मैपिंग ऑब्जेक्ट, सामान्यतः उपयोग किए\nजाने वाले लोडर नाम कॉन्स्टेंट प्रदान करता है:\n\n * builtinSwcLoader: Rspack में अंतर्निहित SWC लोडर, TypeScript/JavaScript\n   फ़ाइलों को प्रोसेस करने के लिए\n * lightningcssLoader: Rspack में अंतर्निहित lightningcss लोडर, CSS फ़ाइलों के\n   लिए उच्च प्रदर्शन कंपाइलर\n * styleLoader: CSS को DOM में इंजेक्ट करने के लिए लोडर\n * cssLoader: CSS फ़ाइलों को पार्स करने और CSS मॉड्यूलराइज़ेशन को प्रोसेस करने\n   के लिए लोडर\n * lessLoader: Less फ़ाइलों को CSS में कंपाइल करने के लिए लोडर\n * styleResourcesLoader: ग्लोबल स्टाइल संसाधन (जैसे वेरिएबल्स, mixins) को\n   ऑटोमेटिकली इम्पोर्ट करने के लिए लोडर\n * workerRspackLoader: Web Worker फ़ाइलों को प्रोसेस करने के लिए लोडर\n\nइन कॉन्स्टेंट का उपयोग करके कॉन्फ़िगरेशन में अंतर्निहित लोडर को रेफ़र कर सकते\nहैं, मैन्युअल स्ट्रिंग इनपुट से बच सकते हैं:\n\n\n\nध्यान दें:\n\n * ये लोडर Rspack में पहले से अंतर्निहित हैं, अतिरिक्त इंस्टॉलेशन की आवश्यकता\n   नहीं है\n * कस्टम लोडर कॉन्फ़िगरेशन करते समय, इन कॉन्स्टेंट का उपयोग करके डिफ़ॉल्ट लोडर\n   इम्प्लीमेंटेशन को रिप्लेस कर सकते हैं\n * कुछ लोडर (जैसे builtinSwcLoader) के विशिष्ट कॉन्फ़िगरेशन विकल्प होते हैं,\n   संबंधित कॉन्फ़िगरेशन डॉक्यूमेंटेशन देखें\n\n\nमॉड्यूल एक्सपोर्ट#\n\n\nrspack#\n\n@rspack/core पैकेज की सभी सामग्री को री-एक्सपोर्ट करता है, Rspack कोर\nफ़ंक्शनलिटी प्रदान करता है।","routePath":"/hi/api/app/rspack","lang":"hi","toc":[{"text":"इंस्टॉलेशन","id":"इंस्टॉलेशन","depth":2,"charIndex":170},{"text":"टाइप एक्सपोर्ट","id":"टाइप-एक्सपोर्ट","depth":2,"charIndex":259},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":277},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":674},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1017},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1429},{"text":"फ़ंक्शन एक्सपोर्ट","id":"फ़ंक्शन-एक्सपोर्ट","depth":2,"charIndex":1570},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1591},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1853},{"text":"कॉन्स्टेंट एक्सपोर्ट","id":"कॉन्स्टेंट-एक्सपोर्ट","depth":2,"charIndex":2130},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2154},{"text":"मॉड्यूल एक्सपोर्ट","id":"मॉड्यूल-एक्सपोर्ट","depth":2,"charIndex":3381},{"text":"rspack","id":"rspack","depth":3,"charIndex":3402}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क Rspack बिल्ड टूल","description":"Gez फ्रेमवर्क का Rspack बिल्ड टूल, उच्च प्रदर्शन वाले एप्लिकेशन बिल्ड क्षमता प्रदान करता है, स्टैंडर्ड एप्लिकेशन और HTML एप्लिकेशन के विकास और बिल्ड को सपोर्ट करता है, अंतर्निहित कई संसाधन प्रोसेसर और ऑप्टिमाइज़ेशन कॉन्फ़िगरेशन।","head":[["meta",{"property":"keywords","content":"Gez, Rspack, बिल्ड टूल, एप्लिकेशन बिल्ड, HTML एप्लिकेशन, TypeScript, CSS, संसाधन प्रसंस्करण, प्रदर्शन अनुकूलन"}]]},"version":""},{"id":102,"title":"App","content":"#\n\nApp Gez फ्रेमवर्क का एप्लिकेशन एब्स्ट्रैक्शन है, जो एप्लिकेशन के लाइफसाइकल,\nस्टैटिक संसाधन और सर्वर-साइड रेंडरिंग को प्रबंधित करने के लिए एकीकृत इंटरफेस\nप्रदान करता है।\n\n\n\n\nप्रकार परिभाषाएँ#\n\n\nApp#\n\n\n\nmiddleware#\n\n * प्रकार: Middleware\n\nस्टैटिक संसाधन प्रसंस्करण मिडलवेयर।\n\nडेवलपमेंट एनवायरनमेंट:\n\n * सोर्स कोड के स्टैटिक संसाधन अनुरोधों को संसाधित करता है\n * रियल-टाइम कंपाइलेशन और हॉट रीलोडिंग का समर्थन करता है\n * no-cache कैशिंग नीति का उपयोग करता है\n\nप्रोडक्शन एनवायरनमेंट:\n\n * बिल्ड किए गए स्टैटिक संसाधनों को संसाधित करता है\n * अपरिवर्तनीय फाइलों के लिए दीर्घकालिक कैशिंग (.final.xxx) का समर्थन करता है\n * अनुकूलित संसाधन लोडिंग नीति\n\n\n\nrender#\n\n * प्रकार: (options?: RenderContextOptions) => Promise\n\nसर्वर-साइड रेंडरिंग फ़ंक्शन। रनटाइम एनवायरनमेंट के आधार पर अलग-अलग कार्यान्वयन\nप्रदान करता है:\n\n * प्रोडक्शन एनवायरनमेंट (start): बिल्ड किए गए सर्वर-साइड एंट्री फाइल\n   (entry.server) को लोड करके रेंडरिंग करता है\n * डेवलपमेंट एनवायरनमेंट (dev): सोर्स कोड में सर्वर-साइड एंट्री फाइल को लोड करके\n   रेंडरिंग करता है\n\n\n\nbuild#\n\n * प्रकार: () => Promise\n\nप्रोडक्शन एनवायरनमेंट बिल्ड फ़ंक्शन। संसाधन पैकेजिंग और अनुकूलन के लिए उपयोग\nकिया जाता है। बिल्ड सफल होने पर true, विफल होने पर false लौटाता है।\n\ndestroy#\n\n * प्रकार: () => Promise\n\nसंसाधन सफाई फ़ंक्शन। सर्वर बंद करने, कनेक्शन तोड़ने आदि के लिए उपयोग किया जाता\nहै। सफाई सफल होने पर true, विफल होने पर false लौटाता है।","routePath":"/hi/api/core/app","lang":"hi","toc":[{"text":"प्रकार परिभाषाएँ","id":"प्रकार-परिभाषाएँ","depth":2,"charIndex":175},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":203},{"text":"render","id":"render","depth":4,"charIndex":646},{"text":"build","id":"build","depth":4,"charIndex":1028},{"text":"destroy","id":"destroy","depth":4,"charIndex":1208}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क एप्लिकेशन एब्स्ट्रैक्शन इंटरफेस","description":"Gez फ्रेमवर्क के App इंटरफेस का विस्तृत विवरण, जिसमें एप्लिकेशन लाइफसाइकल प्रबंधन, स्टैटिक संसाधन प्रसंस्करण और सर्वर-साइड रेंडरिंग कार्यक्षमता शामिल है, जो डेवलपर्स को एप्लिकेशन की मुख्य कार्यक्षमताओं को समझने और उपयोग करने में मदद करता है।","head":[["meta",{"property":"keywords","content":"Gez, App, एप्लिकेशन एब्स्ट्रैक्शन, लाइफसाइकल, स्टैटिक संसाधन, सर्वर-साइड रेंडरिंग, API"}]]},"version":""},{"id":103,"title":"Gez","content":"#\n\n\nपरिचय#\n\nGz एक Rspack पर आधारित उच्च-प्रदर्शन वेब एप्लिकेशन फ्रेमवर्क है, जो पूर्ण\nएप्लिकेशन लाइफसाइकल प्रबंधन, स्टेटिक संसाधन प्रसंस्करण और सर्वर-साइड रेंडरिंग\nक्षमताएं प्रदान करता है।\n\n\nप्रकार परिभाषाएं#\n\n\nRuntimeTarget#\n\n * प्रकार परिभाषा:\n\n\n\nएप्लिकेशन रनटाइम वातावरण प्रकार:\n\n * client: ब्राउज़र वातावरण में चलता है, DOM ऑपरेशन और ब्राउज़र API का समर्थन\n   करता है\n * server: Node.js वातावरण में चलता है, फाइल सिस्टम और सर्वर-साइड कार्यक्षमताओं\n   का समर्थन करता है\n\n\nImportMap#\n\n * प्रकार परिभाषा:\n\n\n\nES मॉड्यूल आयात मैपिंग प्रकार।\n\nSpecifierMap#\n\n * प्रकार परिभाषा:\n\n\n\nमॉड्यूल पहचानकर्ता मैपिंग प्रकार, जो मॉड्यूल आयात पथ की मैपिंग संबंधों को\nपरिभाषित करता है।\n\nScopesMap#\n\n * प्रकार परिभाषा:\n\n\n\nस्कोप मैपिंग प्रकार, जो विशिष्ट स्कोप के तहत मॉड्यूल आयात मैपिंग संबंधों को\nपरिभाषित करता है।\n\n\nCOMMAND#\n\n * प्रकार परिभाषा:\n\n\n\nकमांड प्रकार एनम:\n\n * dev: डेवलपमेंट वातावरण कमांड, डेवलपमेंट सर्वर शुरू करता है और हॉट रीलोडिंग का\n   समर्थन करता है\n * build: बिल्ड कमांड, प्रोडक्शन वातावरण के लिए बिल्ड आउटपुट उत्पन्न करता है\n * preview: प्रीव्यू कमांड, स्थानीय प्रीव्यू सर्वर शुरू करता है\n * start: स्टार्ट कमांड, प्रोडक्शन वातावरण सर्वर चलाता है\n\n\nइंस्टेंस विकल्प#\n\nGez फ्रेमवर्क के मुख्य कॉन्फ़िगरेशन विकल्पों को परिभाषित करता है।\n\n\n\nroot#\n\n * प्रकार: string\n * डिफ़ॉल्ट मान: process.cwd()\n\nप्रोजेक्ट रूट डायरेक्टरी पथ। यह पूर्ण पथ या सापेक्ष पथ हो सकता है, सापेक्ष पथ\nवर्तमान कार्यशील डायरेक्टरी के आधार पर हल किया जाता है।\n\nisProd#\n\n * प्रकार: boolean\n * डिफ़ॉल्ट मान: process.env.NODE_ENV === 'production'\n\nवातावरण पहचानकर्ता।\n\n * true: प्रोडक्शन वातावरण\n * false: डेवलपमेंट वातावरण\n\nbasePathPlaceholder#\n\n * प्रकार: string | false\n * डिफ़ॉल्ट मान: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nबेस पथ प्लेसहोल्डर कॉन्फ़िगरेशन। रनटाइम में संसाधनों के बेस पथ को डायनामिक रूप\nसे बदलने के लिए उपयोग किया जाता है। false सेट करने पर इस सुविधा को अक्षम किया जा\nसकता है।\n\nmodules#\n\n * प्रकार: ModuleConfig\n\nमॉड्यूल कॉन्फ़िगरेशन विकल्प। प्रोजेक्ट के मॉड्यूल रिज़ॉल्यूशन नियमों को\nकॉन्फ़िगर करने के लिए उपयोग किया जाता है, जिसमें मॉड्यूल एलियास, बाहरी\nनिर्भरताएं आदि शामिल हैं।\n\npacks#\n\n * प्रकार: PackConfig\n\nपैकेजिंग कॉन्फ़िगरेशन विकल्प। बिल्ड आउटपुट को मानक npm .tgz फॉर्मेट पैकेज में\nपैक करने के लिए उपयोग किया जाता है।\n\ndevApp#\n\n * प्रकार: (gez: Gez) => Promise\n\nडेवलपमेंट वातावरण एप्लिकेशन निर्माण फ़ंक्शन। केवल डेवलपमेंट वातावरण में उपयोग\nकिया जाता है, डेवलपमेंट सर्वर के लिए एप्लिकेशन इंस्टेंस बनाने के लिए।\n\n\n\nserver#\n\n * प्रकार: (gez: Gez) => Promise\n\nसर्वर स्टार्ट कॉन्फ़िगरेशन फ़ंक्शन। HTTP सर्वर को कॉन्फ़िगर और शुरू करने के लिए\nउपयोग किया जाता है, डेवलपमेंट और प्रोडक्शन दोनों वातावरणों में उपयोग किया जा\nसकता है।\n\n\n\npostBuild#\n\n * प्रकार: (gez: Gez) => Promise\n\nबिल्ड पोस्ट-प्रोसेसिंग फ़ंक्शन। प्रोजेक्ट बिल्ड पूरा होने के बाद निष्पादित किया\nजाता है, निम्नलिखित के लिए उपयोग किया जा सकता है:\n\n * अतिरिक्त संसाधन प्रसंस्करण\n * डिप्लॉयमेंट ऑपरेशन\n * स्टेटिक फाइलें उत्पन्न करना\n * बिल्ड नोटिफिकेशन भेजना\n\n\nइंस्टेंस गुण#\n\n\nname#\n\n * प्रकार: string\n * केवल पढ़ने योग्य: true\n\nवर्तमान मॉड्यूल का नाम, मॉड्यूल कॉन्फ़िगरेशन से प्राप्त होता है।\n\n\nvarName#\n\n * प्रकार: string\n * केवल पढ़ने योग्य: true\n\nमॉड्यूल नाम के आधार पर उत्पन्न वैध JavaScript वेरिएबल नाम।\n\n\nroot#\n\n * प्रकार: string\n * केवल पढ़ने योग्य: true\n\nप्रोजेक्ट रूट डायरेक्टरी का पूर्ण पथ। यदि कॉन्फ़िगर किया गया root सापेक्ष पथ है,\nतो वर्तमान कार्यशील डायरेक्टरी के आधार पर हल किया जाता है।\n\n\nisProd#\n\n * प्रकार: boolean\n * केवल पढ़ने योग्य: true\n\nजांचें कि वर्तमान में प्रोडक्शन वातावरण है या नहीं। कॉन्फ़िगरेशन में isProd का\nउपयोग करता है, यदि कॉन्फ़िगर नहीं किया गया है तो process.env.NODE_ENV के आधार पर\nजांचता है।\n\n\nbasePath#\n\n * प्रकार: string\n * केवल पढ़ने योग्य: true\n * थ्रो: NotReadyError - फ्रेमवर्क इनिशियलाइज़ नहीं होने पर\n\nस्लैश से शुरू और समाप्त होने वाला मॉड्यूल बेस पथ प्राप्त करें। रिटर्न फॉर्मेट\n/${name}/ है, जहां नाम मॉड्यूल कॉन्फ़िगरेशन से प्राप्त होता है।\n\n\nbasePathPlaceholder#\n\n * प्रकार: string\n * केवल पढ़ने योग्य: true\n\nरनटाइम में डायनामिक रूप से बदलने के लिए उपयोग किया जाने वाला बेस पथ प्लेसहोल्डर\nप्राप्त करें। कॉन्फ़िगरेशन द्वारा अक्षम किया जा सकता है।\n\n\nmiddleware#\n\n * प्रकार: Middleware\n * केवल पढ़ने योग्य: true\n\nस्टेटिक संसाधन प्रसंस्करण मिडलवेयर प्राप्त करें। वातावरण के आधार पर अलग-अलग\nकार्यान्वयन प्रदान करता है:\n\n * डेवलपमेंट वातावरण: सोर्स कोड रियल-टाइम कंपाइलेशन, हॉट रीलोडिंग का समर्थन करता\n   है\n * प्रोडक्शन वातावरण: स्टेटिक संसाधनों के लिए लॉन्ग-टर्म कैशिंग का समर्थन करता\n   है\n\n\n\n\nrender#\n\n * प्रकार: (options?: RenderContextOptions) => Promise\n * केवल पढ़ने योग्य: true\n\nसर्वर-साइड रेंडरिंग फ़ंक्शन प्राप्त करें। वातावरण के आधार पर अलग-अलग कार्यान्वयन\nप्रदान करता है:\n\n * डेवलपमेंट वातावरण: हॉट रीलोडिंग और रियल-टाइम प्रीव्यू का समर्थन करता है\n * प्रोडक्शन वातावरण: ऑप्टिमाइज़्ड रेंडरिंग प्रदर्शन प्रदान करता है\n\n\n\n\nCOMMAND#\n\n * प्रकार: typeof COMMAND\n * केवल पढ़ने योग्य: true\n\nकमांड एनम प्रकार परिभाषा प्राप्त करें।\n\n\nmoduleConfig#\n\n * प्रकार: ParsedModuleConfig\n * केवल पढ़ने योग्य: true\n * थ्रो: NotReadyError - फ्रेमवर्क इनिशियलाइज़ नहीं होने पर\n\nवर्तमान मॉड्यूल की पूर्ण कॉन्फ़िगरेशन जानकारी प्राप्त करें, जिसमें मॉड्यूल\nरिज़ॉल्यूशन नियम, एलियास कॉन्फ़िगरेशन आदि शामिल हैं।\n\n\npackConfig#\n\n * प्रकार: ParsedPackConfig\n * केवल पढ़ने योग्य: true\n * थ्रो: NotReadyError - फ्रेमवर्क इनिशियलाइज़ नहीं होने पर\n\nवर्तमान मॉड्यूल की पैकेजिंग संबंधित कॉन्फ़िगरेशन प्राप्त करें, जिसमें आउटपुट पथ,\npackage.json प्रसंस्करण आदि शामिल हैं।\n\n\nइंस्टेंस मेथड्स#\n\n\nconstructor()#\n\n * पैरामीटर्स:\n   * options?: GezOptions - फ्रेमवर्क कॉन्फ़िगरेशन विकल्प\n * रिटर्न वैल्यू: Gez\n\nGez फ्रेमवर्क इंस्टेंस बनाएं।\n\n\n\n\ninit()#\n\n * पैरामीटर्स: command: COMMAND\n * रिटर्न वैल्यू: Promise\n * थ्रो:\n   * Error: डुप्लिकेट इनिशियलाइज़ेशन पर\n   * NotReadyError: अनइनिशियलाइज़्ड इंस्टेंस एक्सेस करने पर\n\nGez फ्रेमवर्क इंस्टेंस को इनिशियलाइज़ करें। निम्नलिखित कोर इनिशियलाइज़ेशन\nप्रक्रिया निष्पादित करता है:\n\n 1. प्रोजेक्ट कॉन्फ़िगरेशन पार्स करें (package.json, मॉड्यूल कॉन्फ़िगरेशन,\n    पैकेजिंग कॉन्फ़िगरेशन आदि)\n 2. एप्लिकेशन इंस्टेंस बनाएं (डेवलपमेंट या प्रोडक्शन वातावरण)\n 3. कम","routePath":"/hi/api/core/gez","lang":"hi","toc":[{"text":"परिचय","id":"परिचय","depth":2,"charIndex":3},{"text":"प्रकार परिभाषाएं","id":"प्रकार-परिभाषाएं","depth":2,"charIndex":190},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":210},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":474},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":540},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":670},{"text":"COMMAND","id":"command","depth":3,"charIndex":800},{"text":"इंस्टेंस विकल्प","id":"इंस्टेंस-विकल्प","depth":2,"charIndex":1151},{"text":"root","id":"root","depth":4,"charIndex":1238},{"text":"isProd","id":"isprod","depth":4,"charIndex":1430},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1591},{"text":"modules","id":"modules","depth":4,"charIndex":1858},{"text":"packs","id":"packs","depth":4,"charIndex":2063},{"text":"devApp","id":"devapp","depth":4,"charIndex":2209},{"text":"server","id":"server","depth":4,"charIndex":2403},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":2615},{"text":"इंस्टेंस गुण","id":"इंस्टेंस-गुण","depth":2,"charIndex":2903},{"text":"name","id":"name","depth":3,"charIndex":2919},{"text":"varName","id":"varname","depth":3,"charIndex":3038},{"text":"root","id":"root-1","depth":3,"charIndex":3154},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3348},{"text":"basePath","id":"basepath","depth":3,"charIndex":3576},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":3836},{"text":"middleware","id":"middleware","depth":3,"charIndex":4042},{"text":"render","id":"render","depth":3,"charIndex":4385},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":4721},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":4825},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":5087},{"text":"इंस्टेंस मेथड्स","id":"इंस्टेंस-मेथड्स","depth":2,"charIndex":5337},{"text":"constructor()","id":"constructor","depth":3,"charIndex":5356},{"text":"init()","id":"init","depth":3,"charIndex":5502}],"domain":"","frontmatter":{"titleSuffix":"फ्रेमवर्क कोर क्लास API संदर्भ","description":"Gez फ्रेमवर्क के कोर क्लास API का विस्तृत विवरण, जिसमें एप्लिकेशन लाइफसाइकल प्रबंधन, स्टेटिक संसाधन प्रसंस्करण और सर्वर-साइड रेंडरिंग क्षमताएं शामिल हैं, जो डेवलपर्स को फ्रेमवर्क की मुख्य कार्यक्षमताओं को गहराई से समझने में मदद करती हैं।","head":[["meta",{"property":"keywords","content":"Gez, API, लाइफसाइकल प्रबंधन, स्टेटिक संसाधन, सर्वर-साइड रेंडरिंग, Rspack, वेब एप्लिकेशन फ्रेमवर्क"}]]},"version":""},{"id":104,"title":"ManifestJson","content":"#\n\nmanifest.json Gez फ्रेमवर्क द्वारा बिल्ड प्रक्रिया के दौरान उत्पन्न की जाने वाली\nमैनिफेस्ट फ़ाइल है, जो सेवा बिल्ड के आउटपुट की जानकारी रिकॉर्ड करती है। यह बिल्ड\nआउटपुट, एक्सपोर्ट फ़ाइल और संसाधन आकार सांख्यिकी को प्रबंधित करने के लिए एकीकृत\nइंटरफ़ेस प्रदान करती है।\n\n\n\n\nप्रकार परिभाषाएँ#\n\n\nManifestJson#\n\n\n\nname#\n\n * प्रकार: string\n\nसेवा का नाम, GezOptions.name कॉन्फ़िगरेशन से लिया गया।\n\nexports#\n\n * प्रकार: Record\n\nएक्सपोर्ट की गई फ़ाइलों की मैपिंग, key स्रोत फ़ाइल पथ है और value बिल्ड के बाद\nकी फ़ाइल पथ है।\n\nbuildFiles#\n\n * प्रकार: string[]\n\nबिल्ड आउटपुट की पूरी फ़ाइल सूची, जिसमें सभी उत्पन्न फ़ाइल पथ शामिल हैं।\n\nchunks#\n\n * प्रकार: Record\n\nस्रोत फ़ाइल और संकलित आउटपुट के बीच संबंध, key स्रोत फ़ाइल पथ है और value संकलन\nजानकारी है।\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * प्रकार: string\n\nवर्तमान स्रोत फ़ाइल के संकलित JS फ़ाइल का पथ।\n\ncss#\n\n * प्रकार: string[]\n\nवर्तमान स्रोत फ़ाइल से जुड़ी CSS फ़ाइलों की पथ सूची।\n\nresources#\n\n * प्रकार: string[]\n\nवर्तमान स्रोत फ़ाइल से जुड़े अन्य संसाधन फ़ाइलों की पथ सूची।\n\nsizes#\n\n * प्रकार: ManifestJsonChunkSizes\n\nबिल्ड आउटपुट का आकार सांख्यिकी जानकारी।\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * प्रकार: number\n\nJS फ़ाइल का आकार (बाइट्स में)।\n\ncss#\n\n * प्रकार: number\n\nCSS फ़ाइल का आकार (बाइट्स में)।\n\nresource#\n\n * प्रकार: number\n\nसंसाधन फ़ाइल का आकार (बाइट्स में)।","routePath":"/hi/api/core/manifest-json","lang":"hi","toc":[{"text":"प्रकार परिभाषाएँ","id":"प्रकार-परिभाषाएँ","depth":2,"charIndex":273},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":310},{"text":"exports","id":"exports","depth":4,"charIndex":392},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":517},{"text":"chunks","id":"chunks","depth":4,"charIndex":624},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":746},{"text":"js","id":"js","depth":4,"charIndex":769},{"text":"css","id":"css","depth":4,"charIndex":840},{"text":"resources","id":"resources","depth":4,"charIndex":921},{"text":"sizes","id":"sizes","depth":4,"charIndex":1016},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1101},{"text":"js","id":"js-1","depth":4,"charIndex":1128},{"text":"css","id":"css-1","depth":4,"charIndex":1184},{"text":"resource","id":"resource","depth":4,"charIndex":1242}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क मैनिफेस्ट फ़ाइल संदर्भ","description":"Gez फ्रेमवर्क के मैनिफेस्ट फ़ाइल (manifest.json) की संरचना का विस्तृत विवरण, जिसमें बिल्ड आउटपुट प्रबंधन, एक्सपोर्ट फ़ाइल मैपिंग और संसाधन सांख्यिकी शामिल हैं, जो डेवलपर्स को बिल्ड सिस्टम को समझने और उपयोग करने में मदद करता है।","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, बिल्ड मैनिफेस्ट, संसाधन प्रबंधन, बिल्ड आउटपुट, फ़ाइल मैपिंग, API"}]]},"version":""},{"id":105,"title":"ModuleConfig","content":"#\n\nModuleConfig, Gez फ्रेमवर्क के मॉड्यूल कॉन्फ़िगरेशन कार्यक्षमता प्रदान करता है,\nजिसका उपयोग मॉड्यूल के आयात/निर्यात नियम, उपनाम कॉन्फ़िगरेशन और बाहरी निर्भरता\nआदि को परिभाषित करने के लिए किया जाता है।\n\n\nप्रकार परिभाषा#\n\n\nPathType#\n\n * प्रकार परिभाषा:\n\n\n\nमॉड्यूल पथ प्रकार एनम:\n\n * npm: node_modules में स्थित निर्भरता को दर्शाता है\n * root: प्रोजेक्ट रूट डायरेक्टरी में स्थित फ़ाइल को दर्शाता है\n\n\nModuleConfig#\n\n * प्रकार परिभाषा:\n\n\n\nमॉड्यूल कॉन्फ़िगरेशन इंटरफ़ेस, जिसका उपयोग सेवा के निर्यात, आयात और बाहरी\nनिर्भरता कॉन्फ़िगरेशन को परिभाषित करने के लिए किया जाता है।\n\nexports#\n\nनिर्यात कॉन्फ़िगरेशन सूची, जो सेवा में विशिष्ट कोड यूनिट (जैसे कंपोनेंट,\nउपयोगिता फ़ंक्शन आदि) को ESM प्रारूप में बाहरी रूप से उजागर करती है।\n\nदो प्रकार समर्थित हैं:\n\n * root:*: स्रोत कोड फ़ाइल निर्यात करता है, जैसे:\n   'root:src/components/button.vue'\n * npm:*: तृतीय-पक्ष निर्भरता निर्यात करता है, जैसे: 'npm:vue'\n\nimports#\n\nआयात कॉन्फ़िगरेशन मैपिंग, जो दूरस्थ मॉड्यूल और उनके स्थानीय पथ को कॉन्फ़िगर करता\nहै।\n\nस्थापना विधि के आधार पर कॉन्फ़िगरेशन भिन्न होता है:\n\n * स्रोत कोड स्थापना (Workspace, Git): dist डायरेक्टरी की ओर इंगित करना आवश्यक\n   है\n * सॉफ़्टवेयर पैकेज स्थापना (Link, स्थिर सर्वर, निजी मिरर स्रोत, File): सीधे\n   पैकेज डायरेक्टरी की ओर इंगित करें\n\nexternals#\n\nबाहरी निर्भरता मैपिंग, जो उपयोग की जाने वाली बाहरी निर्भरता को कॉन्फ़िगर करता\nहै, आमतौर पर दूरस्थ मॉड्यूल में स्थित निर्भरता का उपयोग करता है।\n\nउदाहरण:\n\n\n\n\nParsedModuleConfig#\n\n * प्रकार परिभाषा:\n\n\n\nपार्स किया गया मॉड्यूल कॉन्फ़िगरेशन, जो मूल मॉड्यूल कॉन्फ़िगरेशन को मानकीकृत\nआंतरिक प्रारूप में परिवर्तित करता है:\n\nname#\n\nवर्तमान सेवा का नाम\n\n * मॉड्यूल की पहचान और आयात पथ उत्पन्न करने के लिए उपयोग किया जाता है\n\nroot#\n\nवर्तमान सेवा की रूट डायरेक्टरी पथ\n\n * सापेक्ष पथ और निर्माण उत्पादों के भंडारण को हल करने के लिए उपयोग किया जाता है\n\nexports#\n\nनिर्यात कॉन्फ़िगरेशन सूची\n\n * name: मूल निर्यात पथ, जैसे: 'npm:vue' या 'root:src/components'\n * type: पथ प्रकार (npm या root)\n * importName: आयात नाम, प्रारूप: '${serviceName}/${type}/${path}'\n * exportName: निर्यात पथ, सेवा रूट डायरेक्टरी के सापेक्ष\n * exportPath: वास्तविक फ़ाइल पथ\n * externalName: बाहरी निर्भरता नाम, अन्य सेवाओं द्वारा इस मॉड्यूल को आयात करते\n   समय पहचान के लिए उपयोग किया जाता है\n\nimports#\n\nआयात कॉन्फ़िगरेशन सूची\n\n * name: बाहरी सेवा का नाम\n * localPath: स्थानीय भंडारण पथ, बाहरी मॉड्यूल के निर्माण उत्पादों को संग्रहीत\n   करने के लिए उपयोग किया जाता है\n\nexternals#\n\nबाहरी निर्भरता मैपिंग\n\n * मॉड्यूल के आयात पथ को वास्तविक मॉड्यूल स्थान पर मैप करता है\n * match: आयात स्टेटमेंट से मिलान करने के लिए उपयोग किया जाने वाला रेगुलर\n   एक्सप्रेशन\n * import: वास्तविक मॉड्यूल पथ","routePath":"/hi/api/core/module-config","lang":"hi","toc":[{"text":"प्रकार परिभाषा","id":"प्रकार-परिभाषा","depth":2,"charIndex":205},{"text":"PathType","id":"pathtype","depth":3,"charIndex":223},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":572},{"text":"imports","id":"imports","depth":4,"charIndex":899},{"text":"externals","id":"externals","depth":4,"charIndex":1248},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1416},{"text":"name","id":"name","depth":4,"charIndex":1575},{"text":"root","id":"root","depth":4,"charIndex":1674},{"text":"exports","id":"exports-1","depth":4,"charIndex":1798},{"text":"imports","id":"imports-1","depth":4,"charIndex":2212},{"text":"externals","id":"externals-1","depth":4,"charIndex":2387}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क मॉड्यूल कॉन्फ़िगरेशन API संदर्भ","description":"Gez फ्रेमवर्क के ModuleConfig कॉन्फ़िगरेशन इंटरफ़ेस का विस्तृत विवरण, जिसमें मॉड्यूल आयात/निर्यात नियम, उपनाम कॉन्फ़िगरेशन और बाहरी निर्भरता प्रबंधन शामिल है, जो डेवलपर्स को फ्रेमवर्क के मॉड्यूलर सिस्टम को गहराई से समझने में मदद करता है।","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, मॉड्यूल कॉन्फ़िगरेशन, मॉड्यूल आयात/निर्यात, बाहरी निर्भरता, उपनाम कॉन्फ़िगरेशन, निर्भरता प्रबंधन, वेब एप्लिकेशन फ्रेमवर्क"}]]},"version":""},{"id":106,"title":"PackConfig","content":"#\n\nPackConfig सॉफ़्टवेयर पैकेज पैकेजिंग कॉन्फ़िगरेशन इंटरफ़ेस है, जिसका उपयोग सेवा\nके बिल्ड आउटपुट को मानक npm .tgz प्रारूप में पैकेज करने के लिए किया जाता है।\n\n * मानकीकरण: npm मानक .tgz पैकेजिंग प्रारूप का उपयोग करता है\n * पूर्णता: मॉड्यूल के स्रोत कोड, टाइप डिक्लेरेशन और कॉन्फ़िगरेशन फ़ाइलों सहित\n   सभी आवश्यक फ़ाइलें शामिल हैं\n * संगतता: npm इकोसिस्टम के साथ पूरी तरह से संगत, मानक पैकेज प्रबंधन वर्कफ़्लो\n   का समर्थन करता है\n\n\nप्रकार परिभाषा#\n\n\n\n\nPackConfig#\n\nenable#\n\nपैकेजिंग सुविधा को सक्षम करें या नहीं। सक्षम करने पर बिल्ड आउटपुट को मानक npm\n.tgz प्रारूप में पैकेज किया जाएगा।\n\n * प्रकार: boolean\n * डिफ़ॉल्ट मान: false\n\noutputs#\n\nआउटपुट पैकेज फ़ाइल पथ निर्दिष्ट करें। निम्नलिखित कॉन्फ़िगरेशन विधियों का समर्थन\nकरता है:\n\n * string: एकल आउटपुट पथ, जैसे 'dist/versions/my-app.tgz'\n * string[]: एकाधिक आउटपुट पथ, एक साथ कई संस्करण उत्पन्न करने के लिए\n * boolean: true होने पर डिफ़ॉल्ट पथ 'dist/client/versions/latest.tgz' का उपयोग\n   करता है\n\npackageJson#\n\npackage.json सामग्री को अनुकूलित करने के लिए कॉलबैक फ़ंक्शन। पैकेजिंग से पहले\nकॉल किया जाता है, package.json की सामग्री को अनुकूलित करने के लिए उपयोग किया\nजाता है।\n\n * पैरामीटर:\n   * gez: Gez - Gez उदाहरण\n   * pkg: any - मूल package.json सामग्री\n * रिटर्न मान: Promise - संशोधित package.json सामग्री\n\nसामान्य उपयोग:\n\n * पैकेज नाम और संस्करण संख्या संशोधित करना\n * निर्भरताएँ जोड़ना या अद्यतन करना\n * कस्टम फ़ील्ड जोड़ना\n * प्रकाशन संबंधी जानकारी कॉन्फ़िगर करना\n\nउदाहरण:\n\n\n\nonBefore#\n\nपैकेजिंग से पहले की तैयारी के लिए कॉलबैक फ़ंक्शन।\n\n * पैरामीटर:\n   * gez: Gez - Gez उदाहरण\n   * pkg: Record - package.json सामग्री\n * रिटर्न मान: Promise\n\nसामान्य उपयोग:\n\n * अतिरिक्त फ़ाइलें जोड़ना (README, LICENSE आदि)\n * परीक्षण या बिल्ड सत्यापन निष्पादित करना\n * दस्तावेज़ या मेटाडेटा उत्पन्न करना\n * अस्थायी फ़ाइलों को साफ़ करना\n\nउदाहरण:\n\n\n\nonAfter#\n\nपैकेजिंग पूर्ण होने के बाद के प्रसंस्करण के लिए कॉलबैक फ़ंक्शन। .tgz फ़ाइल\nउत्पन्न होने के बाद कॉल किया जाता है, पैकेज आउटपुट को संसाधित करने के लिए उपयोग\nकिया जाता है।\n\n * पैरामीटर:\n   * gez: Gez - Gez उदाहरण\n   * pkg: Record - package.json सामग्री\n   * file: Buffer - पैकेज की गई फ़ाइल सामग्री\n * रिटर्न मान: Promise\n\nसामान्य उपयोग:\n\n * npm रिपॉजिटरी (सार्वजनिक या निजी) पर प्रकाशित करना\n * स्थिर संसाधन सर्वर पर अपलोड करना\n * संस्करण प्रबंधन निष्पादित करना\n * CI/CD प्रक्रिया ट्रिगर करना\n\nउदाहरण:\n\n\n\n\nउपयोग उदाहरण#\n\n","routePath":"/hi/api/core/pack-config","lang":"hi","toc":[{"text":"प्रकार परिभाषा","id":"प्रकार-परिभाषा","depth":2,"charIndex":434},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":467},{"text":"outputs","id":"outputs","depth":4,"charIndex":633},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":952},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1439},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1795},{"text":"उपयोग उदाहरण","id":"उपयोग-उदाहरण","depth":2,"charIndex":2309}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क पैकेजिंग कॉन्फ़िगरेशन API संदर्भ","description":"Gez फ्रेमवर्क के PackConfig कॉन्फ़िगरेशन इंटरफ़ेस का विस्तृत विवरण, जिसमें सॉफ़्टवेयर पैकेज पैकेजिंग नियम, आउटपुट कॉन्फ़िगरेशन और लाइफ़साइकल हुक शामिल हैं, जो डेवलपर्स को मानकीकृत बिल्ड प्रक्रिया को लागू करने में मदद करता है।","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, सॉफ़्टवेयर पैकेज पैकेजिंग, बिल्ड कॉन्फ़िगरेशन, लाइफ़साइकल हुक, पैकेजिंग कॉन्फ़िगरेशन, वेब एप्लिकेशन फ्रेमवर्क"}]]},"version":""},{"id":107,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/hi/api/core/render-context","lang":"hi","toc":[{"text":"प्रकार परिभाषाएं","id":"प्रकार-परिभाषाएं","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"इंस्टेंस विकल्प","id":"इंस्टेंस-विकल्प","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"इंस्टेंस गुण","id":"इंस्टेंस-गुण","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क रेंडरिंग संदर्भ API संदर्भ","description":"Gez फ्रेमवर्क के RenderContext कोर क्लास का विस्तृत विवरण, जिसमें रेंडरिंग नियंत्रण, संसाधन प्रबंधन, स्थिति सिंक्रनाइज़ेशन और रूटिंग नियंत्रण जैसी कार्यक्षमताएं शामिल हैं, जो डेवलपर्स को कुशल सर्वर-साइड रेंडरिंग (SSR) को लागू करने में मदद करती हैं।","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, सर्वर-साइड रेंडरिंग, रेंडरिंग संदर्भ, स्थिति सिंक्रनाइज़ेशन, संसाधन प्रबंधन, वेब एप्लिकेशन फ्रेमवर्क"}]]},"version":""},{"id":108,"title":"घटक साझाकरण से मूल मॉड्यूलरिटी तक: Gez माइक्रो-फ्रंटेंड फ्रेमवर्क का विकास पथ","content":"#\n\n\nपरियोजना पृष्ठभूमि#\n\nपिछले कुछ वर्षों में, माइक्रो-फ्रंटेंड आर्किटेक्चर एक सही रास्ता खोजने की कोशिश\nकर रहा है। हालांकि, हमने विभिन्न जटिल तकनीकी समाधान देखे हैं, जो एक आदर्श\nमाइक्रो-फ्रंटेंड दुनिया का अनुकरण करने के लिए परतों में लपेटे और कृत्रिम अलगाव\nका उपयोग करते हैं। इन समाधानों ने भारी प्रदर्शन बोझ लाया है, सरल विकास को जटिल\nबना दिया है, और मानक प्रक्रियाओं को अस्पष्ट कर दिया है।\n\n\nपारंपरिक समाधानों की सीमाएं#\n\nमाइक्रो-फ्रंटेंड आर्किटेक्चर के अभ्यास में, हमने पारंपरिक समाधानों की कई सीमाओं\nको गहराई से महसूस किया:\n\n * प्रदर्शन हानि: रनटाइम में निर्भरता इंजेक्शन, JS सैंडबॉक्स प्रॉक्सी, हर ऑपरेशन\n   मूल्यवान प्रदर्शन को खा रहा है\n * नाजुक अलगाव: कृत्रिम रूप से बनाए गए सैंडबॉक्स वातावरण, ब्राउज़र के मूल अलगाव\n   क्षमता तक कभी नहीं पहुंच सकते\n * बिल्ड जटिलता: निर्भरता संबंधों को संभालने के लिए, बिल्ड टूल को संशोधित करना\n   पड़ता है, जिससे सरल परियोजनाएं रखरखाव के लिए मुश्किल हो जाती हैं\n * कस्टमाइजेशन नियम: विशेष तैनाती रणनीतियां, रनटाइम प्रसंस्करण, हर कदम आधुनिक\n   विकास की मानक प्रक्रिया से भटक जाता है\n * पारिस्थितिकी सीमाएं: फ्रेमवर्क युग्मन, कस्टम API, तकनीकी चयन को विशिष्ट\n   पारिस्थितिकी में बांध देता है\n\n2019 में हमारे एक एंटरप्राइज़-स्तरीय परियोजना में ये समस्याएं विशेष रूप से\nस्पष्ट थीं। उस समय, एक बड़े उत्पाद को दस से अधिक स्वतंत्र व्यावसायिक\nउप-प्रणालियों में विभाजित किया गया था, जिन्हें एक सामान्य आधार घटक और व्यावसायिक\nघटक सेट साझा करना था। शुरू में अपनाया गया npm पैकेज-आधारित घटक साझाकरण समाधान,\nअभ्यास में गंभीर रखरखाव दक्षता समस्याएं उजागर करता था: जब साझा घटक अपडेट होता\nथा, तो उस घटक पर निर्भर सभी उप-प्रणालियों को पूर्ण बिल्ड और तैनाती प्रक्रिया से\nगुजरना पड़ता था।\n\n\nतकनीकी विकास#\n\n\nv1.0: रिमोट घटकों की खोज#\n\nघटक साझाकरण की दक्षता समस्या को हल करने के लिए, Gez v1.0 ने HTTP प्रोटोकॉल पर\nआधारित RemoteView घटक तंत्र पेश किया। यह समाधान रनटाइम में गतिशील अनुरोध के\nमाध्यम से सेवाओं के बीच कोड की ऑन-डिमांड असेंबली को सक्षम करता है, जिससे बिल्ड\nनिर्भरता श्रृंखला की लंबाई की समस्या सफलतापूर्वक हल हो गई। हालांकि, मानकीकृत\nरनटाइम संचार तंत्र की कमी के कारण, सेवाओं के बीच स्थिति समकालिकरण और घटना संचार\nमें अभी भी दक्षता अड़चनें थीं।\n\n\nv2.0: मॉड्यूल फेडरेशन प्रयास#\n\nv2.0 संस्करण में, हमने Webpack 5.0 के मॉड्यूल फेडरेशन (Module Federation) तकनीक\nको अपनाया। यह तकनीक एकीकृत मॉड्यूल लोडिंग तंत्र और रनटाइम कंटेनर के माध्यम से,\nसेवाओं के बीच सहयोग दक्षता को महत्वपूर्ण रूप से बढ़ाती है। लेकिन बड़े पैमाने पर\nअभ्यास में, मॉड्यूल फेडरेशन के बंद कार्यान्वयन तंत्र ने नई चुनौतियां लाईं: सटीक\nनिर्भरता संस्करण प्रबंधन को प्राप्त करना मुश्किल हो गया, विशेष रूप से कई सेवाओं\nके साझा निर्भरताओं को एकीकृत करते समय, संस्करण संघर्ष और रनटाइम अपवाद अक्सर\nसामने आते थे।\n\n\nESM नए युग को अपनाना#\n\nv3.0 संस्करण की योजना बनाते समय, हमने फ्रंटेंड पारिस्थितिकी के विकास\nप्रवृत्तियों का गहन अवलोकन किया और पाया कि ब्राउज़र की मूल क्षमताओं में प्रगति\nने माइक्रो-फ्रंटेंड आर्किटेक्चर के लिए नई संभावनाएं लाई हैं:\n\n\nमानकीकृत मॉड्यूल प्रणाली#\n\nES Modules (ESM) के लिए प्रमुख ब्राउज़रों के समर्थन और Import Maps मानक के\nपरिपक्व होने के साथ, फ्रंटेंड विकास ने वास्तविक मॉड्यूलरिटी युग में प्रवेश किया\nहै। Can I Use के आंकड़ों के अनुसार, वर्तमान में प्रमुख ब्राउज़र (Chrome >= 89,\nEdge >= 89, Firefox >= 108, Safari >= 16.4) ESM के मूल समर्थन दर 93.5% तक पहुंच\nगया है, जो हमें निम्नलिखित लाभ प्रदान करता है:\n\n * निर्भरता प्रबंधन मानकीकरण: Import Maps ब्राउज़र स्तर पर मॉड्यूल निर्भरता को\n   हल करने की क्षमता प्रदान करता है, जटिल रनटाइम इंजेक्शन की आवश्यकता नहीं है\n * संसाधन लोडिंग अनुकूलन: ब्राउज़र के मूल मॉड्यूल कैशिंग तंत्र, संसाधन लोडिंग\n   दक्षता को महत्वपूर्ण रूप से बढ़ाता है\n * बिल्ड प्रक्रिया सरलीकरण: ESM-आधारित विकास मोड, विकास और उत्पादन वातावरण की\n   बिल्ड प्रक्रियाओं को अधिक सुसंगत बनाता है\n\nसाथ ही, संगतता मोड समर्थन (Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >=\n14) के माध्यम से, हम ब्राउज़र कवरेज को 96.81% तक और बढ़ा सकते हैं, जो हमें उच्च\nप्रदर्शन बनाए रखते हुए, पुराने ब्राउज़रों के समर्थन को बलिदान किए बिना करने की\nअनुमति देता है।\n\n\nप्रदर्शन और अलगाव में सफलता#\n\nमूल मॉड्यूल प्रणाली न केवल मानकीकरण लाती है, बल्कि प्रदर्शन और अलगाव में\nगुणात्मक सुधार भी लाती है:\n\n * शून्य रनटाइम ओवरहेड: पारंपरिक माइक्रो-फ्रंटेंड समाधानों में JavaScript\n   सैंडबॉक्स प्रॉक्सी और रनटाइम इंजेक्शन को अलविदा कह दिया\n * विश्वसनीय अलगाव तंत्र: ESM का सख्त मॉड्यूल स्कोप स्वाभाविक रूप से सबसे\n   विश्वसनीय अलगाव क्षमता प्रदान करता है\n * सटीक निर्भरता प्रबंधन: स्थैतिक आयात विश्लेषण निर्भरता संबंधों को अधिक स्पष्ट\n   बनाता है, संस्करण नियंत्रण अधिक सटीक हो जाता है\n\n\nबिल्ड टूल का चयन#\n\nतकनीकी समाधान के कार्यान्वयन प्रक्रिया में, बिल्ड टूल का चयन एक महत्वपूर्ण\nनिर्णय बिंदु है। लगभग एक वर्ष के तकनीकी शोध और अभ्यास के बाद, हमारा चयन\nनिम्नलिखित विकास से गुजरा:\n\n 1. Vite अन्वेषण\n    \n    * लाभ: ESM-आधारित विकास सर्वर, अत्यधिक विकास अनुभव प्रदान करता है\n    * चुनौती: विकास और उत्पादन वातावरण की बिल्ड अंतर, कुछ अनिश्चितता लाती है\n\n 2. Rspack स्थापना\n    \n    * प्रदर्शन लाभ: Rust पर आधारित उच्च प्रदर्शन संकलन, बिल्ड गति को महत्वपूर्ण\n      रूप से बढ़ाता है\n    * पारिस्थितिकी समर्थन: Webpack पारिस्थितिकी के साथ उच्च संगतता, माइग्रेशन\n      लागत को कम करता है\n    * ESM समर्थन: Rslib परियोजना के अभ्यास के माध्यम से, ESM बिल्डिंग में इसकी\n      विश्वसनीयता सत्यापित की गई\n\nइस निर्णय ने हमें विकास अनुभव बनाए रखते हुए, अधिक स्थिर उत्पादन वातावरण समर्थन\nप्राप्त करने की अनुमति दी। ESM और Rspack के संयोजन पर आधारित, हमने अंततः एक उच्च\nप्रदर्शन, कम आक्रामक माइक्रो-फ्रंटेंड समाधान का निर्माण किया।\n\n\nभविष्य की संभावनाएं#\n\nभविष्य की विकास योजनाओं में, Gez फ्रेमवर्क निम्नलिखित तीन दिशाओं पर ध्यान\nकेंद्रित करेगा:\n\n\nImport Maps गहन अनुकूलन#\n\n * गतिशील निर्भरता प्रबंधन: रनटाइम निर्भरता संस्करणों का बुद्धिमान शेड्यूलिंग,\n   बहु-एप्लिकेशन निर्भरता संघर्ष को हल करना\n * प्रीलोड रणनीति: रूटिंग विश्लेषण पर आधारित बुद्धिमान प्रीलोडिंग, संसाधन लोडिंग\n   दक्षता बढ़ाना\n * बिल्ड अनुकूलन: इष्टतम Import Maps कॉन्फ़िगरेशन का स्वचालित जनरेशन, डेवलपर्स\n   के मैन्युअल कॉन्फ़िगरेशन लागत को कम करना\n\n\nफ्रेमवर्क-अज्ञेय रूटिंग समाधान#\n\n * एकीकृत रूटिंग एब्स्ट्रक्शन: फ्रेमवर्क-अज्ञेय रूटिंग इंटरफ़ेस डिज़ाइन, Vue,\n   React जैसे प्रमुख फ्रेमवर्क का समर्थन\n * माइक्रो-एप्लिकेशन रूटिंग: एप्लिकेशनों के बीच रूटिंग लिंकेज, URL और एप्लिकेशन\n   स्थिति की स्थिरता बनाए रखना\n * रूटिंग मिडलवेयर: विस्तार योग्य मिडलवेयर तंत्र, अनुमति नियंत्रण, पृष्ठ संक्रमण\n   जैसी सुविधाओं का समर्थन\n\n\nक्रॉस-फ्रेमवर्क संचार सर्वोत्तम प्रथाएं#\n\n * उदाहरण एप्लिकेशन: Vue, React, Preact जैसे प्रमुख फ्रेमवर्क को कवर करने वाले\n   पूर्ण क्रॉस-फ्रेमवर्क संचार उदाहरण प्रदान करना\n * स्थिति समकालिकरण: ESM-आधारित हल्के-वजन स्थिति साझाकरण समाधान\n * घटना बस: मानकीकृत घटना संचार तंत्र, एप्लिकेशनों के बीच डिकपल्ड संचार का\n   समर्थन\n\nइन अनुकूलन और विस्त","routePath":"/hi/blog/birth-of-gez","lang":"hi","toc":[{"text":"परियोजना पृष्ठभूमि","id":"परियोजना-पृष्ठभूमि","depth":2,"charIndex":3},{"text":"पारंपरिक समाधानों की सीमाएं","id":"पारंपरिक-समाधानों-की-सीमाएं","depth":3,"charIndex":394},{"text":"तकनीकी विकास","id":"तकनीकी-विकास","depth":2,"charIndex":1614},{"text":"v1.0: रिमोट घटकों की खोज","id":"v10-रिमोट-घटकों-की-खोज","depth":3,"charIndex":1630},{"text":"v2.0: मॉड्यूल फेडरेशन प्रयास","id":"v20-मॉड्यूल-फेडरेशन-प्रयास","depth":3,"charIndex":2080},{"text":"ESM नए युग को अपनाना","id":"esm-नए-युग-को-अपनाना","depth":2,"charIndex":2602},{"text":"मानकीकृत मॉड्यूल प्रणाली","id":"मानकीकृत-मॉड्यूल-प्रणाली","depth":3,"charIndex":2836},{"text":"प्रदर्शन और अलगाव में सफलता","id":"प्रदर्शन-और-अलगाव-में-सफलता","depth":3,"charIndex":3880},{"text":"बिल्ड टूल का चयन","id":"बिल्ड-टूल-का-चयन","depth":3,"charIndex":4392},{"text":"भविष्य की संभावनाएं","id":"भविष्य-की-संभावनाएं","depth":2,"charIndex":5323},{"text":"Import Maps गहन अनुकूलन","id":"import-maps-गहन-अनुकूलन","depth":3,"charIndex":5437},{"text":"फ्रेमवर्क-अज्ञेय रूटिंग समाधान","id":"फ्रेमवर्क-अज्ञेय-रूटिंग-समाधान","depth":3,"charIndex":5809},{"text":"क्रॉस-फ्रेमवर्क संचार सर्वोत्तम प्रथाएं","id":"क्रॉस-फ्रेमवर्क-संचार-सर्वोत्तम-प्रथाएं","depth":3,"charIndex":6182}],"domain":"","frontmatter":{"titleSuffix":"माइक्रो-फ्रंटेंड की चुनौतियों से ESM नवाचार तक: Gez फ्रेमवर्क का विकास पथ","description":"Gez फ्रेमवर्क के पारंपरिक माइक्रो-फ्रंटेंड आर्किटेक्चर की चुनौतियों से ESM-आधारित नवाचार तक के विकास पर गहन चर्चा, प्रदर्शन अनुकूलन, निर्भरता प्रबंधन और बिल्ड टूल चयन जैसे क्षेत्रों में तकनीकी अनुभव साझा करना।","head":[["meta",{"property":"keywords","content":"Gez, माइक्रो-फ्रंटेंड फ्रेमवर्क, ESM, Import Maps, Rspack, मॉड्यूल फेडरेशन, निर्भरता प्रबंधन, प्रदर्शन अनुकूलन, तकनीकी विकास, सर्वर-साइड रेंडरिंग"}]],"sidebar":false},"version":""},{"id":109,"title":"टीम ब्लॉग","content":"#\n\nGez टीम के तकनीकी ब्लॉग में आपका स्वागत है! यहाँ हम फ्रेमवर्क विकास प्रक्रिया\nमें प्राप्त अनुभव, तकनीकी नवाचार और सर्वोत्तम प्रथाओं को साझा करेंगे।\n\n\nनवीनतम लेख#\n\n * 2025-02-25 घटक साझाकरण से मूल मॉड्यूलरिटी तक: Gez माइक्रो फ्रंटएंड फ्रेमवर्क\n   का विकास पथ\n   \n   > Gez फ्रेमवर्क के पारंपरिक घटक साझाकरण से ESM आधारित मूल मॉड्यूलरिटी तक के\n   > विकास यात्रा का अन्वेषण करें, प्रदर्शन अनुकूलन, निर्भरता प्रबंधन और निर्माण\n   > उपकरण चयन जैसे तकनीकी व्यावहारिक अनुभवों को साझा करें।","routePath":"/hi/blog/","lang":"hi","toc":[{"text":"नवीनतम लेख","id":"नवीनतम-लेख","depth":2,"charIndex":152}],"domain":"","frontmatter":{"titleSuffix":"Gez टीम ब्लॉग","description":"Gez टीम का तकनीकी ब्लॉग, फ्रेमवर्क विकास अनुभव, सर्वोत्तम प्रथाओं और तकनीकी नवाचारों को साझा करना।","head":[["meta",{"property":"keywords","content":"Gez, टीम ब्लॉग, तकनीकी साझाकरण, सर्वोत्तम प्रथाएँ, विकास अनुभव"}]],"sidebar":false},"version":""},{"id":110,"title":"पथ उपनाम (Path Alias)","content":"#\n\nपथ उपनाम (Path Alias) एक मॉड्यूल आयात पथ मैपिंग तंत्र है, जो डेवलपर्स को पूर्ण\nमॉड्यूल पथ के बजाय संक्षिप्त और अर्थपूर्ण पहचानकर्ता (identifier) का उपयोग करने\nकी अनुमति देता है। Gez में, पथ उपनाम तंत्र के निम्नलिखित लाभ हैं:\n\n * आयात पथ को सरल बनाना: लंबे रिलेटिव पथ के बजाय अर्थपूर्ण उपनाम का उपयोग करके\n   कोड की पठनीयता बढ़ाना\n * गहरे नेस्टिंग से बचना: बहुस्तरीय डायरेक्टरी संदर्भ (जैसे ../../../../) से\n   होने वाली रखरखाव कठिनाइयों को दूर करना\n * प्रकार सुरक्षा: TypeScript के प्रकार प्रणाली के साथ पूर्ण एकीकरण, कोड पूर्णता\n   और प्रकार जांच प्रदान करना\n * मॉड्यूल रिज़ॉल्यूशन ऑप्टिमाइज़ेशन: पूर्वनिर्धारित पथ मैपिंग के माध्यम से\n   मॉड्यूल रिज़ॉल्यूशन प्रदर्शन को बढ़ाना\n\n\nडिफ़ॉल्ट उपनाम तंत्र#\n\nGez सेवा नाम (Service Name) पर आधारित स्वचालित उपनाम तंत्र का उपयोग करता है, जो\nकॉन्फ़िगरेशन पर सम्मेलन (convention over configuration) को प्राथमिकता देता है।\nइसके निम्नलिखित विशेषताएं हैं:\n\n * स्वचालित कॉन्फ़िगरेशन: package.json में name फ़ील्ड के आधार पर स्वचालित रूप\n   से उपनाम उत्पन्न करना, मैन्युअल कॉन्फ़िगरेशन की आवश्यकता नहीं\n * एकीकृत मानक: सभी सेवा मॉड्यूल को एक समान नामकरण और संदर्भ मानक का पालन करना\n   सुनिश्चित करना\n * प्रकार समर्थन: npm run build:dts कमांड के साथ, स्वचालित रूप से प्रकार घोषणा\n   फ़ाइलें उत्पन्न करना, जो क्रॉस-सेवा प्रकार अनुमान (type inference) को सक्षम\n   करता है\n * पूर्वानुमेयता: सेवा नाम के माध्यम से मॉड्यूल संदर्भ पथ का अनुमान लगाना,\n   रखरखाव लागत को कम करना\n\n\nकॉन्फ़िगरेशन विवरण#\n\n\npackage.json कॉन्फ़िगरेशन#\n\npackage.json में, name फ़ील्ड के माध्यम से सेवा का नाम परिभाषित करें, यह नाम\nसेवा के डिफ़ॉल्ट उपनाम उपसर्ग (prefix) के रूप में कार्य करेगा:\n\n\n\n\ntsconfig.json कॉन्फ़िगरेशन#\n\nTypeScript को उपनाम पथ को सही ढंग से रिज़ॉल्व करने के लिए, tsconfig.json में\npaths मैपिंग को कॉन्फ़िगर करना आवश्यक है:\n\n\n\n\nउपयोग उदाहरण#\n\n\nसेवा आंतरिक मॉड्यूल आयात करना#\n\n\n\n\nअन्य सेवा मॉड्यूल आयात करना#\n\n\n\nसर्वोत्तम अभ्यास\n * रिलेटिव पथ के बजाय उपनाम पथ का प्राथमिकता से उपयोग करें\n * उपनाम पथ को अर्थपूर्ण और सुसंगत रखें\n * उपनाम पथ में बहुत अधिक डायरेक्टरी स्तरों का उपयोग करने से बचें\n\n\n\n\nक्रॉस-सेवा आयात#\n\nजब मॉड्यूल लिंक (Module Link) कॉन्फ़िगर किया जाता है, तो अन्य सेवा के मॉड्यूल को\nउसी तरह आयात किया जा सकता है:\n\n\n\n\nकस्टम उपनाम#\n\nथर्ड-पार्टी पैकेज या विशेष परिदृश्यों के लिए, Gez कॉन्फ़िगरेशन फ़ाइल के माध्यम\nसे कस्टम उपनाम परिभाषित किए जा सकते हैं:\n\n\n\nध्यान देने योग्य बातें\n 1. व्यावसायिक मॉड्यूल के लिए, परियोजना की सुसंगतता बनाए रखने के लिए डिफ़ॉल्ट\n    उपनाम तंत्र का उपयोग करने की सिफारिश की जाती है\n 2. कस्टम उपनाम मुख्य रूप से थर्ड-पार्टी पैकेज की विशेष आवश्यकताओं को संभालने या\n    विकास अनुभव को अनुकूलित करने के लिए उपयोग किए जाते हैं\n 3. कस्टम उपनाम का अत्यधिक उपयोग कोड की रखरखाव क्षमता और बिल्ड ऑप्टिमाइज़ेशन को\n    प्रभावित कर सकता है","routePath":"/hi/guide/essentials/alias","lang":"hi","toc":[{"text":"डिफ़ॉल्ट उपनाम तंत्र","id":"डिफ़ॉल्ट-उपनाम-तंत्र","depth":2,"charIndex":682},{"text":"कॉन्फ़िगरेशन विवरण","id":"कॉन्फ़िगरेशन-विवरण","depth":2,"charIndex":1409},{"text":"package.json कॉन्फ़िगरेशन","id":"packagejson-कॉन्फ़िगरेशन","depth":3,"charIndex":1431},{"text":"tsconfig.json कॉन्फ़िगरेशन","id":"tsconfigjson-कॉन्फ़िगरेशन","depth":3,"charIndex":1603},{"text":"उपयोग उदाहरण","id":"उपयोग-उदाहरण","depth":2,"charIndex":1755},{"text":"सेवा आंतरिक मॉड्यूल आयात करना","id":"सेवा-आंतरिक-मॉड्यूल-आयात-करना","depth":3,"charIndex":1771},{"text":"अन्य सेवा मॉड्यूल आयात करना","id":"अन्य-सेवा-मॉड्यूल-आयात-करना","depth":3,"charIndex":1806},{"text":"क्रॉस-सेवा आयात","id":"क्रॉस-सेवा-आयात","depth":3,"charIndex":2024},{"text":"कस्टम उपनाम","id":"कस्टम-उपनाम","depth":3,"charIndex":2157}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क मॉड्यूल आयात पथ मैपिंग गाइड","description":"Gez फ्रेमवर्क के पथ उपनाम (Path Alias) तंत्र के बारे में विस्तृत जानकारी, जिसमें आयात पथ को सरल बनाना, गहरे नेस्टिंग से बचना, प्रकार सुरक्षा और मॉड्यूल रिज़ॉल्यूशन ऑप्टिमाइज़ेशन जैसी विशेषताएं शामिल हैं, जो डेवलपर्स को कोड की रखरखाव क्षमता बढ़ाने में मदद करती हैं।","head":[["meta",{"property":"keywords","content":"Gez, पथ उपनाम, Path Alias, TypeScript, मॉड्यूल आयात, पथ मैपिंग, कोड रखरखाव क्षमता"}]]},"version":""},{"id":111,"title":"बेस पथ","content":"#\n\nबेस पथ (Base Path) एप्लिकेशन में स्टेटिक संसाधनों (जैसे JavaScript, CSS, इमेज\nआदि) के एक्सेस पथ का प्रीफ़िक्स होता है। Gez में, बेस पथ को सही तरीके से\nकॉन्फ़िगर करना निम्नलिखित परिदृश्यों के लिए महत्वपूर्ण है:\n\n * मल्टी-एनवायरनमेंट डिप्लॉयमेंट: डेवलपमेंट, टेस्टिंग, प्रोडक्शन आदि विभिन्न\n   वातावरणों में संसाधन एक्सेस का समर्थन\n * मल्टी-रिजन डिप्लॉयमेंट: विभिन्न क्षेत्रों या देशों में क्लस्टर डिप्लॉयमेंट की\n   आवश्यकताओं को पूरा करना\n * CDN वितरण: स्टेटिक संसाधनों का वैश्विक वितरण और त्वरण प्राप्त करना\n\n\nडिफ़ॉल्ट पथ मैकेनिज्म#\n\nGz प्रोजेक्ट के package.json में name फ़ील्ड को पढ़कर स्टेटिक संसाधनों के बेस पथ\nको स्वचालित रूप से जनरेट करता है: /your-app-name/.\n\n\n\nयह कन्वेंशन-ओवर-कॉन्फ़िगरेशन डिज़ाइन के निम्नलिखित लाभ हैं:\n\n * संगतता: सभी स्टेटिक संसाधन एक समान एक्सेस पथ का उपयोग करते हैं\n * पूर्वानुमेयता: package.json के name फ़ील्ड के माध्यम से संसाधनों के एक्सेस पथ\n   का अनुमान लगाया जा सकता है\n * रखरखाव क्षमता: अतिरिक्त कॉन्फ़िगरेशन की आवश्यकता नहीं होती, जिससे रखरखाव लागत\n   कम होती है\n\n\nडायनामिक पथ कॉन्फ़िगरेशन#\n\nवास्तविक प्रोजेक्ट्स में, हमें अक्सर एक ही कोड को विभिन्न वातावरणों या क्षेत्रों\nमें डिप्लॉय करने की आवश्यकता होती है। Gez डायनामिक बेस पथ का समर्थन प्रदान करता\nहै, जिससे एप्लिकेशन विभिन्न डिप्लॉयमेंट परिदृश्यों के अनुकूल हो सकता है।\n\n\nउपयोग के परिदृश्य#\n\nसेकेंडरी डायरेक्टरी डिप्लॉयमेंट#\n\n\n\nस्वतंत्र डोमेन डिप्लॉयमेंट#\n\n\n\n\nकॉन्फ़िगरेशन विधि#\n\ngez.render() मेथड के base पैरामीटर के माध्यम से, आप अनुरोध संदर्भ के आधार पर बेस\nपथ को डायनामिक रूप से सेट कर सकते हैं:\n\n","routePath":"/hi/guide/essentials/base-path","lang":"hi","toc":[{"text":"डिफ़ॉल्ट पथ मैकेनिज्म","id":"डिफ़ॉल्ट-पथ-मैकेनिज्म","depth":2,"charIndex":511},{"text":"डायनामिक पथ कॉन्फ़िगरेशन","id":"डायनामिक-पथ-कॉन्फ़िगरेशन","depth":2,"charIndex":1005},{"text":"उपयोग के परिदृश्य","id":"उपयोग-के-परिदृश्य","depth":3,"charIndex":1268},{"text":"सेकेंडरी डायरेक्टरी डिप्लॉयमेंट","id":"सेकेंडरी-डायरेक्टरी-डिप्लॉयमेंट","depth":4,"charIndex":1288},{"text":"स्वतंत्र डोमेन डिप्लॉयमेंट","id":"स्वतंत्र-डोमेन-डिप्लॉयमेंट","depth":4,"charIndex":1324},{"text":"कॉन्फ़िगरेशन विधि","id":"कॉन्फ़िगरेशन-विधि","depth":3,"charIndex":1356}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क स्टेटिक संसाधन पथ कॉन्फ़िगरेशन गाइड","description":"Gez फ्रेमवर्क में बेस पथ कॉन्फ़िगरेशन के बारे में विस्तृत जानकारी, जिसमें मल्टी-एनवायरनमेंट डिप्लॉयमेंट, CDN वितरण और संसाधन एक्सेस पथ सेटिंग शामिल हैं, जो डेवलपर्स को लचीली स्टेटिक संसाधन प्रबंधन प्राप्त करने में मदद करती है।","head":[["meta",{"property":"keywords","content":"Gez, बेस पथ, Base Path, CDN, स्टेटिक संसाधन, मल्टी-एनवायरनमेंट डिप्लॉयमेंट, संसाधन प्रबंधन"}]]},"version":""},{"id":112,"title":"क्लाइंट-साइड रेंडरिंग","content":"\n${rc.importmap()} // इम्पोर्ट मैप ${rc.moduleEntry()} // एंट्री मॉड्यूल\n${rc.modulePreload()} // मॉड्यूल प्रीलोड","routePath":"/hi/guide/essentials/csr","lang":"hi","toc":[{"text":"उपयोग के परिदृश्य","id":"उपयोग-के-परिदृश्य","depth":2,"charIndex":-1},{"text":"कॉन्फ़िगरेशन विवरण","id":"कॉन्फ़िगरेशन-विवरण","depth":2,"charIndex":-1},{"text":"HTML टेम्पलेट कॉन्फ़िगरेशन","id":"html-टेम्पलेट-कॉन्फ़िगरेशन","depth":3,"charIndex":-1},{"text":"स्टेटिक HTML जेनरेशन","id":"स्टेटिक-html-जेनरेशन","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क क्लाइंट-साइड रेंडरिंग गाइड","description":"Gez फ्रेमवर्क की क्लाइंट-साइड रेंडरिंग मैकेनिज्म की विस्तृत जानकारी, जिसमें स्टेटिक बिल्ड, डिप्लॉयमेंट स्ट्रैटेजी और बेस्ट प्रैक्टिसेस शामिल हैं, जो डेवलपर्स को सर्वरलेस वातावरण में एफिशिएंट फ्रंटएंड रेंडरिंग प्राप्त करने में मदद करती है।","head":[["meta",{"property":"keywords","content":"Gez, क्लाइंट-साइड रेंडरिंग, CSR, स्टेटिक बिल्ड, फ्रंटएंड रेंडरिंग, सर्वरलेस डिप्लॉयमेंट, परफॉर्मेंस ऑप्टिमाइज़ेशन"}]]},"version":""},{"id":113,"title":"मॉड्यूल लिंकिंग","content":"#\n\nGez फ्रेमवर्क सेवा-अंतर कोड शेयरिंग और डिपेंडेंसी मैनेजमेंट के लिए एक संपूर्ण\nमॉड्यूल लिंकिंग मैकेनिज्म प्रदान करता है। यह मैकेनिज्म ESM (ECMAScript Module)\nस्पेसिफिकेशन पर आधारित है, जो सोर्स कोड लेवल पर मॉड्यूल एक्सपोर्ट और इम्पोर्ट,\nसाथ ही पूर्ण डिपेंडेंसी मैनेजमेंट फंक्शनलिटी को सपोर्ट करता है।\n\n\nमुख्य अवधारणाएं#\n\nमॉड्यूल एक्सपोर्ट#\n\nमॉड्यूल एक्सपोर्ट सेवा में विशिष्ट कोड यूनिट (जैसे कंपोनेंट्स, यूटिलिटी फंक्शन्स\nआदि) को ESM फॉर्मेट में एक्सपोज करने की प्रक्रिया है। यह दो प्रकार के एक्सपोर्ट\nको सपोर्ट करता है:\n\n * सोर्स कोड एक्सपोर्ट: प्रोजेक्ट में सोर्स कोड फाइल्स को सीधे एक्सपोर्ट करना\n * डिपेंडेंसी एक्सपोर्ट: प्रोजेक्ट में उपयोग किए जाने वाले थर्ड-पार्टी\n   डिपेंडेंसी पैकेज को एक्सपोर्ट करना\n\nमॉड्यूल इम्पोर्ट#\n\nमॉड्यूल इम्पोर्ट सेवा में अन्य सेवाओं द्वारा एक्सपोर्ट किए गए कोड यूनिट को\nरेफरेंस करने की प्रक्रिया है। यह कई इंस्टॉलेशन मोड को सपोर्ट करता है:\n\n * सोर्स कोड इंस्टॉलेशन: डेवलपमेंट एनवायरनमेंट के लिए उपयुक्त, रियल-टाइम\n   मॉडिफिकेशन और हॉट रीलोडिंग को सपोर्ट करता है\n * पैकेज इंस्टॉलेशन: प्रोडक्शन एनवायरनमेंट के लिए उपयुक्त, बिल्ड आर्टिफैक्ट्स का\n   सीधे उपयोग करता है\n\n\nप्रीलोडिंग मैकेनिज्म#\n\nसेवा परफॉर्मेंस को ऑप्टिमाइज़ करने के लिए, Gez ने इंटेलिजेंट मॉड्यूल प्रीलोडिंग\nमैकेनिज्म लागू किया है:\n\n 1. डिपेंडेंसी एनालिसिस\n    \n    * बिल्ड टाइम पर कंपोनेंट्स के बीच डिपेंडेंसी रिलेशनशिप का एनालिसिस\n    * क्रिटिकल पाथ पर कोर मॉड्यूल की पहचान\n    * मॉड्यूल लोडिंग प्रायोरिटी का निर्धारण\n\n 2. लोडिंग स्ट्रैटेजी\n    \n    * इमीडिएट लोडिंग: क्रिटिकल पाथ पर कोर मॉड्यूल\n    * लेज़ी लोडिंग: नॉन-क्रिटिकल फंक्शनलिटी मॉड्यूल\n    * ऑन-डिमांड लोडिंग: कंडीशनल रेंडरिंग वाले मॉड्यूल\n\n 3. रिसोर्स ऑप्टिमाइज़ेशन\n    \n    * इंटेलिजेंट कोड स्प्लिटिंग स्ट्रैटेजी\n    * मॉड्यूल-लेवल कैश मैनेजमेंट\n    * ऑन-डिमांड कंपाइलेशन और बंडलिंग\n\n\nमॉड्यूल एक्सपोर्ट#\n\n\nकॉन्फ़िगरेशन विवरण#\n\nentry.node.ts में एक्सपोर्ट किए जाने वाले मॉड्यूल को कॉन्फ़िगर करें:\n\n\n\nएक्सपोर्ट कॉन्फ़िगरेशन दो प्रकार को सपोर्ट करता है:\n\n * root:*: सोर्स कोड फाइल्स एक्सपोर्ट करें, पाथ प्रोजेक्ट रूट के सापेक्ष\n * npm:*: थर्ड-पार्टी डिपेंडेंसी एक्सपोर्ट करें, सीधे पैकेज नाम निर्दिष्ट करें\n\n\nमॉड्यूल इम्पोर्ट#\n\n\nकॉन्फ़िगरेशन विवरण#\n\nentry.node.ts में इम्पोर्ट किए जाने वाले मॉड्यूल को कॉन्फ़िगर करें:\n\n\n\nकॉन्फ़िगरेशन आइटम्स विवरण:\n\n 1. imports: रिमोट मॉड्यूल के लोकल पाथ को कॉन्फ़िगर करें\n    \n    * सोर्स कोड इंस्टॉलेशन: बिल्ड आर्टिफैक्ट डायरेक्टरी (dist) को पॉइंट करें\n    * पैकेज इंस्टॉलेशन: सीधे पैकेज डायरेक्टरी को पॉइंट करें\n\n 2. externals: एक्सटर्नल डिपेंडेंसी कॉन्फ़िगर करें\n    \n    * रिमोट मॉड्यूल में डिपेंडेंसी शेयर करने के लिए उपयोग किया जाता है\n    * समान डिपेंडेंसी के डुप्लीकेट बंडलिंग से बचें\n    * मल्टीपल मॉड्यूल में डिपेंडेंसी शेयर करने को सपोर्ट करता है\n\n\nइंस्टॉलेशन मोड#\n\nसोर्स कोड इंस्टॉलेशन#\n\nडेवलपमेंट एनवायरनमेंट के लिए उपयुक्त, रियल-टाइम मॉडिफिकेशन और हॉट रीलोडिंग को\nसपोर्ट करता है।\n\n 1. वर्कस्पेस मोड Monorepo प्रोजेक्ट में उपयोग के लिए अनुशंसित:\n\n\n\n 2. लिंक मोड लोकल डेवलपमेंट और डिबगिंग के लिए उपयोग किया जाता है:\n\n\n\nपैकेज इंस्टॉलेशन#\n\nप्रोडक्शन एनवायरनमेंट के लिए उपयुक्त, बिल्ड आर्टिफैक्ट्स का सीधे उपयोग करता है।\n\n 1. NPM रजिस्ट्री npm रजिस्ट्री के माध्यम से इंस्टॉल करें:\n\n\n\n 2. स्टैटिक सर्वर HTTP/HTTPS प्रोटोकॉल के माध्यम से इंस्टॉल करें:\n\n\n\n\nपैकेज बिल्डिंग#\n\n\nकॉन्फ़िगरेशन विवरण#\n\nentry.node.ts में बिल्ड ऑप्शन्स को कॉन्फ़िगर करें:\n\n\n\n\nबिल्ड आर्टिफैक्ट्स#\n\n\n\n\nपब्लिश प्रोसेस#\n\n\n\n\nबेस्ट प्रैक्टिसेज#\n\n\nडेवलपमेंट एनवायरनमेंट कॉन्फ़िगरेशन#\n\n * डिपेंडेंसी मैनेजमेंट\n   \n   * डिपेंडेंसी इंस्टॉल करने के लिए वर्कस्पेस या लिंक मोड का उपयोग करें\n   * डिपेंडेंसी वर्जन को यूनिफाइड मैनेज करें\n   * समान डिपेंडेंसी के डुप्लीकेट इंस्टॉलेशन से बचें\n\n * डेवलपमेंट एक्सपीरियंस\n   \n   * हॉट रीलोडिंग फीचर को सक्षम करें\n   * उपयुक्त प्रीलोडिंग स्ट्रैटेजी कॉन्फ़िगर करें\n   * बिल्ड स्पीड को ऑप्टिमाइज़ करें\n\n\nप्रोडक्शन एनवायरनमेंट कॉन्फ़िगरेशन#\n\n * डिप्लॉयमेंट स्ट्रैटेजी\n   \n   * NPM रजिस्ट्री या स्टैटिक सर्वर का उपयोग करें\n   * बिल्ड आर्टिफैक्ट्स की इंटीग्रिटी सुनिश्चित करें\n   * ग्रे रिलीज़ मैकेनिज्म लागू करें\n\n * परफॉर्मेंस ऑप्टिमाइज़ेशन\n   \n   * रिसोर्स प्रीलोडिंग को उचित रूप से कॉन्फ़िगर करें\n   * मॉड्यूल लोडिंग ऑर्डर को ऑप्टिमाइज़ करें\n   * प्रभावी कैशिंग स्ट्रैटेजी लागू करें\n\n\nवर्जन मैनेजमेंट#\n\n * वर्जनिंग स्टैंडर्ड\n   \n   * सेमेंटिक वर्जनिंग स्टैंडर्ड का पालन करें\n   * विस्तृत चेंजलॉग बनाए रखें\n   * वर्जन कंपैटिबिलिटी टेस्टिंग करें\n\n * डिपेंडेंसी अपडेट\n   \n   * डिपेंडेंसी पैकेज को समय पर अपडेट करें\n   * नियमित सुरक्षा","routePath":"/hi/guide/essentials/module-link","lang":"hi","toc":[{"text":"मुख्य अवधारणाएं","id":"मुख्य-अवधारणाएं","depth":3,"charIndex":304},{"text":"मॉड्यूल एक्सपोर्ट","id":"मॉड्यूल-एक्सपोर्ट","depth":4,"charIndex":322},{"text":"मॉड्यूल इम्पोर्ट","id":"मॉड्यूल-इम्पोर्ट","depth":4,"charIndex":711},{"text":"प्रीलोडिंग मैकेनिज्म","id":"प्रीलोडिंग-मैकेनिज्म","depth":3,"charIndex":1102},{"text":"मॉड्यूल एक्सपोर्ट","id":"मॉड्यूल-एक्सपोर्ट-1","depth":2,"charIndex":1748},{"text":"कॉन्फ़िगरेशन विवरण","id":"कॉन्फ़िगरेशन-विवरण","depth":3,"charIndex":1769},{"text":"मॉड्यूल इम्पोर्ट","id":"मॉड्यूल-इम्पोर्ट-1","depth":2,"charIndex":2069},{"text":"कॉन्फ़िगरेशन विवरण","id":"कॉन्फ़िगरेशन-विवरण-1","depth":3,"charIndex":2089},{"text":"इंस्टॉलेशन मोड","id":"इंस्टॉलेशन-मोड","depth":3,"charIndex":2654},{"text":"सोर्स कोड इंस्टॉलेशन","id":"सोर्स-कोड-इंस्टॉलेशन","depth":4,"charIndex":2671},{"text":"पैकेज इंस्टॉलेशन","id":"पैकेज-इंस्टॉलेशन","depth":4,"charIndex":2925},{"text":"पैकेज बिल्डिंग","id":"पैकेज-बिल्डिंग","depth":2,"charIndex":3157},{"text":"कॉन्फ़िगरेशन विवरण","id":"कॉन्फ़िगरेशन-विवरण-2","depth":3,"charIndex":3175},{"text":"बिल्ड आर्टिफैक्ट्स","id":"बिल्ड-आर्टिफैक्ट्स","depth":3,"charIndex":3251},{"text":"पब्लिश प्रोसेस","id":"पब्लिश-प्रोसेस","depth":3,"charIndex":3275},{"text":"बेस्ट प्रैक्टिसेज","id":"बेस्ट-प्रैक्टिसेज","depth":2,"charIndex":3295},{"text":"डेवलपमेंट एनवायरनमेंट कॉन्फ़िगरेशन","id":"डेवलपमेंट-एनवायरनमेंट-कॉन्फ़िगरेशन","depth":3,"charIndex":3316},{"text":"प्रोडक्शन एनवायरनमेंट कॉन्फ़िगरेशन","id":"प्रोडक्शन-एनवायरनमेंट-कॉन्फ़िगरेशन","depth":3,"charIndex":3706},{"text":"वर्जन मैनेजमेंट","id":"वर्जन-मैनेजमेंट","depth":3,"charIndex":4088}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क सेवा-अंतर कोड शेयरिंग मैकेनिज्म","description":"Gez फ्रेमवर्क के मॉड्यूल लिंकिंग मैकेनिज्म का विस्तृत विवरण, जिसमें सेवा-अंतर कोड शेयरिंग, डिपेंडेंसी मैनेजमेंट और ESM स्पेसिफिकेशन का कार्यान्वयन शामिल है, जो डेवलपर्स को हाई-परफॉर्मेंस माइक्रो-फ्रंटेंड एप्लिकेशन बनाने में मदद करता है।","head":[["meta",{"property":"keywords","content":"Gez, मॉड्यूल लिंकिंग, Module Link, ESM, कोड शेयरिंग, डिपेंडेंसी मैनेजमेंट, माइक्रो-फ्रंटेंड"}]]},"version":""},{"id":114,"title":"रेंडरिंग कॉन्टेक्स्ट","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/hi/guide/essentials/render-context","lang":"hi","toc":[{"text":"उपयोग विधि","id":"उपयोग-विधि","depth":2,"charIndex":-1},{"text":"मुख्य फीचर्स","id":"मुख्य-फीचर्स","depth":2,"charIndex":-1},{"text":"डिपेंडेंसी कलेक्शन","id":"डिपेंडेंसी-कलेक्शन","depth":3,"charIndex":-1},{"text":"ऑन-डिमांड कलेक्शन","id":"ऑन-डिमांड-कलेक्शन","depth":4,"charIndex":-1},{"text":"ऑटोमेटेड हैंडलिंग","id":"ऑटोमेटेड-हैंडलिंग","depth":4,"charIndex":-1},{"text":"परफॉर्मेंस ऑप्टिमाइज़ेशन","id":"परफॉर्मेंस-ऑप्टिमाइज़ेशन","depth":4,"charIndex":-1},{"text":"संसाधन इंजेक्शन","id":"संसाधन-इंजेक्शन","depth":3,"charIndex":-1},{"text":"संसाधन इंजेक्शन ऑर्डर","id":"संसाधन-इंजेक्शन-ऑर्डर","depth":3,"charIndex":-1},{"text":"पूर्ण रेंडरिंग प्रक्रिया","id":"पूर्ण-रेंडरिंग-प्रक्रिया","depth":2,"charIndex":-1},{"text":"एडवांस्ड फीचर्स","id":"एडवांस्ड-फीचर्स","depth":2,"charIndex":-1},{"text":"बेस पाथ कॉन्फ़िगरेशन","id":"बेस-पाथ-कॉन्फ़िगरेशन","depth":3,"charIndex":-1},{"text":"इम्पोर्ट मैपिंग मोड","id":"इम्पोर्ट-मैपिंग-मोड","depth":3,"charIndex":-1},{"text":"एंट्री फंक्शन कॉन्फ़िगरेशन","id":"एंट्री-फंक्शन-कॉन्फ़िगरेशन","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क सर्वर-साइड रेंडरिंग कोर मैकेनिज्म","description":"Gez फ्रेमवर्क के रेंडरिंग कॉन्टेक्स्ट (RenderContext) मैकेनिज्म का विस्तृत विवरण, जिसमें संसाधन प्रबंधन, HTML जनरेशन और ESM मॉड्यूल सिस्टम शामिल हैं, डेवलपर्स को सर्वर-साइड रेंडरिंग फीचर्स को समझने और उपयोग करने में मदद करता है।","head":[["meta",{"property":"keywords","content":"Gez, रेंडरिंग कॉन्टेक्स्ट, RenderContext, SSR, सर्वर-साइड रेंडरिंग, ESM, संसाधन प्रबंधन"}]]},"version":""},{"id":115,"title":"Rspack","content":"#\n\nGez Rspack बिल्ड सिस्टम पर आधारित है, जो Rspack की हाई-परफॉर्मेंस बिल्ड क्षमताओं\nका पूरा उपयोग करता है। यह दस्तावेज़ Gez फ्रेमवर्क में Rspack की भूमिका और मुख्य\nकार्यक्षमताओं का परिचय देगा।\n\n\nविशेषताएं#\n\nRspack Gez फ्रेमवर्क का मुख्य बिल्ड सिस्टम है, जो निम्नलिखित मुख्य विशेषताएं\nप्रदान करता है:\n\n * हाई-परफॉर्मेंस बिल्ड: Rust पर आधारित बिल्ड इंजन, जो बड़े प्रोजेक्ट्स के लिए\n   तेज़ कंपाइलेशन प्रदान करता है, जिससे बिल्ड स्पीड में उल्लेखनीय सुधार होता है।\n * डेवलपमेंट अनुभव ऑप्टिमाइज़ेशन: हॉट रीलोड (HMR), इंक्रीमेंटल कंपाइलेशन जैसी\n   आधुनिक डेवलपमेंट विशेषताओं का समर्थन, जो सहज डेवलपमेंट अनुभव प्रदान करता है।\n * मल्टी-एनवायरनमेंट बिल्ड: क्लाइंट (client), सर्वर (server) और Node.js (node)\n   एनवायरनमेंट के लिए एकीकृत बिल्ड कॉन्फ़िगरेशन, जो मल्टी-प्लेटफॉर्म डेवलपमेंट\n   प्रक्रिया को सरल बनाता है।\n * रिसोर्स ऑप्टिमाइज़ेशन: अंतर्निहित रिसोर्स प्रोसेसिंग और ऑप्टिमाइज़ेशन\n   क्षमताएं, जो कोड स्प्लिटिंग, Tree Shaking, रिसोर्स कंप्रेशन जैसी विशेषताओं का\n   समर्थन करती हैं।\n\n\nएप्लिकेशन बिल्ड#\n\nGez का Rspack बिल्ड सिस्टम मॉड्यूलर डिज़ाइन पर आधारित है, जिसमें निम्नलिखित\nमुख्य मॉड्यूल शामिल हैं:\n\n\n@gez/rspack#\n\nबेसिक बिल्ड मॉड्यूल, जो निम्नलिखित मुख्य क्षमताएं प्रदान करता है:\n\n * एकीकृत बिल्ड कॉन्फ़िगरेशन: मानकीकृत बिल्ड कॉन्फ़िगरेशन प्रबंधन, जो\n   मल्टी-एनवायरनमेंट कॉन्फ़िगरेशन का समर्थन करता है।\n * रिसोर्स प्रोसेसिंग: TypeScript, CSS, इमेज आदि रिसोर्सेज़ के लिए अंतर्निहित\n   प्रोसेसिंग क्षमताएं।\n * बिल्ड ऑप्टिमाइज़ेशन: कोड स्प्लिटिंग, Tree Shaking जैसी परफॉर्मेंस\n   ऑप्टिमाइज़ेशन विशेषताएं।\n * डेवलपमेंट सर्वर: हाई-परफॉर्मेंस डेवलपमेंट सर्वर, जो HMR का समर्थन करता है।\n\n\n@gez/rspack-vue#\n\nVue फ्रेमवर्क के लिए विशेष बिल्ड मॉड्यूल, जो निम्नलिखित प्रदान करता है:\n\n * Vue कंपोनेंट कंपाइलेशन: Vue 2/3 कंपोनेंट्स के लिए कुशल कंपाइलेशन।\n * SSR ऑप्टिमाइज़ेशन: सर्वर-साइड रेंडरिंग (SSR) परिदृश्यों के लिए विशिष्ट\n   ऑप्टिमाइज़ेशन।\n * डेवलपमेंट एन्हांसमेंट: Vue डेवलपमेंट एनवायरनमेंट के लिए विशिष्ट फंक्शनलिटी\n   एन्हांसमेंट।\n\n\nबिल्ड प्रक्रिया#\n\nGez की बिल्ड प्रक्रिया मुख्य रूप से निम्नलिखित चरणों में विभाजित है:\n\n 1. कॉन्फ़िगरेशन इनिशियलाइज़ेशन\n    \n    * प्रोजेक्ट कॉन्फ़िगरेशन लोड करना\n    * डिफ़ॉल्ट कॉन्फ़िगरेशन और यूज़र कॉन्फ़िगरेशन को मर्ज करना\n    * एनवायरनमेंट वेरिएबल्स के आधार पर कॉन्फ़िगरेशन को एडजस्ट करना\n\n 2. रिसोर्स कंपाइलेशन\n    \n    * सोर्स कोड डिपेंडेंसीज़ को पार्स करना\n    * विभिन्न रिसोर्सेज़ (TypeScript, CSS आदि) को ट्रांसफ़ॉर्म करना\n    * मॉड्यूल इम्पोर्ट/एक्सपोर्ट को प्रोसेस करना\n\n 3. ऑप्टिमाइज़ेशन प्रोसेसिंग\n    \n    * कोड स्प्लिटिंग को एक्ज़ीक्यूट करना\n    * Tree Shaking को लागू करना\n    * कोड और रिसोर्सेज़ को कंप्रेस करना\n\n 4. आउटपुट जनरेशन\n    \n    * टार्गेट फ़ाइल्स जनरेट करना\n    * रिसोर्स मैपिंग आउटपुट करना\n    * बिल्ड रिपोर्ट जनरेट करना\n\n\nबेस्ट प्रैक्टिसेज़#\n\n\nडेवलपमेंट एनवायरनमेंट ऑप्टिमाइज़ेशन#\n\n * इंक्रीमेंटल कंपाइलेशन कॉन्फ़िगरेशन: cache ऑप्शन को उचित रूप से कॉन्फ़िगर\n   करें, जिससे कैश का उपयोग करके बिल्ड स्पीड बढ़ाई जा सके।\n * HMR ऑप्टिमाइज़ेशन: हॉट रीलोड स्कोप को विशिष्ट रूप से कॉन्फ़िगर करें, जिससे\n   अनावश्यक मॉड्यूल अपडेट से बचा जा सके।\n * रिसोर्स प्रोसेसिंग ऑप्टिमाइज़ेशन: उचित loader कॉन्फ़िगरेशन का उपयोग करें,\n   जिससे डुप्लीकेट प्रोसेसिंग से बचा जा सके।\n\n\nप्रोडक्शन एनवायरनमेंट ऑप्टिमाइज़ेशन#\n\n * कोड स्प्लिटिंग स्ट्रैटेजी: splitChunks को उचित रूप से कॉन्फ़िगर करें, जिससे\n   रिसोर्स लोडिंग ऑप्टिमाइज़ हो सके।\n * रिसोर्स कंप्रेशन: उचित कंप्रेशन कॉन्फ़िगरेशन को सक्षम करें, जिससे बिल्ड टाइम\n   और आउटपुट साइज़ के बीच संतुलन बनाया जा सके।\n * कैश ऑप्टिमाइज़ेशन: कंटेंट हैश और लॉन्ग-टर्म कैश स्ट्रैटेजी का उपयोग करें,\n   जिससे लोडिंग परफॉर्मेंस बढ़ाई जा सके।\n\n\nकॉन्फ़िगरेशन उदाहरण#\n\n\n\nTIP\n\nअधिक विस्तृत API विवरण और कॉन्फ़िगरेशन ऑप्शन्स के लिए, कृपया Rspack API\nदस्तावेज़ देखें।","routePath":"/hi/guide/essentials/rspack","lang":"hi","toc":[{"text":"विशेषताएं","id":"विशेषताएं","depth":2,"charIndex":194},{"text":"एप्लिकेशन बिल्ड","id":"एप्लिकेशन-बिल्ड","depth":2,"charIndex":982},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1103},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1586},{"text":"बिल्ड प्रक्रिया","id":"बिल्ड-प्रक्रिया","depth":2,"charIndex":1934},{"text":"बेस्ट प्रैक्टिसेज़","id":"बेस्ट-प्रैक्टिसेज़","depth":2,"charIndex":2686},{"text":"डेवलपमेंट एनवायरनमेंट ऑप्टिमाइज़ेशन","id":"डेवलपमेंट-एनवायरनमेंट-ऑप्टिमाइज़ेशन","depth":3,"charIndex":2708},{"text":"प्रोडक्शन एनवायरनमेंट ऑप्टिमाइज़ेशन","id":"प्रोडक्शन-एनवायरनमेंट-ऑप्टिमाइज़ेशन","depth":3,"charIndex":3124},{"text":"कॉन्फ़िगरेशन उदाहरण","id":"कॉन्फ़िगरेशन-उदाहरण","depth":2,"charIndex":3525}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क हाई-परफॉर्मेंस बिल्ड इंजन","description":"Gez फ्रेमवर्क के Rspack बिल्ड सिस्टम की गहराई से व्याख्या, जिसमें हाई-परफॉर्मेंस कंपाइलेशन, मल्टी-एनवायरनमेंट बिल्ड, रिसोर्स ऑप्टिमाइज़ेशन जैसी मुख्य विशेषताएं शामिल हैं, जो डेवलपर्स को कुशल और विश्वसनीय आधुनिक वेब एप्लिकेशन बनाने में मदद करती हैं।","head":[["meta",{"property":"keywords","content":"Gez, Rspack, बिल्ड सिस्टम, हाई-परफॉर्मेंस कंपाइलेशन, हॉट रीलोड, मल्टी-एनवायरनमेंट बिल्ड, Tree Shaking, कोड स्प्लिटिंग, SSR, रिसोर्स ऑप्टिमाइज़ेशन, डेवलपमेंट एफिशिएंसी, बिल्ड टूल"}]]},"version":""},{"id":116,"title":"मानक मानदंड","content":"#\n\nGez एक आधुनिक SSR फ्रेमवर्क है, जो विकास और उत्पादन वातावरण में परियोजना की\nस्थिरता और रखरखाव क्षमता सुनिश्चित करने के लिए मानकीकृत परियोजना संरचना और पथ\nविश्लेषण तंत्र का उपयोग करता है।\n\n\nपरियोजना संरचना मानक#\n\n\nमानक निर्देशिका संरचना#\n\n\n\nविस्तारित ज्ञान\n * gez.name package.json के name फ़ील्ड से प्राप्त होता है\n * dist/package.json रूट निर्देशिका के package.json से प्राप्त होता है\n * packs.enable को true पर सेट करने पर ही dist निर्देशिका को संग्रहित किया जाएगा\n\n\nप्रवेश फ़ाइल मानक#\n\n\nentry.client.ts#\n\nक्लाइंट-साइड प्रवेश फ़ाइल के जिम्मेदारियां:\n\n * एप्लिकेशन आरंभीकरण: क्लाइंट-साइड एप्लिकेशन की मूल सेटिंग्स कॉन्फ़िगर करना\n * रूटिंग प्रबंधन: क्लाइंट-साइड रूटिंग और नेविगेशन को संभालना\n * स्थिति प्रबंधन: क्लाइंट-साइड स्थिति का भंडारण और अद्यतन करना\n * इंटरैक्शन प्रबंधन: उपयोगकर्ता इवेंट्स और इंटरफ़ेस इंटरैक्शन को संभालना\n\n\nentry.server.ts#\n\nसर्वर-साइड प्रवेश फ़ाइल के जिम्मेदारियां:\n\n * सर्वर-साइड रेंडरिंग: SSR रेंडरिंग प्रक्रिया को निष्पादित करना\n * HTML जनरेशन: प्रारंभिक पृष्ठ संरचना का निर्माण करना\n * डेटा प्रीफ़ेच: सर्वर-साइड डेटा प्राप्ति को संभालना\n * स्थिति इंजेक्शन: सर्वर-साइड स्थिति को क्लाइंट को पास करना\n * SEO अनुकूलन: पृष्ठ की सर्च इंजन अनुकूलन सुनिश्चित करना\n\n\nentry.node.ts#\n\nNode.js सर्वर प्रवेश फ़ाइल के जिम्मेदारियां:\n\n * सर्वर कॉन्फ़िगरेशन: HTTP सर्वर पैरामीटर्स सेट करना\n * रूटिंग प्रबंधन: सर्वर-साइड रूटिंग नियमों को संभालना\n * मिडलवेयर एकीकरण: सर्वर मिडलवेयर कॉन्फ़िगर करना\n * पर्यावरण प्रबंधन: पर्यावरण चर और कॉन्फ़िगरेशन को संभालना\n * अनुरोध प्रतिक्रिया: HTTP अनुरोध और प्रतिक्रिया को संभालना\n\n\nकॉन्फ़िगरेशन फ़ाइल मानक#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/hi/guide/essentials/std","lang":"hi","toc":[{"text":"परियोजना संरचना मानक","id":"परियोजना-संरचना-मानक","depth":2,"charIndex":191},{"text":"मानक निर्देशिका संरचना","id":"मानक-निर्देशिका-संरचना","depth":3,"charIndex":215},{"text":"प्रवेश फ़ाइल मानक","id":"प्रवेश-फ़ाइल-मानक","depth":2,"charIndex":471},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":492},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":834},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1190},{"text":"कॉन्फ़िगरेशन फ़ाइल मानक","id":"कॉन्फ़िगरेशन-फ़ाइल-मानक","depth":2,"charIndex":1534},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1561},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1579}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क परियोजना संरचना और मानक गाइड","description":"Gez फ्रेमवर्क की मानक परियोजना संरचना, प्रवेश फ़ाइल मानक और कॉन्फ़िगरेशन फ़ाइल मानक का विस्तृत विवरण, जो डेवलपर्स को मानकीकृत और रखरखाव योग्य SSR एप्लिकेशन बनाने में मदद करता है।","head":[["meta",{"property":"keywords","content":"Gez, परियोजना संरचना, प्रवेश फ़ाइल, कॉन्फ़िगरेशन मानक, SSR फ्रेमवर्क, TypeScript, परियोजना मानक, विकास मानक"}]]},"version":""},{"id":117,"title":"HTML","content":"#\n\nयह ट्यूटोरियल आपको Gez पर आधारित एक HTML SSR एप्लिकेशन को शुरू से बनाने में मदद\nकरेगा। हम एक पूर्ण उदाहरण के माध्यम से दिखाएंगे कि Gez फ्रेमवर्क का उपयोग करके\nसर्वर-साइड रेंडरिंग एप्लिकेशन कैसे बनाया जाता है।\n\n\nप्रोजेक्ट संरचना#\n\nसबसे पहले, प्रोजेक्ट की मूल संरचना को समझते हैं:\n\n\n\n\nप्रोजेक्ट कॉन्फ़िगरेशन#\n\n\npackage.json#\n\npackage.json फ़ाइल बनाएं, प्रोजेक्ट डिपेंडेंसी और स्क्रिप्ट को कॉन्फ़िगर करें:\n\n\n\npackage.json फ़ाइल बनाने के बाद, प्रोजेक्ट डिपेंडेंसी को इंस्टॉल करने की\nआवश्यकता है। आप निम्नलिखित किसी भी कमांड का उपयोग करके इंस्टॉल कर सकते हैं:\n\n\n\nयह सभी आवश्यक डिपेंडेंसी पैकेज को इंस्टॉल करेगा, जिसमें TypeScript और SSR से\nसंबंधित डिपेंडेंसी शामिल हैं।\n\n\ntsconfig.json#\n\ntsconfig.json फ़ाइल बनाएं, TypeScript कंपाइल विकल्प को कॉन्फ़िगर करें:\n\n\n\n\nसोर्स कोड संरचना#\n\n\napp.ts#\n\nमुख्य एप्लिकेशन कंपोनेंट src/app.ts बनाएं, पेज संरचना और इंटरैक्शन लॉजिक को\nइम्प्लीमेंट करें:\n\n\n\n\ncreate-app.ts#\n\nsrc/create-app.ts फ़ाइल बनाएं, एप्लिकेशन इंस्टेंस बनाने के लिए जिम्मेदार:\n\n\n\n\nentry.client.ts#\n\nक्लाइंट-साइड एंट्री फ़ाइल src/entry.client.ts बनाएं:\n\n\n\n\nentry.node.ts#\n\nentry.node.ts फ़ाइल बनाएं, डेवलपमेंट एनवायरनमेंट कॉन्फ़िगरेशन और सर्वर स्टार्टअप\nको कॉन्फ़िगर करें:\n\n\n\nयह फ़ाइल डेवलपमेंट एनवायरनमेंट कॉन्फ़िगरेशन और सर्वर स्टार्टअप के लिए एंट्री\nफ़ाइल है, जिसमें दो मुख्य फंक्शनलिटी शामिल हैं:\n\n 1. devApp फ़ंक्शन: डेवलपमेंट एनवायरनमेंट के लिए Rspack एप्लिकेशन इंस्टेंस बनाने\n    और कॉन्फ़िगर करने के लिए जिम्मेदार है, हॉट रीलोडिंग और रियल-टाइम प्रीव्यू\n    फंक्शनलिटी को सपोर्ट करता है।\n 2. server फ़ंक्शन: HTTP सर्वर बनाने और कॉन्फ़िगर करने के लिए जिम्मेदार है, Gez\n    मिडलवेयर को इंटीग्रेट करके SSR रिक्वेस्ट को हैंडल करता है।\n\n\nentry.server.ts#\n\nसर्वर-साइड रेंडरिंग एंट्री फ़ाइल src/entry.server.ts बनाएं:\n\n","routePath":"/hi/guide/frameworks/html","lang":"hi","toc":[{"text":"प्रोजेक्ट संरचना","id":"प्रोजेक्ट-संरचना","depth":2,"charIndex":213},{"text":"प्रोजेक्ट कॉन्फ़िगरेशन","id":"प्रोजेक्ट-कॉन्फ़िगरेशन","depth":2,"charIndex":285},{"text":"package.json","id":"packagejson","depth":3,"charIndex":311},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":669},{"text":"सोर्स कोड संरचना","id":"सोर्स-कोड-संरचना","depth":2,"charIndex":760},{"text":"app.ts","id":"appts","depth":3,"charIndex":780},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":887},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":981},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1056},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":1639}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क HTML SSR एप्लिकेशन उदाहरण","description":"Gez पर आधारित HTML SSR एप्लिकेशन को शुरू से बनाने का उदाहरण, जिसमें प्रोजेक्ट इनिशियलाइज़ेशन, HTML कॉन्फ़िगरेशन और एंट्री फ़ाइल सेटअप शामिल हैं।","head":[["meta",{"property":"keywords","content":"Gez, HTML, SSR एप्लिकेशन, TypeScript कॉन्फ़िगरेशन, प्रोजेक्ट इनिशियलाइज़ेशन, सर्वर-साइड रेंडरिंग, क्लाइंट-साइड इंटरैक्शन"}]]},"version":""},{"id":118,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/hi/guide/frameworks/preact-htm","lang":"hi","toc":[{"text":"प्रोजेक्ट संरचना","id":"प्रोजेक्ट-संरचना","depth":2,"charIndex":-1},{"text":"प्रोजेक्ट कॉन्फ़िगरेशन","id":"प्रोजेक्ट-कॉन्फ़िगरेशन","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"सोर्स कोड संरचना","id":"सोर्स-कोड-संरचना","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"प्रोजेक्ट को रन करें","id":"प्रोजेक्ट-को-रन-करें","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क Preact+HTM SSR एप्लिकेशन उदाहरण","description":"Gez पर आधारित Preact+HTM SSR एप्लिकेशन को शुरू से बनाने का तरीका, जिसमें प्रोजेक्ट इनिशियलाइज़ेशन, Preact कॉन्फ़िगरेशन और एंट्री फ़ाइल सेटअप शामिल हैं।","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, SSR एप्लिकेशन, TypeScript कॉन्फ़िगरेशन, प्रोजेक्ट इनिशियलाइज़ेशन, सर्वर-साइड रेंडरिंग, क्लाइंट-साइड इंटरैक्शन"}]]},"version":""},{"id":119,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/hi/guide/frameworks/vue2","lang":"hi","toc":[{"text":"प्रोजेक्ट संरचना","id":"प्रोजेक्ट-संरचना","depth":2,"charIndex":-1},{"text":"प्रोजेक्ट कॉन्फ़िगरेशन","id":"प्रोजेक्ट-कॉन्फ़िगरेशन","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"सोर्स कोड संरचना","id":"सोर्स-कोड-संरचना","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"प्रोजेक्ट चलाएं","id":"प्रोजेक्ट-चलाएं","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क Vue2 SSR एप्लिकेशन उदाहरण","description":"Gez पर आधारित Vue2 SSR एप्लिकेशन को शुरू से बनाने का तरीका, जिसमें प्रोजेक्ट इनिशियलाइज़ेशन, Vue2 कॉन्फ़िगरेशन और एंट्री फ़ाइल सेटअप शामिल हैं।","head":[["meta",{"property":"keywords","content":"Gez, Vue2, SSR एप्लिकेशन, TypeScript कॉन्फ़िगरेशन, प्रोजेक्ट इनिशियलाइज़ेशन, सर्वर-साइड रेंडरिंग, क्लाइंट-साइड इंटरैक्शन"}]]},"version":""},{"id":120,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/hi/guide/frameworks/vue3","lang":"hi","toc":[{"text":"प्रोजेक्ट संरचना","id":"प्रोजेक्ट-संरचना","depth":2,"charIndex":-1},{"text":"प्रोजेक्ट कॉन्फ़िगरेशन","id":"प्रोजेक्ट-कॉन्फ़िगरेशन","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"सोर्स कोड संरचना","id":"सोर्स-कोड-संरचना","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"प्रोजेक्ट को रन करें","id":"प्रोजेक्ट-को-रन-करें","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क Vue3 SSR एप्लिकेशन उदाहरण","description":"Gez पर आधारित Vue3 SSR एप्लिकेशन को शुरू से बनाने का तरीका, प्रोजेक्ट इनिशियलाइज़ेशन, Vue3 कॉन्फ़िगरेशन और एंट्री फ़ाइल सेटअप सहित फ्रेमवर्क के बेसिक उपयोग को उदाहरण के माध्यम से दिखाया गया है।","head":[["meta",{"property":"keywords","content":"Gez, Vue3, SSR एप्लिकेशन, TypeScript कॉन्फ़िगरेशन, प्रोजेक्ट इनिशियलाइज़ेशन, सर्वर-साइड रेंडरिंग, क्लाइंट-साइड इंटरैक्शन, कंपोज़ेबल API"}]]},"version":""},{"id":121,"title":"पर्यावरण आवश्यकताएं","content":"#\n\nयह दस्तावेज़ इस फ्रेमवर्क का उपयोग करने के लिए आवश्यक पर्यावरण आवश्यकताओं का\nवर्णन करता है, जिसमें Node.js पर्यावरण और ब्राउज़र संगतता शामिल है।\n\n\nNode.js पर्यावरण#\n\nफ्रेमवर्क को Node.js संस्करण >= 22.6 की आवश्यकता होती है, मुख्य रूप से\nTypeScript प्रकार आयात ( --experimental-strip-types फ्लैग के माध्यम से) का\nसमर्थन करने के लिए, अतिरिक्त संकलन चरणों की आवश्यकता नहीं होती है।\n\n\nब्राउज़र संगतता#\n\nफ्रेमवर्क डिफ़ॉल्ट रूप से संगत मोड में बनाया जाता है, ताकि अधिक व्यापक\nब्राउज़रों का समर्थन किया जा सके। हालांकि, ध्यान दें कि पूर्ण ब्राउज़र संगतता\nसमर्थन प्राप्त करने के लिए, es-module-shims निर्भरता को मैन्युअल रूप से जोड़ना\nआवश्यक है।\n\n\nसंगत मोड (डिफ़ॉल्ट)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nCan I Use के आंकड़ों के अनुसार, संगत मोड में ब्राउज़र कवरेज दर 96.81% है।\n\n\nमूल समर्थन मोड#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * � Safari: >= 16.4\n\nमूल समर्थन मोड के निम्नलिखित लाभ हैं:\n\n * शून्य रनटाइम ओवरहेड, अतिरिक्त मॉड्यूल लोडर की आवश्यकता नहीं\n * ब्राउज़र द्वारा मूल रूप से पार्सिंग, तेज़ निष्पादन गति\n * बेहतर कोड विभाजन और ऑन-डिमांड लोडिंग क्षमता\n\nCan I Use के आंकड़ों के अनुसार, संगत मोड में ब्राउज़र कवरेज दर 93.5% है।\n\n\nसंगत समर्थन सक्षम करें#\n\nमहत्वपूर्ण सूचना\n\nहालांकि फ्रेमवर्क डिफ़ॉल्ट रूप से संगत मोड में बनाया जाता है, लेकिन पुराने\nब्राउज़रों के लिए पूर्ण समर्थन प्राप्त करने के लिए, आपको अपने प्रोजेक्ट में\nes-module-shims निर्भरता जोड़ने की आवश्यकता है।\n\nHTML फ़ाइल में निम्नलिखित स्क्रिप्ट जोड़ें:\n\n\n\nसर्वोत्तम अभ्यास\n 1. उत्पादन पर्यावरण सुझाव:\n    * es-module-shims को अपने स्वयं के सर्वर पर तैनात करें\n    * संसाधन लोडिंग की स्थिरता और पहुंच गति सुनिश्चित करें\n    * संभावित सुरक्षा जोखिमों से बचें\n 2. प्रदर्शन विचार:\n    * संगत मोड थोड़ा प्रदर्शन ओवरहेड लाता है\n    * लक्षित उपयोगकर्ता समूह के ब्राउज़र वितरण के आधार पर इसे सक्षम करने का\n      निर्णय लिया जा सकता है","routePath":"/hi/guide/start/environment","lang":"hi","toc":[{"text":"Node.js पर्यावरण","id":"nodejs-पर्यावरण","depth":2,"charIndex":149},{"text":"ब्राउज़र संगतता","id":"ब्राउज़र-संगतता","depth":2,"charIndex":383},{"text":"संगत मोड (डिफ़ॉल्ट)","id":"संगत-मोड-डिफ़ॉल्ट","depth":3,"charIndex":642},{"text":"मूल समर्थन मोड","id":"मूल-समर्थन-मोड","depth":3,"charIndex":820},{"text":"संगत समर्थन सक्षम करें","id":"संगत-समर्थन-सक्षम-करें","depth":3,"charIndex":1202}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क संगतता गाइड","description":"Gez फ्रेमवर्क के पर्यावरण आवश्यकताओं का विस्तृत विवरण, जिसमें Node.js संस्करण आवश्यकताएं और ब्राउज़र संगतता विवरण शामिल हैं, जो डेवलपर्स को सही विकास पर्यावरण कॉन्फ़िगर करने में मदद करता है।","head":[["meta",{"property":"keywords","content":"Gez, Node.js, ब्राउज़र संगतता, TypeScript, es-module-shims, पर्यावरण कॉन्फ़िगरेशन"}]]},"version":""},{"id":122,"title":"त्वरित प्रारंभ","content":"#\n\n\nप्रोजेक्ट इनिशियलाइज़ेशन#\n\nएक नया Gez प्रोजेक्ट बनाने और इनिशियलाइज़ करने के लिए, निम्नलिखित चरणों का पालन\nकरें:\n\n\n\n\nफ्रेमवर्क संस्करण चयन#\n\nGez फ्रेमवर्क कई तकनीकी स्टैक संस्करण प्रदान करता है, जिनमें से प्रत्येक को\nविभिन्न एप्लिकेशन परिदृश्यों के लिए अनुकूलित किया गया है। कृपया प्रोजेक्ट\nआवश्यकताओं के अनुसार उपयुक्त संस्करण चुनें:\n\n\nHTML#\n\nअत्यंत सरल आर्किटेक्चर वाले प्रोजेक्ट्स के लिए उपयुक्त:\n\n * शून्य बाहरी निर्भरता, शुरू करने के लिए तैयार\n * मूल JavaScript विकास अनुभव\n * स्थिर वेबसाइट और हल्के एप्लिकेशन बनाने के लिए उपयुक्त\n * प्रगतिशील कार्यक्षमता विस्तार का समर्थन\n\nHTML संस्करण का विस्तृत दस्तावेज़ देखें\n\n\nVue2#\n\nएंटरप्राइज़-ग्रेड एप्लिकेशन विकास के लिए उपयुक्त:\n\n * पूर्ण TypeScript समर्थन\n * समृद्ध तृतीय-पक्ष घटक पारिस्थितिकी तंत्र\n * परिपक्व विकास टूलचेन\n * उत्पादन वातावरण में सत्यापित स्थिरता\n\nVue2 संस्करण का विस्तृत दस्तावेज़ देखें\n\n\nVue3#\n\nआधुनिक वेब एप्लिकेशन विकास के लिए उपयुक्त:\n\n * Proxy आधारित प्रतिक्रियाशील प्रणाली\n * कंपोज़ेबल API समर्थन\n * बेहतर रनटाइम प्रदर्शन\n * छोटा बंडल आकार\n\nVue3 संस्करण का विस्तृत दस्तावेज़ देखें\n\n\nPreact+HTM#\n\nहल्के और उच्च प्रदर्शन वाले प्रोजेक्ट्स के लिए उपयुक्त:\n\n * अत्यंत छोटा रनटाइम आकार (3KB)\n * मूल JavaScript टेम्पलेट सिंटैक्स\n * React के साथ संगत API\n * उत्कृष्ट प्रदर्शन\n\nPreact+HTM संस्करण का विस्तृत दस्तावेज़ देखें\n\n\nAI सहायित विकास#\n\nGez फ्रेमवर्क AI सहायित विकास क्षमता प्रदान करता है, जो विकास दक्षता को काफी\nबढ़ा सकता है:\n\n 1. उपयुक्त फ्रेमवर्क संस्करण दस्तावेज़ चुनें\n 2. दस्तावेज़ सामग्री को AI सहायक को प्रदान करें\n 3. AI स्वचालित रूप से प्रोजेक्ट स्केलेटन और कॉन्फ़िगरेशन फ़ाइलें उत्पन्न करेगा\n\nसुझाव\n\nAI सहायित विकास न केवल प्रोजेक्ट इनिशियलाइज़ेशन गति को बढ़ाता है, बल्कि यह\nसुनिश्चित करता है कि प्रोजेक्ट संरचना सर्वोत्तम प्रथाओं के अनुरूप हो।","routePath":"/hi/guide/start/getting-started","lang":"hi","toc":[{"text":"प्रोजेक्ट इनिशियलाइज़ेशन","id":"प्रोजेक्ट-इनिशियलाइज़ेशन","depth":2,"charIndex":3},{"text":"फ्रेमवर्क संस्करण चयन","id":"फ्रेमवर्क-संस्करण-चयन","depth":2,"charIndex":120},{"text":"HTML","id":"html","depth":3,"charIndex":340},{"text":"Vue2","id":"vue2","depth":3,"charIndex":625},{"text":"Vue3","id":"vue3","depth":3,"charIndex":861},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1061},{"text":"AI सहायित विकास","id":"ai-सहायित-विकास","depth":2,"charIndex":1295}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क त्वरित प्रारंभ गाइड","description":"Gez फ्रेमवर्क त्वरित प्रारंभ गाइड, जो आपको शून्य से प्रोजेक्ट बनाने में मदद करता है, जिसमें प्रोजेक्ट इनिशियलाइज़ेशन, फ्रेमवर्क संस्करण चयन और AI सहायित विकास शामिल है।","head":[["meta",{"name":"keywords","content":"Gez फ्रेमवर्क, त्वरित प्रारंभ, प्रोजेक्ट इनिशियलाइज़ेशन, Vue विकास, HTML विकास, AI सहायित"}]]},"version":""},{"id":123,"title":"परिचय","content":"#\n\n\nपरियोजना पृष्ठभूमि#\n\nGz एक ECMAScript Modules (ESM) पर आधारित आधुनिक माइक्रो-फ्रंटएंड फ्रेमवर्क है,\nजो उच्च प्रदर्शन और स्केलेबल सर्वर-साइड रेंडरिंग (SSR) एप्लिकेशन बनाने पर\nकेंद्रित है। Genesis परियोजना के तीसरे पीढ़ी के उत्पाद के रूप में, Gez ने तकनीकी\nविकास की प्रक्रिया में लगातार नवाचार किया है:\n\n * v1.0: HTTP अनुरोधों के आधार पर रिमोट कंपोनेंट्स की ऑन-डिमांड लोडिंग\n * v2.0: Webpack Module Federation के आधार पर एप्लिकेशन एकीकरण\n * v3.0: ब्राउज़र नेटिव ESM पर आधारित मॉड्यूल लिंक सिस्टम का पुन: डिज़ाइन\n\n\nतकनीकी पृष्ठभूमि#\n\nमाइक्रो-फ्रंटएंड आर्किटेक्चर के विकास के दौरान, पारंपरिक समाधानों में मुख्य रूप\nसे निम्नलिखित सीमाएं थीं:\n\n\nमौजूदा समाधानों की चुनौतियाँ#\n\n * प्रदर्शन बाधाएं: रनटाइम डिपेंडेंसी इंजेक्शन और JavaScript सैंडबॉक्स प्रॉक्सी\n   से महत्वपूर्ण प्रदर्शन ओवरहेड\n * अलगाव तंत्र: स्व-विकसित सैंडबॉक्स वातावरण ब्राउज़र नेटिव मॉड्यूल अलगाव\n   क्षमताओं तक पहुँचने में असमर्थ\n * निर्माण जटिलता: निर्भरता साझाकरण के लिए निर्माण उपकरणों में संशोधन से\n   परियोजना रखरखाव लागत बढ़ जाती है\n * मानक विचलन: विशेष तैनाती रणनीतियाँ और रनटाइम प्रसंस्करण तंत्र आधुनिक वेब\n   विकास मानकों से विचलित होते हैं\n * पारिस्थितिकी सीमाएं: फ्रेमवर्क युग्मन और कस्टम API से तकनीकी स्टैक विकल्प\n   सीमित हो जाते हैं\n\n\nतकनीकी नवाचार#\n\nGz आधुनिक वेब मानकों पर आधारित, एक नया समाधान प्रदान करता है:\n\n * नेटिव मॉड्यूल सिस्टम: ब्राउज़र नेटिव ESM और Import Maps का उपयोग करके\n   निर्भरता प्रबंधन, तेज पार्सिंग और निष्पादन गति\n * मानक अलगाव तंत्र: ECMAScript मॉड्यूल स्कोप पर आधारित विश्वसनीय एप्लिकेशन\n   अलगाव\n * खुला तकनीकी स्टैक: किसी भी आधुनिक फ्रंटएंड फ्रेमवर्क के सहज एकीकरण का समर्थन\n * अनुकूलित विकास अनुभव: सहज विकास मोड और पूर्ण डिबगिंग क्षमता प्रदान करता है\n * अत्यधिक प्रदर्शन अनुकूलन: नेटिव क्षमताओं के माध्यम से शून्य रनटाइम ओवरहेड,\n   स्मार्ट कैशिंग रणनीतियों के साथ\n\nTIP\n\nGz उच्च प्रदर्शन, आसानी से स्केलेबल माइक्रो-फ्रंटएंड बुनियादी ढांचे के निर्माण\nपर केंद्रित है, विशेष रूप से बड़े पैमाने पर सर्वर-साइड रेंडरिंग एप्लिकेशन\nपरिदृश्यों के लिए उपयुक्त।\n\n\nतकनीकी विनिर्देश#\n\n\nपर्यावरण निर्भरताएँ#\n\nकृपया पर्यावरण आवश्यकताएँ दस्तावेज़ को ब्राउज़र और Node.js पर्यावरण आवश्यकताओं\nके बारे में विस्तृत जानकारी के लिए देखें।\n\n\nमुख्य तकनीकी स्टैक#\n\n * निर्भरता प्रबंधन: Import Maps का उपयोग करके मॉड्यूल मैपिंग, es-module-shims\n   के साथ संगतता समर्थन\n * निर्माण प्रणाली: Rspack के module-import पर आधारित बाहरी निर्भरताओं का\n   प्रसंस्करण\n * विकास उपकरण श्रृंखला: ESM हॉट अपडेट और TypeScript नेटिव निष्पादन का समर्थन\n\n\nफ्रेमवर्क स्थिति#\n\nGz Next.js या Nuxt.js से अलग है, बल्कि माइक्रो-फ्रंटएंड बुनियादी ढांचे प्रदान\nकरने पर केंद्रित है:\n\n * मॉड्यूल लिंक सिस्टम: कुशल, विश्वसनीय मॉड्यूल आयात/निर्यात\n * सर्वर-साइड रेंडरिंग: लचीली SSR कार्यान्वयन तंत्र प्रदान करता है\n * प्रकार प्रणाली समर्थन: पूर्ण TypeScript प्रकार परिभाषाओं का एकीकरण\n * फ्रेमवर्क तटस्थता: मुख्यधारा के फ्रंटएंड फ्रेमवर्क्स के एकीकरण का समर्थन\n\n\nआर्किटेक्चर डिज़ाइन#\n\n\nकेंद्रीकृत निर्भरता प्रबंधन#\n\n * एकीकृत निर्भरता स्रोत: केंद्रीकृत तीसरे पक्ष की निर्भरता प्रबंधन\n * स्वचालित वितरण: निर्भरता अपडेट की वैश्विक स्वचालित सिंक्रनाइज़ेशन\n * संस्करण स्थिरता: सटीक निर्भरता संस्करण नियंत्रण\n\n\nमॉड्यूलर डिज़ाइन#\n\n * दायित्व पृथक्करण: व्यावसायिक तर्क और बुनियादी ढांचे का अलगाव\n * प्लगइन तंत्र: मॉड्यूल्स के लचीले संयोजन और प्रतिस्थापन का समर्थन\n * मानक इंटरफेस: मॉड्यूल्स के बीच मानकीकृत संचार प्रोटोकॉल\n\n\nप्रदर्शन अनुकूलन#\n\n * शून्य ओवरहेड सिद्धांत: ब्राउज़र नेटिव क्षमताओं का अधिकतम उपयोग\n * स्मार्ट कैशिंग: सामग्री हैश पर आधारित सटीक कैशिंग रणनीति\n * ऑन-डिमांड लोडिंग: सूक्ष्म कोड विभाजन और निर्भरता प्रबंधन\n\n\nपरियोजना परिपक्वता#\n\nGz ने लगभग 5 वर्षों के पुनरावृत्ति विकास (v1.0 से v3.0) के माध्यम से,\nउद्यम-स्तरीय वातावरण में व्यापक सत्यापन प्राप्त किया है। वर्तमान में यह दर्जनों\nव्यावसायिक परियोजनाओं को स्थिर रूप से संचालित कर रहा है, और तकनीकी स्टैक के\nआधुनिकीकरण को लगातार आगे बढ़ा रहा है। फ्रेमवर्क की स्थिरता, विश्वसनीयता और\nप्रदर्शन लाभ व्यवहार में पूरी तरह से सिद्ध हो चुके हैं, जो बड़े पैमाने के\nएप्लिकेशन विकास के लिए एक विश्वसनीय तकनीकी आधार प्रदान करते हैं।","routePath":"/hi/guide/start/introduction","lang":"hi","toc":[{"text":"परियोजना पृष्ठभूमि","id":"परियोजना-पृष्ठभूमि","depth":2,"charIndex":3},{"text":"तकनीकी पृष्ठभूमि","id":"तकनीकी-पृष्ठभूमि","depth":2,"charIndex":515},{"text":"मौजूदा समाधानों की चुनौतियाँ","id":"मौजूदा-समाधानों-की-चुनौतियाँ","depth":3,"charIndex":642},{"text":"तकनीकी नवाचार","id":"तकनीकी-नवाचार","depth":3,"charIndex":1214},{"text":"तकनीकी विनिर्देश","id":"तकनीकी-विनिर्देश","depth":2,"charIndex":1960},{"text":"पर्यावरण निर्भरताएँ","id":"पर्यावरण-निर्भरताएँ","depth":3,"charIndex":1980},{"text":"मुख्य तकनीकी स्टैक","id":"मुख्य-तकनीकी-स्टैक","depth":3,"charIndex":2125},{"text":"फ्रेमवर्क स्थिति","id":"फ्रेमवर्क-स्थिति","depth":2,"charIndex":2417},{"text":"आर्किटेक्चर डिज़ाइन","id":"आर्किटेक्चर-डिज़ाइन","depth":2,"charIndex":2812},{"text":"केंद्रीकृत निर्भरता प्रबंधन","id":"केंद्रीकृत-निर्भरता-प्रबंधन","depth":3,"charIndex":2835},{"text":"मॉड्यूलर डिज़ाइन","id":"मॉड्यूलर-डिज़ाइन","depth":3,"charIndex":3055},{"text":"प्रदर्शन अनुकूलन","id":"प्रदर्शन-अनुकूलन","depth":3,"charIndex":3267},{"text":"परियोजना परिपक्वता","id":"परियोजना-परिपक्वता","depth":2,"charIndex":3474}],"domain":"","frontmatter":{"titleSuffix":"Gez फ्रेमवर्क का अवलोकन और तकनीकी नवाचार","description":"Gez माइक्रो-फ्रंटएंड फ्रेमवर्क की परियोजना पृष्ठभूमि, तकनीकी विकास और मुख्य लाभों के बारे में गहराई से जानें, ESM-आधारित आधुनिक सर्वर-साइड रेंडरिंग समाधानों का अन्वेषण करें।","head":[["meta",{"property":"keywords","content":"Gez, माइक्रो-फ्रंटएंड, ESM, सर्वर-साइड रेंडरिंग, SSR, तकनीकी नवाचार, मॉड्यूल फेडरेशन"}]]},"version":""}]