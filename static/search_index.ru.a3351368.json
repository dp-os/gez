[{"id":225,"title":"@gez/rspack-vue","content":"#\n\nПакет Rspack Vue предоставляет набор API для создания и настройки приложений на\nоснове Vue с использованием Rspack, поддерживая разработку компонентов, сборку и\nсерверный рендеринг.\n\n\nУстановка#\n\nУстановите @gez/rspack-vue как зависимость для разработки с помощью менеджера\nпакетов:\n\n\nЭкспорт типов#\n\n\nBuildTarget#\n\n\n\nТип целевой среды сборки, определяющий целевую среду для сборки приложения,\nиспользуется для настройки специфических оптимизаций и функций в процессе\nсборки:\n\n * node: Сборка кода для выполнения в среде Node.js\n * client: Сборка кода для выполнения в браузере\n * server: Сборка кода для выполнения на сервере\n\n\nRspackAppConfigContext#\n\n\n\nИнтерфейс контекста конфигурации приложения Rspack, предоставляющий информацию,\nдоступную в функциях-хуках конфигурации:\n\n * gez: Экземпляр Gez Framework\n * buildTarget: Текущая цель сборки (client/server/node)\n * config: Объект конфигурации Rspack\n * options: Опции конфигурации приложения\n\n\nRspackAppOptions#\n\n\n\nИнтерфейс опций конфигурации приложения Rspack:\n\n * css: Способ вывода CSS, возможные значения: 'css' (отдельный файл) или\n   'style' (встроенные стили)\n * loaders: Пользовательская конфигурация загрузчиков\n * styleLoader: Опции конфигурации style-loader\n * cssLoader: Опции конфигурации css-loader\n * target: Конфигурация совместимости целевой среды сборки\n * definePlugin: Определение глобальных констант\n * config: Функция-хук конфигурации\n\n\nRspackHtmlAppOptions#\n\nНаследуется от RspackAppOptions, используется для настройки специфических опций\nHTML-приложения.\n\n\nЭкспорт функций#\n\n\ncreateRspackApp#\n\n\n\nСоздает стандартный экземпляр приложения Rspack.\n\nПараметры:\n\n * gez: Экземпляр Gez Framework\n * options: Опции конфигурации приложения Rspack\n\nВозвращаемое значение:\n\n * Возвращает Promise, который разрешается в созданный экземпляр приложения\n\n\ncreateRspackHtmlApp#\n\n\n\nСоздает экземпляр HTML-приложения Rspack.\n\nПараметры:\n\n * gez: Экземпляр Gez Framework\n * options: Опции конфигурации HTML-приложения\n\nВозвращаемое значение:\n\n * Возвращает Promise, который разрешается в созданный экземпляр HTML-приложения\n\n\nЭкспорт констант#\n\n\nRSPACK_LOADER#\n\n\n\nОбъект сопоставления идентификаторов встроенных загрузчиков Rspack,\nпредоставляющий константы для часто используемых загрузчиков:\n\n * builtinSwcLoader: Встроенный SWC загрузчик Rspack, используемый для обработки\n   файлов TypeScript/JavaScript\n * lightningcssLoader: Встроенный lightningcss загрузчик Rspack, используемый\n   для высокопроизводительной компиляции CSS-файлов\n * styleLoader: Загрузчик для вставки CSS в DOM\n * cssLoader: Загрузчик для разбора CSS-файлов и обработки CSS-модулей\n * lessLoader: Загрузчик для компиляции Less-файлов в CSS\n * styleResourcesLoader: Загрузчик для автоматического импорта глобальных\n   стилевых ресурсов (например, переменных, миксинов)\n * workerRspackLoader: Загрузчик для обработки файлов Web Worker\n\nИспользование этих констант позволяет ссылаться на встроенные загрузчики в\nконфигурации, избегая ручного ввода строк:\n\n\n\nПримечания:\n\n * Эти загрузчики уже встроены в Rspack и не требуют дополнительной установки\n * При настройке пользовательских загрузчиков можно использовать эти константы\n   для замены стандартных реализаций\n * Некоторые загрузчики (например, builtinSwcLoader) имеют специфические опции\n   конфигурации, обратитесь к соответствующей документации\n\n\nЭкспорт модулей#\n\n\nrspack#\n\nРеэкспортирует все содержимое пакета @rspack/core, предоставляя полный набор\nфункций ядра Rspack.","routePath":"/ru/api/app/rspack-vue","lang":"ru","toc":[{"text":"Установка","id":"установка","depth":2,"charIndex":186},{"text":"Экспорт типов","id":"экспорт-типов","depth":2,"charIndex":287},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":304},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":631},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":951},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1417},{"text":"Экспорт функций","id":"экспорт-функций","depth":2,"charIndex":1539},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1558},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1824},{"text":"Экспорт констант","id":"экспорт-констант","depth":2,"charIndex":2090},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2110},{"text":"Экспорт модулей","id":"экспорт-модулей","depth":2,"charIndex":3341},{"text":"rspack","id":"rspack","depth":3,"charIndex":3360}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Vue Build Tool","description":"Специализированный инструмент сборки Gez Framework для Vue, предоставляющий полную поддержку сборки приложений Vue 2/3, включая разработку компонентов, SSR-рендеринг и оптимизацию производительности.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, инструмент сборки, разработка компонентов, серверный рендеринг, оптимизация производительности"}]]},"version":""},{"id":226,"title":"@gez/rspack","content":"#\n\nThe Rspack package provides a set of APIs for creating and configuring Rspack\napplications, supporting the building and development of standard applications\nand HTML applications.\n\n\nInstallation#\n\nInstall @gez/rspack as a development dependency using a package manager:\n\n\nType Exports#\n\n\nBuildTarget#\n\n\n\nThe build target environment type defines the target environment for the\napplication build, used to configure specific optimizations and features during\nthe build process:\n\n * node: Build code to run in a Node.js environment\n * client: Build code to run in a browser environment\n * server: Build code to run in a server environment\n\n\nRspackAppConfigContext#\n\n\n\nThe Rspack application configuration context interface provides context\ninformation accessible within configuration hook functions:\n\n * gez: Gez framework instance\n * buildTarget: Current build target (client/server/node)\n * config: Rspack configuration object\n * options: Application configuration options\n\n\nRspackAppOptions#\n\n\n\nRspack application configuration options interface:\n\n * css: CSS output method, either 'css' (separate file) or 'style' (inline\n   styles)\n * loaders: Custom loader configuration\n * styleLoader: style-loader configuration options\n * cssLoader: css-loader configuration options\n * target: Build target compatibility configuration\n * definePlugin: Global constant definitions\n * config: Configuration hook function\n\n\nRspackHtmlAppOptions#\n\nInherits from RspackAppOptions, used to configure specific options for HTML\napplications.\n\n\nFunction Exports#\n\n\ncreateRspackApp#\n\n\n\nCreates a standard Rspack application instance.\n\nParameters:\n\n * gez: Gez framework instance\n * options: Rspack application configuration options\n\nReturns:\n\n * Returns a Promise that resolves to the created application instance\n\n\ncreateRspackHtmlApp#\n\n\n\nCreates an HTML-type Rspack application instance.\n\nParameters:\n\n * gez: Gez framework instance\n * options: HTML application configuration options\n\nReturns:\n\n * Returns a Promise that resolves to the created HTML application instance\n\n\nConstant Exports#\n\n\nRSPACK_LOADER#\n\n\n\nRspack built-in loader identifier mapping object, providing commonly used loader\nname constants:\n\n * builtinSwcLoader: Rspack built-in SWC loader for processing\n   TypeScript/JavaScript files\n * lightningcssLoader: Rspack built-in lightningcss loader for high-performance\n   CSS file compilation\n * styleLoader: Loader for injecting CSS into the DOM\n * cssLoader: Loader for parsing CSS files and handling CSS modularization\n * lessLoader: Loader for compiling Less files into CSS\n * styleResourcesLoader: Loader for automatically importing global style\n   resources (e.g., variables, mixins)\n * workerRspackLoader: Loader for processing Web Worker files\n\nUsing these constants allows referencing built-in loaders in configurations,\navoiding manual string input:\n\n\n\nNotes:\n\n * These loaders are already built into Rspack and do not require additional\n   installation\n * When customizing loader configurations, these constants can be used to\n   replace default loader implementations\n * Some loaders (e.g., builtinSwcLoader) have specific configuration options;\n   refer to the respective configuration documentation\n\n\nModule Exports#\n\n\nrspack#\n\nRe-exports all contents of the @rspack/core package, providing full Rspack core\nfunctionality.","routePath":"/ru/api/app/rspack","lang":"ru","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":184},{"text":"Type Exports","id":"type-exports","depth":2,"charIndex":274},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":290},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":640},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":976},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1412},{"text":"Function Exports","id":"function-exports","depth":2,"charIndex":1527},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1547},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1797},{"text":"Constant Exports","id":"constant-exports","depth":2,"charIndex":2056},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2076},{"text":"Module Exports","id":"module-exports","depth":2,"charIndex":3212},{"text":"rspack","id":"rspack","depth":3,"charIndex":3230}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rspack Build Tool","description":"Rspack build tool for Gez framework provides high-performance application building capabilities, supports development and building of standard applications and HTML applications, and comes with built-in resource processors and optimization configurations.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Build Tool, Application Building, HTML Application, TypeScript, CSS, Resource Processing, Performance Optimization"}]]},"version":""},{"id":227,"title":"App","content":"#\n\nApp — это абстракция приложения в рамках Gez, предоставляющая унифицированный\nинтерфейс для управления жизненным циклом приложения, обработки статических\nресурсов и серверного рендеринга.\n\n\n\n\nОпределение типов#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Тип: Middleware\n\nПромежуточное ПО для обработки статических ресурсов.\n\nВ среде разработки:\n\n * Обрабатывает запросы статических ресурсов исходного кода\n * Поддерживает горячую перезагрузку и компиляцию в реальном времени\n * Использует стратегию кэширования no-cache\n\nВ производственной среде:\n\n * Обрабатывает статические ресурсы после сборки\n * Поддерживает долгосрочное кэширование неизменяемых файлов (.final.xxx)\n * Оптимизированная стратегия загрузки ресурсов\n\n\n\nrender#\n\n * Тип: (options?: RenderContextOptions) => Promise\n\nФункция серверного рендеринга. Предоставляет различные реализации в зависимости\nот среды выполнения:\n\n * Производственная среда (start): Загружает и выполняет рендеринг с\n   использованием серверного входного файла после сборки (entry.server)\n * Среда разработки (dev): Загружает и выполняет рендеринг с использованием\n   серверного входного файла из исходного кода\n\n\n\nbuild#\n\n * Тип: () => Promise\n\nФункция сборки для производственной среды. Используется для упаковки и\nоптимизации ресурсов. Возвращает true при успешной сборке и false при неудаче.\n\ndestroy#\n\n * Тип: () => Promise\n\nФункция очистки ресурсов. Используется для закрытия серверов, разрыва соединений\nи т.д. Возвращает true при успешной очистке и false при неудаче.","routePath":"/ru/api/core/app","lang":"ru","toc":[{"text":"Определение типов","id":"определение-типов","depth":2,"charIndex":194},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":223},{"text":"render","id":"render","depth":4,"charIndex":707},{"text":"build","id":"build","depth":4,"charIndex":1138},{"text":"destroy","id":"destroy","depth":4,"charIndex":1320}],"domain":"","frontmatter":{"titleSuffix":"Абстрактный интерфейс приложения Gez","description":"Подробное описание интерфейса App в рамках Gez, включая управление жизненным циклом приложения, обработку статических ресурсов и функции серверного рендеринга, чтобы помочь разработчикам понять и использовать ключевые функции приложения.","head":[["meta",{"property":"keywords","content":"Gez, App, абстракция приложения, жизненный цикл, статические ресурсы, серверный рендеринг, API"}]]},"version":""},{"id":228,"title":"Gez","content":"#\n\n\nВведение#\n\nGez — это высокопроизводительный фреймворк для веб-приложений, основанный на\nRspack, который предоставляет полный набор функций для управления жизненным\nциклом приложения, обработки статических ресурсов и серверного рендеринга.\n\n\nОпределения типов#\n\n\nRuntimeTarget#\n\n * Определение типа:\n\n\n\nТип среды выполнения приложения:\n\n * client: Работает в браузерной среде, поддерживает операции с DOM и API\n   браузера.\n * server: Работает в среде Node.js, поддерживает файловую систему и серверные\n   функции.\n\n\nImportMap#\n\n * Определение типа:\n\n\n\nТип карты импорта ES-модулей.\n\nSpecifierMap#\n\n * Определение типа:\n\n\n\nТип карты идентификаторов модулей, используемый для определения соответствия\nпутей импорта модулей.\n\nScopesMap#\n\n * Определение типа:\n\n\n\nТип карты областей видимости, используемый для определения соответствия путей\nимпорта модулей в определенных областях видимости.\n\n\nCOMMAND#\n\n * Определение типа:\n\n\n\nПеречисление типов команд:\n\n * dev: Команда для среды разработки, запускает сервер разработки с поддержкой\n   горячей перезагрузки.\n * build: Команда сборки, генерирует артефакты для production-среды.\n * preview: Команда предпросмотра, запускает локальный сервер для предпросмотра.\n * start: Команда запуска, запускает сервер для production-среды.\n\n\nОпции экземпляра#\n\nОпределение основных параметров конфигурации фреймворка Gez.\n\n\n\nroot#\n\n * Тип: string\n * Значение по умолчанию: process.cwd()\n\nПуть к корневой директории проекта. Может быть абсолютным или относительным\nпутем, относительные пути разрешаются относительно текущей рабочей директории.\n\nisProd#\n\n * Тип: boolean\n * Значение по умолчанию: process.env.NODE_ENV === 'production'\n\nИдентификатор среды.\n\n * true: Production-среда.\n * false: Среда разработки.\n\nbasePathPlaceholder#\n\n * Тип: string | false\n * Значение по умолчанию: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nКонфигурация заполнителя базового пути. Используется для динамической замены\nбазового пути ресурсов во время выполнения. Установка значения false отключает\nэту функцию.\n\nmodules#\n\n * Тип: ModuleConfig\n\nОпции конфигурации модулей. Используются для настройки правил разрешения модулей\nпроекта, включая псевдонимы модулей и внешние зависимости.\n\npacks#\n\n * Тип: PackConfig\n\nОпции конфигурации сборки. Используются для упаковки артефактов сборки в\nстандартные npm-пакеты формата .tgz.\n\ndevApp#\n\n * Тип: (gez: Gez) => Promise\n\nФункция создания приложения для среды разработки. Используется только в среде\nразработки для создания экземпляра приложения сервера разработки.\n\n\n\nserver#\n\n * Тип: (gez: Gez) => Promise\n\nФункция конфигурации запуска сервера. Используется для настройки и запуска\nHTTP-сервера, может использоваться как в среде разработки, так и в\nproduction-среде.\n\n\n\npostBuild#\n\n * Тип: (gez: Gez) => Promise\n\nФункция постобработки сборки. Выполняется после завершения сборки проекта и\nможет использоваться для:\n\n * Дополнительной обработки ресурсов.\n * Операций развертывания.\n * Генерации статических файлов.\n * Отправки уведомлений о сборке.\n\n\nСвойства экземпляра#\n\n\nname#\n\n * Тип: string\n * Только для чтения: true\n\nИмя текущего модуля, полученное из конфигурации модуля.\n\n\nvarName#\n\n * Тип: string\n * Только для чтения: true\n\nДопустимое имя переменной JavaScript, сгенерированное на основе имени модуля.\n\n\nroot#\n\n * Тип: string\n * Только для чтения: true\n\nАбсолютный путь к корневой директории проекта. Если в конфигурации указан\nотносительный путь root, он будет разрешен относительно текущей рабочей\nдиректории.\n\n\nisProd#\n\n * Тип: boolean\n * Только для чтения: true\n\nОпределяет, находится ли текущая среда в production-режиме. Приоритет отдается\nпараметру isProd из конфигурации, если он не задан, используется значение\nprocess.env.NODE_ENV.\n\n\nbasePath#\n\n * Тип: string\n * Только для чтения: true\n * Исключение: NotReadyError - если фреймворк не инициализирован\n\nПолучает базовый путь модуля, начинающийся и заканчивающийся косой чертой.\nВозвращает путь в формате /${name}/, где name берется из конфигурации модуля.\n\n\nbasePathPlaceholder#\n\n * Тип: string\n * Только для чтения: true\n\nПолучает заполнитель базового пути для динамической замены во время выполнения.\nМожет быть отключен через конфигурацию.\n\n\nmiddleware#\n\n * Тип: Middleware\n * Только для чтения: true\n\nПолучает middleware для обработки статических ресурсов. В зависимости от среды\nпредоставляет разные реализации:\n\n * Среда разработки: поддерживает компиляцию исходного кода в реальном времени и\n   горячую перезагрузку.\n * Production-среда: поддерживает долгосрочное кэширование статических ресурсов.\n\n\n\n\nrender#\n\n * Тип: (options?: RenderContextOptions) => Promise\n * Только для чтения: true\n\nПолучает функцию серверного рендеринга. В зависимости от среды предоставляет\nразные реализации:\n\n * Среда разработки: поддерживает горячую перезагрузку и предпросмотр в реальном\n   времени.\n * Production-среда: обеспечивает оптимизированную производительность\n   рендеринга.\n\n\n\n\nCOMMAND#\n\n * Тип: typeof COMMAND\n * Только для чтения: true\n\nПолучает определение перечисления типов команд.\n\n\nmoduleConfig#\n\n * Тип: ParsedModuleConfig\n * Только для чтения: true\n * Исключение: NotReadyError - если фреймворк не инициализирован\n\nПолучает полную информацию о конфигурации текущего модуля, включая правила\nразрешения модулей и настройки псевдонимов.\n\n\npackConfig#\n\n * Тип: ParsedPackConfig\n * Только для чтения: true\n * Исключение: NotReadyError - если фреймворк не инициализирован\n\nПолучает конфигурацию, связанную с упаковкой текущего модуля, включая пути\nвывода и обработку package.json.\n\n\nМетоды экземпляра#\n\n\nconstructor()#\n\n * Параметры:\n   * options?: GezOptions - параметры конфигурации фреймворка\n * Возвращаемое значение: Gez\n\nСоздает экземпляр фреймворка Gez.\n\n\n\n\ninit()#\n\n * Параметры: command: COMMAND\n * Возвращаемое значение: Promise\n * Исключения:\n   * Error: при повторной инициализации\n   * NotReadyError: при доступе к неинициализированному экземпляру\n\nИнициализирует экземпляр фреймворка Gez. Выполняет следующие основные шаги\nинициализации:\n\n 1. Разрешает конфигурацию проекта (package.json, конфигурация модулей,\n    конфигурация сборки и т.д.)\n 2. Создает экземпляр приложения (для среды разработки или production-среды)\n 3. Выполняет соответствующие методы жизненного цикла в зависимости от команды\n\nВнимание\n * Повторная инициализация вызовет ошибку\n * Доступ к неинициализированному экземпляру вызовет NotReadyError\n\n\n\n\ndestroy()#\n\n * Возвращаемое значение: Promise\n\nУничтожает экземпляр фреймворка Gez, выполняя очистку ресурсов и закрытие\nсоединений. В основном используется для:\n\n * Закрытия сервера разработки\n * Очистки временных файлов и кэша\n * Освобождения системных ресурсов\n\n\n\n\nbuild()#\n\n * Возвращаемое значение: Promise\n\nВыполняет процесс сборки приложения, включая:\n\n * Компиляцию исходного кода\n * Генерацию артефактов сборки для production-среды\n * Оптимизацию и сжатие кода\n * Генерацию манифеста ресурсов\n\nВнимание\n\nВызов до инициализации экземпляра фреймворка вызовет NotReadyError\n\n\n\n\nserver()#\n\n * Возвращаемое значение: Promise\n * Исключение: NotReadyError - если фреймворк не инициализирован\n\nЗапускает HTTP-сервер и настраивает экземпляр сервера. Вызывается на следующих\nэтапах жизненного цикла:\n\n * Среда разработки (dev): запускает сервер разработки с поддержкой горячей\n   перезагрузки\n * Production-среда (start): запускает сервер для production-среды с\n   production-производительностью\n\n\n\n\npostBuild()#\n\n * Возвращаемое значение: Promise\n\nВыполняет логику постобработки сборки, используется для:\n\n * Генерации статических HTML-файлов\n * Обработки артефактов сборки\n * Выполнения задач развертывания\n * Отправки уведомлений о сборке\n\n\n\n\nresolvePath#\n\nРазрешает путь проекта, преобразуя относительный путь в абсолютный.\n\n * Параметры:\n   \n   * projectPath: ProjectPath - тип пути проекта\n   * ...args: string[] - фрагменты пути\n\n * Возвращаемое значение: string - разрешенный абсолютный путь\n\n * Пример:\n\n\n\n\nwriteSync()#\n\nСинхронно записывает содержимое в файл.\n\n * Параметры:\n   \n   * filepath: string - абсолютный путь к файлу\n   * data: any - данные для записи, могут быть строкой, Buffer или объектом\n\n * Возвращаемое значение: boolean - успешность записи\n\n * Пример:\n\n\n\n\nreadJsonSync()#\n\nСинхронно читает и парсит JSON-файл.\n\n * Параметры:\n   \n   * filename: string - абсолютный путь к JSON-файлу\n\n * Возвращаемое значение: any - распарсенный JSON-объект\n\n * Исключение: выбрасывается, если файл не существует или JSON имеет неверный\n   формат\n\n * Пример:\n\n\n\n\nreadJson()#\n\nАсинхронно читает и парсит JSON-файл.\n\n * Параметры:\n   \n   * filename: string - абсолютный путь к JSON-файлу\n\n * Возвращаемое значение: Promise - распарсенный JSON-объект\n\n * Исключение: выбрасывается, если файл не существует или JSON имеет неверный\n   формат\n\n * Пример:\n\n\n\n\ngetManifestList()#\n\nПолучает список манифестов сборки","routePath":"/ru/api/core/gez","lang":"ru","toc":[{"text":"Введение","id":"введение","depth":2,"charIndex":3},{"text":"Определения типов","id":"определения-типов","depth":2,"charIndex":244},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":265},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":519},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":586},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":726},{"text":"COMMAND","id":"command","depth":3,"charIndex":893},{"text":"Опции экземпляра","id":"опции-экземпляра","depth":2,"charIndex":1277},{"text":"root","id":"root","depth":4,"charIndex":1360},{"text":"isProd","id":"isprod","depth":4,"charIndex":1579},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1747},{"text":"modules","id":"modules","depth":4,"charIndex":2020},{"text":"packs","id":"packs","depth":4,"charIndex":2193},{"text":"devApp","id":"devapp","depth":4,"charIndex":2332},{"text":"server","id":"server","depth":4,"charIndex":2519},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":2722},{"text":"Свойства экземпляра","id":"свойства-экземпляра","depth":2,"charIndex":3002},{"text":"name","id":"name","depth":3,"charIndex":3025},{"text":"varName","id":"varname","depth":3,"charIndex":3133},{"text":"root","id":"root-1","depth":3,"charIndex":3266},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3476},{"text":"basePath","id":"basepath","depth":3,"charIndex":3706},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":3980},{"text":"middleware","id":"middleware","depth":3,"charIndex":4167},{"text":"render","id":"render","depth":3,"charIndex":4531},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":4899},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":5010},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":5266},{"text":"Методы экземпляра","id":"методы-экземпляра","depth":2,"charIndex":5507},{"text":"constructor()","id":"constructor","depth":3,"charIndex":5528},{"text":"init()","id":"init","depth":3,"charIndex":5689},{"text":"destroy()","id":"destroy","depth":3,"charIndex":6360},{"text":"build()","id":"build","depth":3,"charIndex":6628},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":7605},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":7875},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":8143},{"text":"readJson()","id":"readjson","depth":3,"charIndex":8432},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":8722}],"domain":"","frontmatter":{"titleSuffix":"Справочник API основных классов фреймворка","description":"Подробное описание API основных классов фреймворка Gez, включая управление жизненным циклом приложения, обработку статических ресурсов и возможности серверного рендеринга, чтобы помочь разработчикам глубже понять ключевые функции фреймворка.","head":[["meta",{"property":"keywords","content":"Gez, API, управление жизненным циклом, статические ресурсы, серверный рендеринг, Rspack, фреймворк для веб-приложений"}]]},"version":""},{"id":229,"title":"ManifestJson","content":"#\n\nmanifest.json — это файл манифеста, генерируемый фреймворком Gez в процессе\nсборки, который используется для записи информации о результатах сборки сервиса.\nОн предоставляет унифицированный интерфейс для управления артефактами сборки,\nэкспортируемыми файлами и статистикой размеров ресурсов.\n\n\n\n\nОпределение типов#\n\n\nManifestJson#\n\n\n\nname#\n\n * Тип: string\n\nИмя сервиса, взятое из конфигурации GezOptions.name.\n\nexports#\n\n * Тип: Record\n\nОтображение экспортируемых файлов, где ключ — это путь к исходному файлу, а\nзначение — путь к собранному файлу.\n\nbuildFiles#\n\n * Тип: string[]\n\nПолный список файлов артефактов сборки, включающий пути ко всем сгенерированным\nфайлам.\n\nchunks#\n\n * Тип: Record\n\nСоответствие между исходными файлами и скомпилированными артефактами, где ключ —\nэто путь к исходному файлу, а значение — информация о компиляции.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Тип: string\n\nПуть к JS-файлу, скомпилированному из текущего исходного файла.\n\ncss#\n\n * Тип: string[]\n\nСписок путей к CSS-файлам, связанным с текущим исходным файлом.\n\nresources#\n\n * Тип: string[]\n\nСписок путей к другим ресурсам, связанным с текущим исходным файлом.\n\nsizes#\n\n * Тип: ManifestJsonChunkSizes\n\nСтатистика размеров артефактов сборки.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Тип: number\n\nРазмер JS-файла (в байтах).\n\ncss#\n\n * Тип: number\n\nРазмер CSS-файла (в байтах).\n\nresource#\n\n * Тип: number\n\nРазмер ресурсного файла (в байтах).","routePath":"/ru/api/core/manifest-json","lang":"ru","toc":[{"text":"Определение типов","id":"определение-типов","depth":2,"charIndex":298},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":336},{"text":"exports","id":"exports","depth":4,"charIndex":413},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":552},{"text":"chunks","id":"chunks","depth":4,"charIndex":672},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":846},{"text":"js","id":"js","depth":4,"charIndex":869},{"text":"css","id":"css","depth":4,"charIndex":955},{"text":"resources","id":"resources","depth":4,"charIndex":1044},{"text":"sizes","id":"sizes","depth":4,"charIndex":1144},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1225},{"text":"js","id":"js-1","depth":4,"charIndex":1252},{"text":"css","id":"css-1","depth":4,"charIndex":1302},{"text":"resource","id":"resource","depth":4,"charIndex":1354}],"domain":"","frontmatter":{"titleSuffix":"Справочник по файлу манифеста сборки Gez","description":"Подробное описание структуры файла манифеста сборки (manifest.json) в фреймворке Gez, включая управление артефактами сборки, отображение экспортируемых файлов и статистику ресурсов, чтобы помочь разработчикам понять и использовать систему сборки.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, манифест сборки, управление ресурсами, артефакты сборки, отображение файлов, API"}]]},"version":""},{"id":230,"title":"ModuleConfig","content":"#\n\nModuleConfig предоставляет функциональность конфигурации модулей в Gez, позволяя\nопределять правила импорта/экспорта модулей, настройку алиасов и внешние\nзависимости.\n\n\nОпределение типов#\n\n\nPathType#\n\n * Определение типа:\n\n\n\nПеречисление типов путей модулей:\n\n * npm: указывает на зависимости в node_modules\n * root: указывает на файлы в корневой директории проекта\n\n\nModuleConfig#\n\n * Определение типа:\n\n\n\nИнтерфейс конфигурации модулей, используемый для определения экспорта, импорта и\nвнешних зависимостей сервиса.\n\nexports#\n\nСписок конфигураций экспорта, который позволяет открывать определённые единицы\nкода (например, компоненты, утилиты и т.д.) в формате ESM.\n\nПоддерживаются два типа:\n\n * root:*: экспорт исходных файлов, например: 'root:src/components/button.vue'\n * npm:*: экспорт сторонних зависимостей, например: 'npm:vue'\n\nimports#\n\nКарта конфигураций импорта, которая определяет удалённые модули и их локальные\nпути.\n\nКонфигурация зависит от способа установки:\n\n * Установка из исходников (Workspace, Git): необходимо указывать на директорию\n   dist\n * Установка пакетов (Link, статический сервер, приватный репозиторий, File):\n   указывать напрямую на директорию пакета\n\nexternals#\n\nКарта внешних зависимостей, которая определяет используемые внешние зависимости,\nобычно это зависимости из удалённых модулей.\n\nПример:\n\n\n\n\nParsedModuleConfig#\n\n * Определение типа:\n\n\n\nРазобранная конфигурация модулей, которая преобразует исходную конфигурацию в\nстандартизированный внутренний формат:\n\nname#\n\nИмя текущего сервиса\n\n * Используется для идентификации модулей и генерации путей импорта\n\nroot#\n\nПуть к корневой директории текущего сервиса\n\n * Используется для разрешения относительных путей и хранения артефактов сборки\n\nexports#\n\nСписок конфигураций экспорта\n\n * name: исходный путь экспорта, например: 'npm:vue' или 'root:src/components'\n * type: тип пути (npm или root)\n * importName: имя импорта, формат: '${serviceName}/${type}/${path}'\n * exportName: путь экспорта, относительно корневой директории сервиса\n * exportPath: фактический путь к файлу\n * externalName: имя внешней зависимости, используемое для идентификации при\n   импорте этого модуля в других сервисах\n\nimports#\n\nСписок конфигураций импорта\n\n * name: имя внешнего сервиса\n * localPath: локальный путь хранения, используемый для хранения артефактов\n   сборки внешних модулей\n\nexternals#\n\nКарта внешних зависимостей\n\n * Сопоставляет пути импорта модулей с фактическими путями модулей\n * match: регулярное выражение для сопоставления операторов импорта\n * import: фактический путь к модулю","routePath":"/ru/api/core/module-config","lang":"ru","toc":[{"text":"Определение типов","id":"определение-типов","depth":2,"charIndex":171},{"text":"PathType","id":"pathtype","depth":3,"charIndex":192},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":521},{"text":"imports","id":"imports","depth":4,"charIndex":838},{"text":"externals","id":"externals","depth":4,"charIndex":1188},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1339},{"text":"name","id":"name","depth":4,"charIndex":1502},{"text":"root","id":"root","depth":4,"charIndex":1600},{"text":"exports","id":"exports-1","depth":4,"charIndex":1733},{"text":"imports","id":"imports-1","depth":4,"charIndex":2185},{"text":"externals","id":"externals-1","depth":4,"charIndex":2357}],"domain":"","frontmatter":{"titleSuffix":"Справочник API конфигурации модулей Gez","description":"Подробное описание интерфейса конфигурации ModuleConfig в Gez, включая правила импорта/экспорта модулей, настройку алиасов и управление внешними зависимостями, чтобы помочь разработчикам глубже понять модульную систему фреймворка.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, конфигурация модулей, импорт/экспорт модулей, внешние зависимости, настройка алиасов, управление зависимостями, фреймворк для веб-приложений"}]]},"version":""},{"id":231,"title":"PackConfig","content":"#\n\nPackConfig — это интерфейс конфигурации упаковки пакетов, используемый для\nупаковки артефактов сборки сервиса в стандартный формат npm .tgz.\n\n * Стандартизация: Использует стандартный формат упаковки npm .tgz\n * Полнота: Включает все необходимые файлы, такие как исходный код модуля,\n   объявления типов и конфигурационные файлы\n * Совместимость: Полностью совместим с экосистемой npm, поддерживает\n   стандартные рабочие процессы управления пакетами\n\n\nОпределение типа#\n\n\n\n\nPackConfig#\n\nenable#\n\nВключает или отключает функцию упаковки. При включении артефакты сборки будут\nупакованы в стандартный формат npm .tgz.\n\n * Тип: boolean\n * Значение по умолчанию: false\n\noutputs#\n\nУказывает путь к выходному файлу пакета. Поддерживаются следующие варианты\nконфигурации:\n\n * string: Один выходной путь, например, 'dist/versions/my-app.tgz'\n * string[]: Несколько выходных путей для одновременного создания нескольких\n   версий\n * boolean: При значении true используется путь по умолчанию\n   'dist/client/versions/latest.tgz'\n\npackageJson#\n\nФункция обратного вызова для настройки содержимого package.json. Вызывается\nперед упаковкой для изменения содержимого package.json.\n\n * Параметры:\n   * gez: Gez — экземпляр Gez\n   * pkg: any — исходное содержимое package.json\n * Возвращаемое значение: Promise — измененное содержимое package.json\n\nТипичные применения:\n\n * Изменение имени пакета и версии\n * Добавление или обновление зависимостей\n * Добавление пользовательских полей\n * Настройка информации о публикации\n\nПример:\n\n\n\nonBefore#\n\nФункция обратного вызова для подготовки перед упаковкой.\n\n * Параметры:\n   * gez: Gez — экземпляр Gez\n   * pkg: Record — содержимое package.json\n * Возвращаемое значение: Promise\n\nТипичные применения:\n\n * Добавление дополнительных файлов (README, LICENSE и т.д.)\n * Выполнение тестов или проверка сборки\n * Генерация документации или метаданных\n * Очистка временных файлов\n\nПример:\n\n\n\nonAfter#\n\nФункция обратного вызова для обработки после завершения упаковки. Вызывается\nпосле создания файла .tgz для обработки результатов упаковки.\n\n * Параметры:\n   * gez: Gez — экземпляр Gez\n   * pkg: Record — содержимое package.json\n   * file: Buffer — содержимое упакованного файла\n * Возвращаемое значение: Promise\n\nТипичные применения:\n\n * Публикация в npm-репозиторий (публичный или приватный)\n * Загрузка на сервер статических ресурсов\n * Управление версиями\n * Запуск CI/CD-процессов\n\nПример:\n\n\n\n\nПример использования#\n\n","routePath":"/ru/api/core/pack-config","lang":"ru","toc":[{"text":"Определение типа","id":"определение-типа","depth":2,"charIndex":455},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":490},{"text":"outputs","id":"outputs","depth":4,"charIndex":668},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":1022},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1519},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1915},{"text":"Пример использования","id":"пример-использования","depth":2,"charIndex":2422}],"domain":"","frontmatter":{"titleSuffix":"Справочник API конфигурации сборки Gez","description":"Подробное описание интерфейса конфигурации PackConfig в рамках Gez, включая правила упаковки пакетов, настройки вывода и хуки жизненного цикла, чтобы помочь разработчикам реализовать стандартизированные процессы сборки.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, упаковка пакетов, конфигурация сборки, хуки жизненного цикла, конфигурация упаковки, фреймворк для веб-приложений"}]]},"version":""},{"id":232,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ru/api/core/render-context","lang":"ru","toc":[{"text":"Определения типов","id":"определения-типов","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Параметры экземпляра","id":"параметры-экземпляра","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Свойства экземпляра","id":"свойства-экземпляра","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Методы экземпляра","id":"методы-экземпляра","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Справочник API контекста рендеринга Gez","description":"Подробное описание основного класса RenderContext в фреймворке Gez, включая управление рендерингом, управление ресурсами, синхронизацию состояния и управление маршрутизацией, чтобы помочь разработчикам реализовать эффективный серверный рендеринг.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, серверный рендеринг, контекст рендеринга, синхронизация состояния, управление ресурсами, фреймворк для веб-приложений"}]]},"version":""},{"id":233,"title":"От совместного использования компонентов к нативной модульности: путь эволюции микрофронтенд фреймворка Gez","content":"От совместного использования компонентов к нативной модульности: путь эволюции\nмикрофронтенд фреймворка Gez#\n\n\nКонтекст проекта#\n\nВ последние годы архитектура микрофронтенда искала правильный путь. Однако мы\nнаблюдали множество сложных технических решений, которые с помощью множества\nслоев и искусственной изоляции пытались имитировать идеальный мир\nмикрофронтенда. Эти решения приносили значительные потери производительности,\nусложняли разработку и делали стандартные процессы запутанными.\n\n\nОграничения традиционных решений#\n\nВ процессе практики микрофронтенд архитектуры мы глубоко осознали множество\nограничений традиционных решений:\n\n * Потери производительности: инъекция зависимостей в runtime, проксирование\n   JS-песочницы — каждая операция потребляет драгоценную производительность.\n * Хрупкая изоляция: искусственно созданная среда песочницы никогда не сможет\n   достичь нативной изоляции браузера.\n * Сложность сборки: для обработки зависимостей приходится модифицировать\n   инструменты сборки, что делает простые проекты сложными в поддержке.\n * Пользовательские правила: специальные стратегии развертывания, обработка в\n   runtime — каждый шаг отклоняется от стандартных процессов современной\n   разработки.\n * Ограничения экосистемы: привязка к фреймворкам, пользовательские API — выбор\n   технологий вынужденно ограничивается конкретной экосистемой.\n\nЭти проблемы особенно ярко проявились в нашем корпоративном проекте 2019 года.\nТогда крупный продукт был разделен на более чем десять независимых\nбизнес-подсистем, которые должны были использовать общий набор базовых и\nбизнес-компонентов. Изначально использованное решение на основе npm-пакетов для\nсовместного использования компонентов выявило серьезные проблемы с\nэффективностью поддержки: при обновлении общих компонентов все подсистемы,\nзависящие от них, должны были проходить полный процесс сборки и развертывания.\n\n\nТехническая эволюция#\n\n\nv1.0: Исследование удаленных компонентов#\n\nДля решения проблемы эффективности совместного использования компонентов Gez\nv1.0 представил механизм RemoteView на основе HTTP-протокола. Это решение\nреализовало динамическую сборку кода между сервисами по запросу в runtime,\nуспешно решив проблему длинных цепочек зависимостей при сборке. Однако из-за\nотсутствия стандартизированного механизма коммуникации в runtime, синхронизация\nсостояния и передача событий между сервисами все еще оставались неэффективными.\n\n\nv2.0: Попытка с Module Federation#\n\nВ версии v2.0 мы использовали технологию Module Federation из Webpack 5.0. Эта\nтехнология значительно повысила эффективность взаимодействия между сервисами\nблагодаря унифицированному механизму загрузки модулей и контейнеру в runtime.\nОднако в крупномасштабной практике закрытая реализация Module Federation\nпринесла новые вызовы: стало сложно управлять точными версиями зависимостей,\nособенно при унификации общих зависимостей между несколькими сервисами, часто\nвозникали конфликты версий и ошибки в runtime.\n\n\nВступление в новую эру ESM#\n\nПри планировании версии v3.0 мы глубоко изучили тенденции развития фронтенд\nэкосистемы и обнаружили, что прогресс нативных возможностей браузера открывает\nновые возможности для архитектуры микрофронтенда:\n\n\nСтандартизированная модульная система#\n\nС полной поддержкой ES Modules в основных браузерах и зрелостью спецификации\nImport Maps, фронтенд разработка вступила в настоящую эру модульности. Согласно\nданным Can I Use, поддержка ESM в основных браузерах (Chrome >= 89, Edge >= 89,\nFirefox >= 108, Safari >= 16.4) достигла 93.5%, что предоставило нам следующие\nпреимущества:\n\n * Стандартизация управления зависимостями: Import Maps предоставляет\n   возможность разрешения зависимостей модулей на уровне браузера, без сложной\n   инъекции в runtime.\n * Оптимизация загрузки ресурсов: Нативный механизм кэширования модулей в\n   браузере значительно повышает эффективность загрузки ресурсов.\n * Упрощение процесса сборки: Разработка на основе ESM делает процессы сборки в\n   разработке и производстве более согласованными.\n\nКроме того, благодаря поддержке режима совместимости (Chrome >= 87, Edge >= 88,\nFirefox >= 78, Safari >= 14), мы можем увеличить покрытие браузеров до 96.81%,\nчто позволяет нам сохранять высокую производительность, не жертвуя поддержкой\nстарых браузеров.\n\n\nПрорыв в производительности и изоляции#\n\nНативная модульная система приносит не только стандартизацию, но и значительное\nулучшение производительности и изоляции:\n\n * Нулевые накладные расходы в runtime: Прощание с проксированием JS-песочницы и\n   инъекцией в runtime в традиционных решениях микрофронтенда.\n * Надежная изоляция: Строгая область видимости модулей ESM естественным образом\n   обеспечивает наиболее надежную изоляцию.\n * Точное управление зависимостями: Статический анализ импорта делает\n   зависимости более прозрачными, а управление версиями — более точным.\n\n\nВыбор инструментов сборки#\n\nВ процессе реализации технических решений выбор инструментов сборки был ключевым\nрешением. После почти года исследований и практики наш выбор прошел следующие\nэтапы:\n\n 1. Исследование Vite\n    \n    * Преимущества: Сервер разработки на основе ESM, обеспечивающий превосходный\n      опыт разработки.\n    * Проблемы: Различия в сборке между средой разработки и производственной\n      средой создавали некоторую неопределенность.\n\n 2. Утверждение Rspack\n    \n    * Преимущества производительности: Высокая скорость компиляции благодаря\n      Rust.\n    * Поддержка экосистемы: Высокая совместимость с экосистемой Webpack, что\n      снижает затраты на миграцию.\n    * Поддержка ESM: Практика проекта Rslib подтвердила надежность Rspack в\n      сборке ESM.\n\nЭто решение позволило нам сохранить опыт разработки, одновременно получив более\nстабильную поддержку производственной среды. На основе комбинации ESM и Rspack\nмы в итоге создали высокопроизводительное и малоинвазивное решение для\nмикрофронтенда.\n\n\nПерспективы на будущее#\n\nВ планах развития фреймворка Gez основное внимание будет уделено следующим трем\nнаправлениям:\n\n\nГлубокая оптимизация Import Maps#\n\n * Динамическое управление зависимостями: Реализация интеллектуального\n   планирования версий зависимостей в runtime для решения конфликтов между\n   несколькими приложениями.\n * Стратегия предзагрузки: Интеллектуальная предзагрузка на основе анализа\n   маршрутов для повышения эффективности загрузки ресурсов.\n * Оптимизация сборки: Автоматическая генерация оптимальной конфигурации Import\n   Maps для снижения затрат на ручную настройку разработчиками.\n\n\nНезависимая от фреймворка маршрутизация#\n\n * Унифицированная абстракция маршрутизации: Разработка независимого от\n   фреймворка интерфейса маршрутизации, поддерживающего Vue, React и другие\n   популярные фреймворки.\n * Маршрутизация микро-приложений: Реализация взаимодействия маршрутов между\n   приложениями для поддержания согласованности URL и состояния приложения.\n * Промежуточное ПО маршрутизации: Предоставление расширяемого механизма\n   промежуточного ПО для поддержки контроля доступа, переходов между страницами\n   и других функций.\n\n\nЛучшие практики межфреймворковой коммуникации#\n\n * Примеры приложений: Предоставление полных примеров межфреймворковой\n   коммуникации, охватывающих Vue, React, Preact и другие популярные фреймворки.\n * Синхронизация состояния: Легковесное решение для совместного использования\n   состояния на основе ESM.\n * Шина событий: Стандартизированный механизм коммуникации событий для поддержки\n   развязанной коммуникации между приложениями.\n\nС помощью этих оптимизаций и расширений мы надеемся сделать Gez более\nсовершенным и удобным решением для микрофронтенда, предоставляя разработчикам\nлучший опыт разработки и более высокую эффективность.","routePath":"/ru/blog/birth-of-gez","lang":"ru","toc":[{"text":"Контекст проекта","id":"контекст-проекта","depth":2,"charIndex":110},{"text":"Ограничения традиционных решений","id":"ограничения-традиционных-решений","depth":3,"charIndex":494},{"text":"Техническая эволюция","id":"техническая-эволюция","depth":2,"charIndex":1890},{"text":"v1.0: Исследование удаленных компонентов","id":"v10-исследование-удаленных-компонентов","depth":3,"charIndex":1914},{"text":"v2.0: Попытка с Module Federation","id":"v20-попытка-с-module-federation","depth":3,"charIndex":2422},{"text":"Вступление в новую эру ESM","id":"вступление-в-новую-эру-esm","depth":2,"charIndex":2969},{"text":"Стандартизированная модульная система","id":"стандартизированная-модульная-система","depth":3,"charIndex":3205},{"text":"Прорыв в производительности и изоляции","id":"прорыв-в-производительности-и-изоляции","depth":3,"charIndex":4277},{"text":"Выбор инструментов сборки","id":"выбор-инструментов-сборки","depth":3,"charIndex":4853},{"text":"Перспективы на будущее","id":"перспективы-на-будущее","depth":2,"charIndex":5880},{"text":"Глубокая оптимизация Import Maps","id":"глубокая-оптимизация-import-maps","depth":3,"charIndex":6001},{"text":"Независимая от фреймворка маршрутизация","id":"независимая-от-фреймворка-маршрутизация","depth":3,"charIndex":6492},{"text":"Лучшие практики межфреймворковой коммуникации","id":"лучшие-практики-межфреймворковой-коммуникации","depth":3,"charIndex":7037}],"domain":"","frontmatter":{"titleSuffix":"От проблем микрофронтенда к инновациям ESM: путь эволюции фреймворка Gez","description":"Глубокое погружение в эволюцию фреймворка Gez от традиционных проблем микрофронтенда к инновационным решениям на основе ESM, с опытом в оптимизации производительности, управлении зависимостями и выборе инструментов сборки.","head":[["meta",{"property":"keywords","content":"Gez, микрофронтенд, ESM, Import Maps, Rspack, Module Federation, управление зависимостями, оптимизация производительности, техническая эволюция, серверный рендеринг"}]],"sidebar":false},"version":""},{"id":234,"title":"Блог команды","content":"#\n\nДобро пожаловать в технический блог команды Gez! Здесь мы делимся опытом\nразработки фреймворков, технологическими инновациями и лучшими практиками.\n\n\nПоследние статьи#\n\n * 2025-02-25 От совместного использования компонентов до нативной модульности:\n   путь эволюции микрофронтенд-фреймворка Gez\n   \n   > Исследуем путь эволюции фреймворка Gez от традиционного совместного\n   > использования компонентов до нативной модульности на основе ESM. Делимся\n   > техническим опытом в области оптимизации производительности, управления\n   > зависимостями и выбора инструментов сборки.","routePath":"/ru/blog/","lang":"ru","toc":[{"text":"Последние статьи","id":"последние-статьи","depth":2,"charIndex":152}],"domain":"","frontmatter":{"titleSuffix":"Блог команды Gez","description":"Технический блог команды Gez, где мы делимся опытом разработки фреймворков, лучшими практиками и технологическими инновациями.","head":[["meta",{"property":"keywords","content":"Gez, блог команды, технические статьи, лучшие практики, опыт разработки"}]],"sidebar":false},"version":""},{"id":235,"title":"Псевдонимы путей","content":"#\n\nПсевдонимы путей (Path Alias) — это механизм сопоставления путей импорта\nмодулей, который позволяет разработчикам использовать короткие, семантически\nзначимые идентификаторы вместо полных путей модулей. В Gez механизм псевдонимов\nпутей имеет следующие преимущества:\n\n * Упрощение путей импорта: Использование семантически значимых псевдонимов\n   вместо длинных относительных путей, что повышает читаемость кода.\n * Избегание глубокой вложенности: Устранение сложностей, связанных с\n   многоуровневыми ссылками на каталоги (например, ../../../../).\n * Безопасность типов: Полная интеграция с системой типов TypeScript,\n   обеспечивающая автодополнение и проверку типов.\n * Оптимизация разрешения модулей: Ускорение разрешения модулей за счет\n   предопределенного сопоставления путей.\n\n\nМеханизм псевдонимов по умолчанию#\n\nGez использует автоматический механизм псевдонимов на основе имени сервиса\n(Service Name). Этот подход, основанный на соглашениях, имеет следующие\nособенности:\n\n * Автоматическая настройка: Псевдонимы автоматически генерируются на основе\n   поля name в package.json, без необходимости ручной настройки.\n * Единый стандарт: Обеспечивает единообразие в именовании и ссылках на модули\n   всех сервисов.\n * Поддержка типов: В сочетании с командой npm run build:dts автоматически\n   генерируются файлы объявлений типов, что позволяет осуществлять вывод типов\n   между сервисами.\n * Предсказуемость: Путь модуля можно определить по имени сервиса, что снижает\n   затраты на поддержку.\n\n\nНастройка#\n\n\nНастройка в package.json#\n\nВ package.json имя сервиса определяется через поле name, которое будет\nиспользоваться как префикс псевдонима по умолчанию:\n\n\n\n\nНастройка в tsconfig.json#\n\nЧтобы TypeScript мог правильно разрешать пути с псевдонимами, необходимо\nнастроить сопоставление paths в tsconfig.json:\n\n\n\n\nПримеры использования#\n\n\nИмпорт внутренних модулей сервиса#\n\n\n\n\nИмпорт модулей других сервисов#\n\n\n\nЛучшие практики\n * Предпочитайте использование псевдонимов путей вместо относительных путей.\n * Поддерживайте семантическую значимость и единообразие псевдонимов путей.\n * Избегайте использования слишком большого количества уровней вложенности в\n   псевдонимах путей.\n\n\n\n\nИмпорт между сервисами#\n\nПосле настройки связей модулей (Module Link) можно использовать аналогичный\nспособ для импорта модулей других сервисов:\n\n\n\n\nПользовательские псевдонимы#\n\nДля сторонних пакетов или особых случаев можно настроить пользовательские\nпсевдонимы через конфигурационный файл Gez:\n\n\n\nВажные замечания\n 1. Для бизнес-модулей рекомендуется всегда использовать механизм псевдонимов по\n    умолчанию, чтобы поддерживать единообразие проекта.\n 2. Пользовательские псевдонимы в основном используются для обработки особых\n    требований сторонних пакетов или оптимизации процесса разработки.\n 3. Чрезмерное использование пользовательских псевдонимов может негативно\n    сказаться на поддерживаемости кода и оптимизации сборки.","routePath":"/ru/guide/essentials/alias","lang":"ru","toc":[{"text":"Механизм псевдонимов по умолчанию","id":"механизм-псевдонимов-по-умолчанию","depth":2,"charIndex":787},{"text":"Настройка","id":"настройка","depth":2,"charIndex":1503},{"text":"Настройка в package.json","id":"настройка-в-packagejson","depth":3,"charIndex":1516},{"text":"Настройка в tsconfig.json","id":"настройка-в-tsconfigjson","depth":3,"charIndex":1670},{"text":"Примеры использования","id":"примеры-использования","depth":2,"charIndex":1822},{"text":"Импорт внутренних модулей сервиса","id":"импорт-внутренних-модулей-сервиса","depth":3,"charIndex":1847},{"text":"Импорт модулей других сервисов","id":"импорт-модулей-других-сервисов","depth":3,"charIndex":1886},{"text":"Импорт между сервисами","id":"импорт-между-сервисами","depth":3,"charIndex":2193},{"text":"Пользовательские псевдонимы","id":"пользовательские-псевдонимы","depth":3,"charIndex":2342}],"domain":"","frontmatter":{"titleSuffix":"Руководство по сопоставлению путей импорта модулей в Gez","description":"Подробное описание механизма псевдонимов путей в Gez, включая упрощение путей импорта, избегание глубокой вложенности, безопасность типов и оптимизацию разрешения модулей, чтобы помочь разработчикам повысить поддерживаемость кода.","head":[["meta",{"property":"keywords","content":"Gez, псевдонимы путей, Path Alias, TypeScript, импорт модулей, сопоставление путей, поддерживаемость кода"}]]},"version":""},{"id":236,"title":"Базовый путь","content":"#\n\nБазовый путь (Base Path) — это префикс пути доступа к статическим ресурсам\n(таким как JavaScript, CSS, изображения и т.д.) в приложении. В Gez правильная\nнастройка базового пути имеет решающее значение для следующих сценариев:\n\n * Развертывание в нескольких средах: поддержка доступа к ресурсам в различных\n   средах, таких как разработка, тестирование и производство.\n * Развертывание в нескольких регионах: адаптация к требованиям развертывания в\n   различных регионах или странах.\n * CDN-распределение: реализация глобального распределения и ускорения\n   статических ресурсов.\n\n\nМеханизм пути по умолчанию#\n\nGez использует механизм автоматической генерации путей на основе имени сервиса.\nПо умолчанию фреймворк считывает поле name из файла package.json проекта для\nгенерации базового пути статических ресурсов: /your-app-name/.\n\n\n\nТакой подход, основанный на соглашениях, имеет следующие преимущества:\n\n * Согласованность: обеспечивает использование единого пути доступа для всех\n   статических ресурсов.\n * Предсказуемость: путь доступа к ресурсам можно определить по полю name в\n   package.json.\n * Удобство поддержки: отсутствие необходимости в дополнительной настройке\n   снижает затраты на обслуживание.\n\n\nДинамическая настройка пути#\n\nВ реальных проектах часто требуется развернуть один и тот же код в разных средах\nили регионах. Gez поддерживает динамическую настройку базового пути, что\nпозволяет приложению адаптироваться к различным сценариям развертывания.\n\n\nСценарии использования#\n\nРазвертывание в подкаталоге#\n\n\n\nРазвертывание на отдельных доменах#\n\n\n\n\nМетод настройки#\n\nС помощью параметра base метода gez.render() вы можете динамически установить\nбазовый путь в зависимости от контекста запроса:\n\n","routePath":"/ru/guide/essentials/base-path","lang":"ru","toc":[{"text":"Механизм пути по умолчанию","id":"механизм-пути-по-умолчанию","depth":2,"charIndex":584},{"text":"Динамическая настройка пути","id":"динамическая-настройка-пути","depth":2,"charIndex":1216},{"text":"Сценарии использования","id":"сценарии-использования","depth":3,"charIndex":1475},{"text":"Развертывание в подкаталоге","id":"развертывание-в-подкаталоге","depth":4,"charIndex":1500},{"text":"Развертывание на отдельных доменах","id":"развертывание-на-отдельных-доменах","depth":4,"charIndex":1532},{"text":"Метод настройки","id":"метод-настройки","depth":3,"charIndex":1572}],"domain":"","frontmatter":{"titleSuffix":"Руководство по настройке путей статических ресурсов в Gez","description":"Подробное руководство по настройке базового пути в Gez, включая развертывание в нескольких средах, CDN-распределение и настройку путей доступа к ресурсам, чтобы помочь разработчикам реализовать гибкое управление статическими ресурсами.","head":[["meta",{"property":"keywords","content":"Gez, базовый путь, Base Path, CDN, статические ресурсы, развертывание в нескольких средах, управление ресурсами"}]]},"version":""},{"id":237,"title":"Клиентский рендеринг","content":"\n${rc.importmap()} // Карта импорта ${rc.moduleEntry()} // Входной модуль\n${rc.modulePreload()} // Предзагрузка модулей","routePath":"/ru/guide/essentials/csr","lang":"ru","toc":[{"text":"Сценарии использования","id":"сценарии-использования","depth":2,"charIndex":-1},{"text":"Настройка","id":"настройка","depth":2,"charIndex":-1},{"text":"Конфигурация HTML-шаблона","id":"конфигурация-html-шаблона","depth":3,"charIndex":-1},{"text":"Генерация статического HTML","id":"генерация-статического-html","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Руководство по реализации клиентского рендеринга в Gez","description":"Подробное описание механизма клиентского рендеринга в Gez, включая статическую сборку, стратегии развертывания и лучшие практики, помогающие разработчикам реализовать эффективный фронтенд-рендеринг в бессерверной среде.","head":[["meta",{"property":"keywords","content":"Gez, клиентский рендеринг, CSR, статическая сборка, фронтенд-рендеринг, бессерверное развертывание, оптимизация производительности"}]]},"version":""},{"id":238,"title":"Связывание модулей","content":"#\n\nGez предоставляет полный механизм связывания модулей для управления совместным\nиспользованием кода и зависимостями между сервисами. Этот механизм реализован на\nоснове спецификации ESM (ECMAScript Module) и поддерживает экспорт и импорт\nмодулей на уровне исходного кода, а также полное управление зависимостями.\n\n\nОсновные концепции#\n\nЭкспорт модулей#\n\nЭкспорт модулей — это процесс предоставления доступа к определенным единицам\nкода (например, компонентам, утилитам и т.д.) из сервиса в формате ESM.\nПоддерживаются два типа экспорта:\n\n * Экспорт исходного кода: прямое экспортирование файлов исходного кода из\n   проекта\n * Экспорт зависимостей: экспортирование сторонних пакетов, используемых в\n   проекте\n\nИмпорт модулей#\n\nИмпорт модулей — это процесс использования единиц кода, экспортированных другими\nсервисами. Поддерживаются несколько способов установки:\n\n * Установка исходного кода: подходит для среды разработки, поддерживает\n   изменения в реальном времени и горячую перезагрузку\n * Установка пакетов: подходит для производственной среды, использует готовые\n   сборки\n\n\nМеханизм предварительной загрузки#\n\nДля оптимизации производительности сервисов Gez реализует интеллектуальный\nмеханизм предварительной загрузки модулей:\n\n 1. Анализ зависимостей\n    \n    * Анализ зависимостей между компонентами во время сборки\n    * Идентификация ключевых модулей на критическом пути\n    * Определение приоритета загрузки модулей\n\n 2. Стратегия загрузки\n    \n    * Немедленная загрузка: ключевые модули на критическом пути\n    * Отложенная загрузка: модули неключевых функций\n    * Загрузка по требованию: модули, отображаемые условно\n\n 3. Оптимизация ресурсов\n    \n    * Интеллектуальная стратегия разделения кода\n    * Управление кэшированием на уровне модулей\n    * Компиляция и сборка по требованию\n\n\nЭкспорт модулей#\n\n\nНастройка#\n\nНастройка экспортируемых модулей в entry.node.ts:\n\n\n\nКонфигурация экспорта поддерживает два типа:\n\n * root:*: экспорт файлов исходного кода, путь относительно корня проекта\n * npm:*: экспорт сторонних зависимостей, указывается имя пакета\n\n\nИмпорт модулей#\n\n\nНастройка#\n\nНастройка импортируемых модулей в entry.node.ts:\n\n\n\nОписание конфигурации:\n\n 1. imports: настройка локальных путей для удаленных модулей\n    \n    * Установка исходного кода: указывает на директорию сборки (dist)\n    * Установка пакетов: указывает на директорию пакета\n\n 2. externals: настройка внешних зависимостей\n    \n    * Для совместного использования зависимостей из удаленных модулей\n    * Избежание дублирования сборки одинаковых зависимостей\n    * Поддержка совместного использования зависимостей несколькими модулями\n\n\nСпособы установки#\n\nУстановка исходного кода#\n\nПодходит для среды разработки, поддерживает изменения в реальном времени и\nгорячую перезагрузку.\n\n 1. Workspace Рекомендуется для использования в Monorepo:\n\n\n\n 2. Link Для локальной разработки и отладки:\n\n\n\nУстановка пакетов#\n\nПодходит для производственной среды, использует готовые сборки.\n\n 1. NPM Registry Установка через npm registry:\n\n\n\n 2. Статический сервер Установка через HTTP/HTTPS:\n\n\n\n\nСборка пакетов#\n\n\nНастройка#\n\nНастройка параметров сборки в entry.node.ts:\n\n\n\n\nРезультаты сборки#\n\n\n\n\nПроцесс публикации#\n\n\n\n\nЛучшие практики#\n\n\nНастройка среды разработки#\n\n * Управление зависимостями\n   \n   * Использование Workspace или Link для установки зависимостей\n   * Унификация версий зависимостей\n   * Избежание дублирования зависимостей\n\n * Опыт разработки\n   \n   * Включение горячей перезагрузки\n   * Настройка подходящей стратегии предварительной загрузки\n   * Оптимизация скорости сборки\n\n\nНастройка производственной среды#\n\n * Стратегия развертывания\n   \n   * Использование NPM Registry или статического сервера\n   * Обеспечение целостности сборки\n   * Внедрение механизма постепенного развертывания\n\n * Оптимизация производительности\n   \n   * Настройка предварительной загрузки ресурсов\n   * Оптимизация порядка загрузки модулей\n   * Внедрение эффективной стратегии кэширования\n\n\nУправление версиями#\n\n * Стандарты версий\n   \n   * Следование семантическому версионированию\n   * Ведение подробного журнала изменений\n   * Проведение тестов на совместимость версий\n\n * Обновление зависимостей\n   \n   * Своевременное обновление пакетов\n   * Регулярный аудит безопасности\n   * Поддержание согласованности версий зависимостей","routePath":"/ru/guide/essentials/module-link","lang":"ru","toc":[{"text":"Основные концепции","id":"основные-концепции","depth":3,"charIndex":315},{"text":"Экспорт модулей","id":"экспорт-модулей","depth":4,"charIndex":336},{"text":"Импорт модулей","id":"импорт-модулей","depth":4,"charIndex":711},{"text":"Механизм предварительной загрузки","id":"механизм-предварительной-загрузки","depth":3,"charIndex":1084},{"text":"Экспорт модулей","id":"экспорт-модулей-1","depth":2,"charIndex":1807},{"text":"Настройка","id":"настройка","depth":3,"charIndex":1826},{"text":"Импорт модулей","id":"импорт-модулей-1","depth":2,"charIndex":2078},{"text":"Настройка","id":"настройка-1","depth":3,"charIndex":2096},{"text":"Способы установки","id":"способы-установки","depth":3,"charIndex":2636},{"text":"Установка исходного кода","id":"установка-исходного-кода","depth":4,"charIndex":2656},{"text":"Установка пакетов","id":"установка-пакетов","depth":4,"charIndex":2890},{"text":"Сборка пакетов","id":"сборка-пакетов","depth":2,"charIndex":3080},{"text":"Настройка","id":"настройка-2","depth":3,"charIndex":3098},{"text":"Результаты сборки","id":"результаты-сборки","depth":3,"charIndex":3159},{"text":"Процесс публикации","id":"процесс-публикации","depth":3,"charIndex":3182},{"text":"Лучшие практики","id":"лучшие-практики","depth":2,"charIndex":3206},{"text":"Настройка среды разработки","id":"настройка-среды-разработки","depth":3,"charIndex":3225},{"text":"Настройка производственной среды","id":"настройка-производственной-среды","depth":3,"charIndex":3584},{"text":"Управление версиями","id":"управление-версиями","depth":3,"charIndex":3976}],"domain":"","frontmatter":{"titleSuffix":"Механизм совместного использования кода между сервисами в Gez","description":"Подробное описание механизма связывания модулей в Gez, включая совместное использование кода между сервисами, управление зависимостями и реализацию спецификации ESM, чтобы помочь разработчикам создавать эффективные микрофронтенд-приложения.","head":[["meta",{"property":"keywords","content":"Gez, связывание модулей, Module Link, ESM, совместное использование кода, управление зависимостями, микрофронтенд"}]]},"version":""},{"id":239,"title":"Контекст рендеринга","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ru/guide/essentials/render-context","lang":"ru","toc":[{"text":"Использование","id":"использование","depth":2,"charIndex":-1},{"text":"Основные функции","id":"основные-функции","depth":2,"charIndex":-1},{"text":"Сбор зависимостей","id":"сбор-зависимостей","depth":3,"charIndex":-1},{"text":"Сбор по требованию","id":"сбор-по-требованию","depth":4,"charIndex":-1},{"text":"Автоматическая обработка","id":"автоматическая-обработка","depth":4,"charIndex":-1},{"text":"Оптимизация производительности","id":"оптимизация-производительности","depth":4,"charIndex":-1},{"text":"Внедрение ресурсов","id":"внедрение-ресурсов","depth":3,"charIndex":-1},{"text":"Порядок внедрения ресурсов","id":"порядок-внедрения-ресурсов","depth":3,"charIndex":-1},{"text":"Полный процесс рендеринга","id":"полный-процесс-рендеринга","depth":2,"charIndex":-1},{"text":"Расширенные возможности","id":"расширенные-возможности","depth":2,"charIndex":-1},{"text":"Настройка базового пути","id":"настройка-базового-пути","depth":3,"charIndex":-1},{"text":"Режимы отображения импорта","id":"режимы-отображения-импорта","depth":3,"charIndex":-1},{"text":"Настройка входной функции","id":"настройка-входной-функции","depth":3,"charIndex":-1},{"text":"Рекомендации","id":"рекомендации","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Основные механизмы серверного рендеринга в Gez","description":"Подробное описание механизма контекста рендеринга (RenderContext) в Gez, включая управление ресурсами, генерацию HTML и систему модулей ESM, чтобы помочь разработчикам понять и использовать функции серверного рендеринга.","head":[["meta",{"property":"keywords","content":"Gez, контекст рендеринга, RenderContext, SSR, серверный рендеринг, ESM, управление ресурсами"}]]},"version":""},{"id":240,"title":"Rspack","content":"#\n\nGez реализован на основе системы сборки Rspack, которая обеспечивает высокую\nпроизводительность сборки. В этом документе описаны роль и ключевые функции\nRspack в фреймворке Gez.\n\n\nОсобенности#\n\nRspack является основной системой сборки фреймворка Gez и предоставляет\nследующие ключевые функции:\n\n * Высокая производительность сборки: Движок сборки, реализованный на Rust,\n   обеспечивает высокую скорость компиляции, что значительно ускоряет сборку\n   крупных проектов.\n * Оптимизация опыта разработки: Поддержка горячей перезагрузки (HMR),\n   инкрементальной компиляции и других современных функций разработки,\n   обеспечивая плавный процесс разработки.\n * Сборка для нескольких сред: Унифицированная конфигурация сборки поддерживает\n   клиентскую (client), серверную (server) и Node.js (node) среды, упрощая\n   процесс разработки для нескольких платформ.\n * Оптимизация ресурсов: Встроенные возможности обработки и оптимизации\n   ресурсов, включая разделение кода, Tree Shaking, сжатие ресурсов и другие\n   функции.\n\n\nСборка приложения#\n\nСистема сборки Rspack в Gez имеет модульную архитектуру и включает следующие\nосновные модули:\n\n\n@gez/rspack#\n\nБазовый модуль сборки, предоставляющий следующие ключевые возможности:\n\n * Унифицированная конфигурация сборки: Стандартизированное управление\n   конфигурацией сборки с поддержкой конфигурации для нескольких сред.\n * Обработка ресурсов: Встроенная поддержка обработки TypeScript, CSS,\n   изображений и других ресурсов.\n * Оптимизация сборки: Функции оптимизации производительности, такие как\n   разделение кода и Tree Shaking.\n * Сервер разработки: Интеграция высокопроизводительного сервера разработки с\n   поддержкой HMR.\n\n\n@gez/rspack-vue#\n\nСпециализированный модуль сборки для фреймворка Vue, предоставляющий:\n\n * Компиляция компонентов Vue: Поддержка эффективной компиляции компонентов Vue\n   2/3.\n * Оптимизация SSR: Специальная оптимизация для сценариев серверного рендеринга.\n * Улучшения для разработки: Улучшения для среды разработки Vue.\n\n\nПроцесс сборки#\n\nПроцесс сборки в Gez состоит из следующих этапов:\n\n 1. Инициализация конфигурации\n    \n    * Загрузка конфигурации проекта\n    * Объединение конфигурации по умолчанию и пользовательской конфигурации\n    * Настройка конфигурации в зависимости от переменных окружения\n\n 2. Компиляция ресурсов\n    \n    * Анализ зависимостей исходного кода\n    * Преобразование различных ресурсов (TypeScript, CSS и т.д.)\n    * Обработка импорта и экспорта модулей\n\n 3. Оптимизация\n    \n    * Выполнение разделения кода\n    * Применение Tree Shaking\n    * Сжатие кода и ресурсов\n\n 4. Генерация выходных данных\n    \n    * Генерация целевых файлов\n    * Создание карты ресурсов\n    * Генерация отчета о сборке\n\n\nЛучшие практики#\n\n\nОптимизация среды разработки#\n\n * Конфигурация инкрементальной компиляции: Правильная настройка параметра cache\n   для ускорения сборки за счет использования кэша.\n * Оптимизация HMR: Целевая настройка области действия горячей перезагрузки для\n   избежания ненужных обновлений модулей.\n * Оптимизация обработки ресурсов: Использование подходящих конфигураций loader\n   для избежания повторной обработки.\n\n\nОптимизация производственной среды#\n\n * Стратегия разделения кода: Правильная настройка splitChunks для оптимизации\n   загрузки ресурсов.\n * Сжатие ресурсов: Включение подходящих настроек сжатия для баланса между\n   временем сборки и размером выходных данных.\n * Оптимизация кэша: Использование хэшей содержимого и стратегий долгосрочного\n   кэширования для повышения производительности загрузки.\n\n\nПример конфигурации#\n\n\n\nTIP\n\nДля получения более подробной информации о API и параметрах конфигурации,\nобратитесь к документации Rspack API.","routePath":"/ru/guide/essentials/rspack","lang":"ru","toc":[{"text":"Особенности","id":"особенности","depth":2,"charIndex":182},{"text":"Сборка приложения","id":"сборка-приложения","depth":2,"charIndex":1021},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1137},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1677},{"text":"Процесс сборки","id":"процесс-сборки","depth":2,"charIndex":2002},{"text":"Лучшие практики","id":"лучшие-практики","depth":2,"charIndex":2709},{"text":"Оптимизация среды разработки","id":"оптимизация-среды-разработки","depth":3,"charIndex":2728},{"text":"Оптимизация производственной среды","id":"оптимизация-производственной-среды","depth":3,"charIndex":3134},{"text":"Пример конфигурации","id":"пример-конфигурации","depth":2,"charIndex":3533}],"domain":"","frontmatter":{"titleSuffix":"Высокопроизводительный движок сборки Gez","description":"Подробный анализ системы сборки Rspack в фреймворке Gez, включая высокопроизводительную компиляцию, сборку для нескольких сред, оптимизацию ресурсов и другие ключевые функции, которые помогают разработчикам создавать эффективные и надежные современные веб-приложения.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, система сборки, высокопроизводительная компиляция, горячая перезагрузка, сборка для нескольких сред, Tree Shaking, разделение кода, SSR, оптимизация ресурсов, эффективность разработки, инструменты сборки"}]]},"version":""},{"id":241,"title":"Стандартные нормы","content":"#\n\nGez — это современный SSR-фреймворк, использующий стандартизированную структуру\nпроекта и механизмы разрешения путей для обеспечения согласованности и\nподдерживаемости проекта в средах разработки и производства.\n\n\nНормы структуры проекта#\n\n\nСтандартная структура каталогов#\n\n\n\nДополнительная информация\n * gez.name берется из поля name в package.json\n * dist/package.json берется из package.json в корневом каталоге\n * Архивация каталога dist происходит только при установке packs.enable в true\n\n\nНормы входных файлов#\n\n\nentry.client.ts#\n\nКлиентский входной файл отвечает за:\n\n * Инициализацию приложения: настройка базовых параметров клиентского приложения\n * Управление маршрутизацией: обработка клиентских маршрутов и навигации\n * Управление состоянием: реализация хранения и обновления состояния клиента\n * Обработку взаимодействий: управление пользовательскими событиями и\n   взаимодействиями с интерфейсом\n\n\nentry.server.ts#\n\nСерверный входной файл отвечает за:\n\n * Серверный рендеринг: выполнение процесса SSR-рендеринга\n * Генерацию HTML: построение начальной структуры страницы\n * Предварительное получение данных: обработка получения данных на сервере\n * Инъекцию состояния: передача состояния сервера клиенту\n * Оптимизацию SEO: обеспечение оптимизации для поисковых систем\n\n\nentry.node.ts#\n\nВходной файл Node.js-сервера отвечает за:\n\n * Конфигурацию сервера: настройка параметров HTTP-сервера\n * Обработку маршрутов: управление правилами маршрутизации на сервере\n * Интеграцию промежуточного ПО: настройка промежуточного ПО сервера\n * Управление окружением: обработка переменных окружения и конфигураций\n * Обработку запросов и ответов: обработка HTTP-запросов и ответов\n\n\nНормы конфигурационных файлов#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/ru/guide/essentials/std","lang":"ru","toc":[{"text":"Нормы структуры проекта","id":"нормы-структуры-проекта","depth":2,"charIndex":216},{"text":"Стандартная структура каталогов","id":"стандартная-структура-каталогов","depth":3,"charIndex":243},{"text":"Нормы входных файлов","id":"нормы-входных-файлов","depth":2,"charIndex":499},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":523},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":916},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1289},{"text":"Нормы конфигурационных файлов","id":"нормы-конфигурационных-файлов","depth":2,"charIndex":1687},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1720},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1738}],"domain":"","frontmatter":{"titleSuffix":"Руководство по структуре и стандартам проекта Gez","description":"Подробное описание стандартной структуры проекта, спецификаций входных файлов и конфигурационных файлов фреймворка Gez, помогающее разработчикам создавать стандартизированные и поддерживаемые SSR-приложения.","head":[["meta",{"property":"keywords","content":"Gez, структура проекта, входные файлы, конфигурационные стандарты, SSR-фреймворк, TypeScript, стандарты проекта, стандарты разработки"}]]},"version":""},{"id":242,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ru/guide/frameworks/html","lang":"ru","toc":[{"text":"Структура проекта","id":"структура-проекта","depth":2,"charIndex":-1},{"text":"Конфигурация проекта","id":"конфигурация-проекта","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Структура исходного кода","id":"структура-исходного-кода","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Запуск проекта","id":"запуск-проекта","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Пример HTML SSR приложения на фреймворке Gez","description":"Пошаговое руководство по созданию HTML SSR приложения на основе Gez, включая инициализацию проекта, настройку HTML и конфигурацию входных файлов.","head":[["meta",{"property":"keywords","content":"Gez, HTML, SSR приложение, конфигурация TypeScript, инициализация проекта, серверный рендеринг, клиентское взаимодействие"}]]},"version":""},{"id":243,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ru/guide/frameworks/preact-htm","lang":"ru","toc":[{"text":"Структура проекта","id":"структура-проекта","depth":2,"charIndex":-1},{"text":"Конфигурация проекта","id":"конфигурация-проекта","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Структура исходного кода","id":"структура-исходного-кода","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Запуск проекта","id":"запуск-проекта","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Пример SSR-приложения на Gez с использованием Preact+HTM","description":"Пошаговое руководство по созданию SSR-приложения на основе Gez с использованием Preact и HTM. Включает инициализацию проекта, настройку Preact и конфигурацию входных файлов.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, SSR-приложение, конфигурация TypeScript, инициализация проекта, серверный рендеринг, клиентское взаимодействие"}]]},"version":""},{"id":244,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ru/guide/frameworks/vue2","lang":"ru","toc":[{"text":"Структура проекта","id":"структура-проекта","depth":2,"charIndex":-1},{"text":"Конфигурация проекта","id":"конфигурация-проекта","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Структура исходного кода","id":"структура-исходного-кода","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Запуск проекта","id":"запуск-проекта","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Пример приложения Vue2 SSR на фреймворке Gez","description":"Пошаговое руководство по созданию приложения Vue2 SSR с использованием фреймворка Gez. Включает инициализацию проекта, настройку Vue2 и конфигурацию входных файлов.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, SSR приложение, TypeScript конфигурация, инициализация проекта, серверный рендеринг, клиентское взаимодействие"}]]},"version":""},{"id":245,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ru/guide/frameworks/vue3","lang":"ru","toc":[{"text":"Структура проекта","id":"структура-проекта","depth":2,"charIndex":-1},{"text":"Конфигурация проекта","id":"конфигурация-проекта","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Структура исходного кода","id":"структура-исходного-кода","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Запуск проекта","id":"запуск-проекта","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Пример SSR-приложения на Vue3 с использованием фреймворка Gez","description":"Пошаговое руководство по созданию SSR-приложения на Vue3 с использованием фреймворка Gez. Включает инициализацию проекта, настройку Vue3 и конфигурацию входных файлов.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, SSR-приложение, TypeScript, инициализация проекта, серверный рендеринг, клиентское взаимодействие, Composition API"}]]},"version":""},{"id":246,"title":"Требования к окружению","content":"#\n\nВ этом документе описаны требования к окружению, необходимые для использования\nданного фреймворка, включая окружение Node.js и совместимость с браузерами.\n\n\nОкружение Node.js#\n\nФреймворк требует версию Node.js >= 22.6, в основном для поддержки импорта типов\nTypeScript (через флаг --experimental-strip-types), без необходимости\nдополнительных шагов компиляции.\n\n\nСовместимость с браузерами#\n\nФреймворк по умолчанию использует режим совместимости для сборки, чтобы\nподдерживать более широкий спектр браузеров. Однако следует отметить, что для\nполной поддержки совместимости с браузерами необходимо вручную добавить\nзависимость es-module-shims.\n\n\nРежим совместимости (по умолчанию)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nСогласно статистике Can I Use, охват браузеров в режиме совместимости составляет\n96.81%.\n\n\nРежим нативной поддержки#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nРежим нативной поддержки имеет следующие преимущества:\n\n * Нулевые накладные расходы на выполнение, без необходимости дополнительного\n   загрузчика модулей\n * Нативный парсинг браузером, более высокая скорость выполнения\n * Лучшие возможности разделения кода и загрузки по требованию\n\nСогласно статистике Can I Use, охват браузеров в режиме нативной поддержки\nсоставляет 93.5%.\n\n\nВключение поддержки совместимости#\n\nВажное замечание\n\nХотя фреймворк по умолчанию использует режим совместимости для сборки, для\nполной поддержки старых версий браузеров необходимо добавить зависимость\nes-module-shims в ваш проект.\n\nДобавьте следующий скрипт в HTML-файл:\n\n\n\nРекомендации\n 1. Для производственной среды рекомендуется:\n    * Разместить es-module-shims на собственном сервере\n    * Обеспечить стабильность и скорость загрузки ресурсов\n    * Избежать потенциальных рисков безопасности\n 2. Соображения производительности:\n    * Режим совместимости может привести к небольшим накладным расходам на\n      производительность\n    * Можно решить, включать ли его, исходя из распределения браузеров среди\n      целевой аудитории","routePath":"/ru/guide/start/environment","lang":"ru","toc":[{"text":"Окружение Node.js","id":"окружение-nodejs","depth":2,"charIndex":159},{"text":"Совместимость с браузерами","id":"совместимость-с-браузерами","depth":2,"charIndex":365},{"text":"Режим совместимости (по умолчанию)","id":"режим-совместимости-по-умолчанию","depth":3,"charIndex":647},{"text":"Режим нативной поддержки","id":"режим-нативной-поддержки","depth":3,"charIndex":855},{"text":"Включение поддержки совместимости","id":"включение-поддержки-совместимости","depth":3,"charIndex":1345}],"domain":"","frontmatter":{"titleSuffix":"Руководство по совместимости фреймворка Gez","description":"Подробное описание требований к окружению для фреймворка Gez, включая требования к версии Node.js и совместимость с браузерами, чтобы помочь разработчикам правильно настроить среду разработки.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, совместимость с браузерами, TypeScript, es-module-shims, настройка окружения"}]]},"version":""},{"id":247,"title":"Быстрый старт","content":"#\n\n\nИнициализация проекта#\n\nЧтобы создать и инициализировать новый проект на Gez, выполните следующие шаги:\n\n\n\n\nВыбор версии фреймворка#\n\nФреймворк Gez предоставляет несколько версий для различных технологических\nстеков, каждая из которых оптимизирована для определенных сценариев\nиспользования. Выберите подходящую версию в зависимости от требований вашего\nпроекта:\n\n\nHTML#\n\nПодходит для проектов, требующих минималистичной архитектуры:\n\n * Нет внешних зависимостей, готов к использованию сразу после установки\n * Нативный опыт разработки на JavaScript\n * Идеально подходит для создания статических сайтов и легковесных приложений\n * Поддержка постепенного расширения функциональности\n\nПодробнее о версии HTML\n\n\nVue2#\n\nПодходит для разработки корпоративных приложений:\n\n * Полная поддержка TypeScript\n * Богатая экосистема сторонних компонентов\n * Зрелая цепочка инструментов разработки\n * Проверенная стабильность в производственной среде\n\nПодробнее о версии Vue2\n\n\nVue3#\n\nПодходит для разработки современных веб-приложений:\n\n * Реактивная система на основе Proxy\n * Поддержка Composition API\n * Улучшенная производительность во время выполнения\n * Меньший размер сборки\n\nПодробнее о версии Vue3\n\n\nPreact+HTM#\n\nПодходит для проектов, требующих минимального размера и высокой\nпроизводительности:\n\n * Очень маленький размер среды выполнения (3KB)\n * Нативный синтаксис шаблонов JavaScript\n * Совместимый с React API\n * Отличная производительность\n\nПодробнее о версии Preact+HTM\n\n\nAI-помощник в разработке#\n\nФреймворк Gez предоставляет возможность использования AI для помощи в\nразработке, что может значительно повысить эффективность:\n\n 1. Выберите подходящую версию фреймворка и ознакомьтесь с документацией\n 2. Передайте содержимое документации AI-помощнику\n 3. AI автоматически сгенерирует каркас проекта и конфигурационные файлы\n\nСовет\n\nИспользование AI-помощника не только ускоряет процесс инициализации проекта, но\nи гарантирует, что структура проекта соответствует лучшим практикам.","routePath":"/ru/guide/start/getting-started","lang":"ru","toc":[{"text":"Инициализация проекта","id":"инициализация-проекта","depth":2,"charIndex":3},{"text":"Выбор версии фреймворка","id":"выбор-версии-фреймворка","depth":2,"charIndex":111},{"text":"HTML","id":"html","depth":3,"charIndex":368},{"text":"Vue2","id":"vue2","depth":3,"charIndex":712},{"text":"Vue3","id":"vue3","depth":3,"charIndex":967},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1199},{"text":"AI-помощник в разработке","id":"ai-помощник-в-разработке","depth":2,"charIndex":1479}],"domain":"","frontmatter":{"titleSuffix":"Руководство по быстрому старту с фреймворком Gez","description":"Руководство по быстрому старту с фреймворком Gez, которое поможет вам начать проект с нуля, включая инициализацию проекта, выбор версии фреймворка и использование AI для разработки.","head":[["meta",{"name":"keywords","content":"Фреймворк Gez, Быстрый старт, Инициализация проекта, Разработка на Vue, Разработка на HTML, AI-помощник"}]]},"version":""},{"id":248,"title":"Введение","content":"#\n\n\nИстория проекта#\n\nGez — это современный микрофронтенд-фреймворк, основанный на ECMAScript Modules\n(ESM), который ориентирован на создание высокопроизводительных и масштабируемых\nприложений с серверным рендерингом (SSR). Как третье поколение проекта Genesis,\nGez постоянно развивается и внедряет инновации:\n\n * v1.0: Реализация отложенной загрузки удаленных компонентов на основе\n   HTTP-запросов\n * v2.0: Интеграция приложений с использованием Webpack Module Federation\n * v3.0: Переработанная система модульных связей на основе нативного ESM в\n   браузере\n\n\nТехнологический контекст#\n\nВ процессе развития микрофронтенд-архитектуры традиционные решения сталкивались\nс рядом ограничений:\n\n\nПроблемы существующих решений#\n\n * Проблемы производительности: Внедрение зависимостей во время выполнения и\n   использование JavaScript-песочниц приводят к значительным накладным расходам\n * Механизмы изоляции: Самодельные песочницы не могут сравниться с нативной\n   изоляцией модулей в браузере\n * Сложность сборки: Модификации инструментов сборки для совместного\n   использования зависимостей увеличивают затраты на поддержку проекта\n * Отклонение от стандартов: Специальные стратегии развертывания и механизмы\n   обработки во время выполнения противоречат современным стандартам\n   веб-разработки\n * Ограничения экосистемы: Привязка к фреймворкам и кастомные API ограничивают\n   выбор технологического стека\n\n\nТехнологические инновации#\n\nGez предлагает новое решение, основанное на современных веб-стандартах:\n\n * Нативная система модулей: Использование нативного ESM и Import Maps для\n   управления зависимостями обеспечивает более быстрый анализ и выполнение\n * Стандартные механизмы изоляции: Надежная изоляция приложений на основе\n   области видимости модулей ECMAScript\n * Открытый технологический стек: Поддержка интеграции с любыми современными\n   фронтенд-фреймворками\n * Оптимизация разработки: Интуитивно понятный режим разработки и полная\n   поддержка отладки\n * Максимальная оптимизация производительности: Нулевые накладные расходы\n   благодаря использованию нативных возможностей и интеллектуальной стратегии\n   кэширования\n\nTIP\n\nGez ориентирован на создание высокопроизводительной и легко расширяемой\nинфраструктуры для микрофронтендов, особенно подходящей для крупномасштабных\nприложений с серверным рендерингом.\n\n\nТехнические спецификации#\n\n\nЗависимости окружения#\n\nПодробные требования к браузерам и окружению Node.js можно найти в документации\nТребования к окружению.\n\n\nОсновной технологический стек#\n\n * Управление зависимостями: Использование Import Maps для отображения модулей и\n   es-module-shims для обеспечения совместимости\n * Система сборки: Обработка внешних зависимостей с помощью module-import на\n   основе Rspack\n * Инструменты разработки: Поддержка горячей замены модулей ESM и нативного\n   выполнения TypeScript\n\n\nПозиционирование фреймворка#\n\nGez отличается от Next.js или Nuxt.js, так как ориентирован на предоставление\nинфраструктуры для микрофронтендов:\n\n * Система модульных связей: Обеспечивает эффективный и надежный импорт и\n   экспорт модулей\n * Серверный рендеринг: Предоставляет гибкие механизмы реализации SSR\n * Поддержка системы типов: Полная интеграция с TypeScript\n * Независимость от фреймворков: Поддержка интеграции с основными\n   фронтенд-фреймворками\n\n\nАрхитектурный дизайн#\n\n\nЦентрализованное управление зависимостями#\n\n * Единый источник зависимостей: Централизованное управление сторонними\n   зависимостями\n * Автоматическое распространение: Глобальная автоматическая синхронизация\n   обновлений зависимостей\n * Согласованность версий: Точный контроль версий зависимостей\n\n\nМодульный дизайн#\n\n * Разделение обязанностей: Разделение бизнес-логики и инфраструктуры\n * Механизм плагинов: Гибкая комбинация и замена модулей\n * Стандартные интерфейсы: Унифицированные протоколы взаимодействия между\n   модулями\n\n\nОптимизация производительности#\n\n * Принцип нулевых накладных расходов: Максимальное использование нативных\n   возможностей браузера\n * Интеллектуальное кэширование: Точная стратегия кэширования на основе хэша\n   содержимого\n * Отложенная загрузка: Тонкое разделение кода и управление зависимостями\n\n\nЗрелость проекта#\n\nGez прошел почти 5 лет итеративного развития (от v1.0 до v3.0) и был полностью\nпроверен в корпоративных средах. В настоящее время он поддерживает стабильную\nработу десятков бизнес-проектов и продолжает способствовать модернизации\nтехнологического стека. Стабильность, надежность и преимущества в\nпроизводительности фреймворка были подтверждены на практике, что делает его\nнадежной основой для разработки крупномасштабных приложений.","routePath":"/ru/guide/start/introduction","lang":"ru","toc":[{"text":"История проекта","id":"история-проекта","depth":2,"charIndex":3},{"text":"Технологический контекст","id":"технологический-контекст","depth":2,"charIndex":562},{"text":"Проблемы существующих решений","id":"проблемы-существующих-решений","depth":3,"charIndex":692},{"text":"Технологические инновации","id":"технологические-инновации","depth":3,"charIndex":1406},{"text":"Технические спецификации","id":"технические-спецификации","depth":2,"charIndex":2327},{"text":"Зависимости окружения","id":"зависимости-окружения","depth":3,"charIndex":2355},{"text":"Основной технологический стек","id":"основной-технологический-стек","depth":3,"charIndex":2485},{"text":"Позиционирование фреймворка","id":"позиционирование-фреймворка","depth":2,"charIndex":2844},{"text":"Архитектурный дизайн","id":"архитектурный-дизайн","depth":2,"charIndex":3304},{"text":"Централизованное управление зависимостями","id":"централизованное-управление-зависимостями","depth":3,"charIndex":3328},{"text":"Модульный дизайн","id":"модульный-дизайн","depth":3,"charIndex":3628},{"text":"Оптимизация производительности","id":"оптимизация-производительности","depth":3,"charIndex":3862},{"text":"Зрелость проекта","id":"зрелость-проекта","depth":2,"charIndex":4163}],"domain":"","frontmatter":{"titleSuffix":"Обзор фреймворка Gez и технологические инновации","description":"Узнайте больше о проекте Gez, эволюции технологий и ключевых преимуществах этого микрофронтенд-фреймворка, а также исследуйте современные решения для серверного рендеринга на основе ESM.","head":[["meta",{"property":"keywords","content":"Gez, микрофронтенд, ESM, серверный рендеринг, SSR, технологические инновации, Module Federation"}]]},"version":""}]