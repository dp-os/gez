[{"id":275,"title":"@gez/rspack-vue","content":"#\n\nGói Rspack Vue cung cấp một bộ API để tạo và cấu hình ứng dụng Rspack dựa trên\nframework Vue, hỗ trợ phát triển component Vue, xây dựng và kết xuất phía máy\nchủ.\n\n\nCài đặt#\n\nSử dụng trình quản lý gói để cài đặt @gez/rspack-vue như một phụ thuộc phát\ntriển:\n\n\nXuất kiểu#\n\n\nBuildTarget#\n\n\n\nKiểu môi trường đích xây dựng, định nghĩa môi trường đích xây dựng của ứng dụng,\nđược sử dụng để cấu hình các tối ưu hóa và chức năng cụ thể trong quá trình xây\ndựng:\n\n * node: Xây dựng mã chạy trong môi trường Node.js\n * client: Xây dựng mã chạy trong môi trường trình duyệt\n * server: Xây dựng mã chạy trong môi trường máy chủ\n\n\nRspackAppConfigContext#\n\n\n\nGiao diện ngữ cảnh cấu hình ứng dụng Rspack, cung cấp thông tin ngữ cảnh có thể\ntruy cập trong các hàm hook cấu hình:\n\n * gez: Thể hiện của Gez Framework\n * buildTarget: Mục tiêu xây dựng hiện tại (client/server/node)\n * config: Đối tượng cấu hình Rspack\n * options: Tùy chọn cấu hình ứng dụng\n\n\nRspackAppOptions#\n\n\n\nGiao diện tùy chọn cấu hình ứng dụng Rspack:\n\n * css: Cách thức xuất CSS, có thể chọn 'css' (tệp độc lập) hoặc 'style' (style\n   nội tuyến)\n * loaders: Cấu hình loader tùy chỉnh\n * styleLoader: Tùy chọn cấu hình style-loader\n * cssLoader: Tùy chọn cấu hình css-loader\n * target: Cấu hình tương thích mục tiêu xây dựng\n * definePlugin: Định nghĩa hằng số toàn cục\n * config: Hàm hook cấu hình\n\n\nRspackHtmlAppOptions#\n\nKế thừa từ RspackAppOptions, được sử dụng để cấu hình các tùy chọn cụ thể cho\nứng dụng HTML.\n\n\nXuất hàm#\n\n\ncreateRspackApp#\n\n\n\nTạo một thể hiện ứng dụng Rspack tiêu chuẩn.\n\nTham số:\n\n * gez: Thể hiện của Gez Framework\n * options: Tùy chọn cấu hình ứng dụng Rspack\n\nGiá trị trả về:\n\n * Trả về một Promise, giải quyết thành thể hiện ứng dụng được tạo\n\n\ncreateRspackHtmlApp#\n\n\n\nTạo một thể hiện ứng dụng Rspack kiểu HTML.\n\nTham số:\n\n * gez: Thể hiện của Gez Framework\n * options: Tùy chọn cấu hình ứng dụng HTML\n\nGiá trị trả về:\n\n * Trả về một Promise, giải quyết thành thể hiện ứng dụng HTML được tạo\n\n\nXuất hằng số#\n\n\nRSPACK_LOADER#\n\n\n\nĐối tượng ánh xạ định danh loader tích hợp của Rspack, cung cấp các hằng số tên\nloader thông dụng:\n\n * builtinSwcLoader: SWC loader tích hợp của Rspack, được sử dụng để xử lý tệp\n   TypeScript/JavaScript\n * lightningcssLoader: lightningcss loader tích hợp của Rspack, được sử dụng để\n   xử lý tệp CSS với trình biên dịch hiệu suất cao\n * styleLoader: Loader được sử dụng để chèn CSS vào DOM\n * cssLoader: Loader được sử dụng để phân tích tệp CSS và xử lý module hóa CSS\n * lessLoader: Loader được sử dụng để biên dịch tệp Less thành CSS\n * styleResourcesLoader: Loader được sử dụng để tự động nhập tài nguyên style\n   toàn cục (như biến, mixins)\n * workerRspackLoader: Loader được sử dụng để xử lý tệp Web Worker\n\nSử dụng các hằng số này có thể tham chiếu đến các loader tích hợp trong cấu\nhình, tránh việc nhập chuỗi thủ công:\n\n\n\nLưu ý:\n\n * Các loader này đã được tích hợp sẵn trong Rspack, không cần cài đặt thêm\n * Khi cấu hình loader tùy chỉnh, có thể sử dụng các hằng số này để thay thế\n   triển khai loader mặc định\n * Một số loader (như builtinSwcLoader) có các tùy chọn cấu hình cụ thể, vui\n   lòng tham khảo tài liệu cấu hình tương ứng\n\n\nXuất module#\n\n\nrspack#\n\nXuất lại tất cả nội dung của gói @rspack/core, cung cấp đầy đủ chức năng cốt lõi\ncủa Rspack.","routePath":"/vi/api/app/rspack-vue","lang":"vi","toc":[{"text":"Cài đặt","id":"cài-đặt","depth":2,"charIndex":166},{"text":"Xuất kiểu","id":"xuất-kiểu","depth":2,"charIndex":261},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":274},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":621},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":944},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1359},{"text":"Xuất hàm","id":"xuất-hàm","depth":2,"charIndex":1477},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1489},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1733},{"text":"Xuất hằng số","id":"xuất-hằng-số","depth":2,"charIndex":1983},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":1999},{"text":"Xuất module","id":"xuất-module","depth":2,"charIndex":3164},{"text":"rspack","id":"rspack","depth":3,"charIndex":3179}],"domain":"","frontmatter":{"titleSuffix":"Công cụ xây dựng Vue của Gez Framework","description":"Công cụ xây dựng chuyên dụng cho Vue của Gez Framework, cung cấp hỗ trợ xây dựng ứng dụng Vue 2/3 đầy đủ, bao gồm phát triển component, kết xuất SSR và tối ưu hiệu suất.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, công cụ xây dựng, phát triển component, kết xuất phía máy chủ, tối ưu hiệu suất"}]]},"version":""},{"id":276,"title":"@gez/rspack","content":"#\n\nGói Rspack cung cấp một bộ API để tạo và cấu hình ứng dụng Rspack, hỗ trợ xây\ndựng và phát triển ứng dụng tiêu chuẩn và ứng dụng HTML.\n\n\nCài đặt#\n\nSử dụng trình quản lý gói để cài đặt phụ thuộc phát triển @gez/rspack:\n\n\nXuất kiểu#\n\n\nBuildTarget#\n\n\n\nKiểu môi trường mục tiêu xây dựng, định nghĩa môi trường mục tiêu xây dựng của\nứng dụng, được sử dụng để cấu hình các tối ưu hóa và chức năng cụ thể trong quá\ntrình xây dựng:\n\n * node: Xây dựng mã chạy trong môi trường Node.js\n * client: Xây dựng mã chạy trong môi trường trình duyệt\n * server: Xây dựng mã chạy trong môi trường máy chủ\n\n\nRspackAppConfigContext#\n\n\n\nGiao diện ngữ cảnh cấu hình ứng dụng Rspack, cung cấp thông tin ngữ cảnh có thể\ntruy cập trong các hàm hook cấu hình:\n\n * gez: Phiên bản Gez Framework\n * buildTarget: Mục tiêu xây dựng hiện tại (client/server/node)\n * config: Đối tượng cấu hình Rspack\n * options: Tùy chọn cấu hình ứng dụng\n\n\nRspackAppOptions#\n\n\n\nGiao diện tùy chọn cấu hình ứng dụng Rspack:\n\n * css: Cách xuất CSS, có thể chọn 'css' (tệp độc lập) hoặc 'style' (kiểu nội\n   tuyến)\n * loaders: Cấu hình loader tùy chỉnh\n * styleLoader: Tùy chọn cấu hình style-loader\n * cssLoader: Tùy chọn cấu hình css-loader\n * target: Cấu hình tương thích mục tiêu xây dựng\n * definePlugin: Định nghĩa hằng số toàn cục\n * config: Hàm hook cấu hình\n\n\nRspackHtmlAppOptions#\n\nKế thừa từ RspackAppOptions, được sử dụng để cấu hình các tùy chọn cụ thể cho\nứng dụng HTML.\n\n\nXuất hàm#\n\n\ncreateRspackApp#\n\n\n\nTạo một phiên bản ứng dụng Rspack tiêu chuẩn.\n\nTham số:\n\n * gez: Phiên bản Gez Framework\n * options: Tùy chọn cấu hình ứng dụng Rspack\n\nGiá trị trả về:\n\n * Trả về một Promise, giải quyết thành phiên bản ứng dụng được tạo\n\n\ncreateRspackHtmlApp#\n\n\n\nTạo một phiên bản ứng dụng Rspack kiểu HTML.\n\nTham số:\n\n * gez: Phiên bản Gez Framework\n * options: Tùy chọn cấu hình ứng dụng HTML\n\nGiá trị trả về:\n\n * Trả về một Promise, giải quyết thành phiên bản ứng dụng HTML được tạo\n\n\nXuất hằng số#\n\n\nRSPACK_LOADER#\n\n\n\nĐối tượng ánh xạ định danh loader tích hợp trong Rspack, cung cấp các hằng số\ntên loader thông dụng:\n\n * builtinSwcLoader: SWC loader tích hợp trong Rspack, được sử dụng để xử lý tệp\n   TypeScript/JavaScript\n * lightningcssLoader: lightningcss loader tích hợp trong Rspack, được sử dụng\n   để xử lý tệp CSS với trình biên dịch hiệu suất cao\n * styleLoader: Loader được sử dụng để chèn CSS vào DOM\n * cssLoader: Loader được sử dụng để phân tích tệp CSS và xử lý mô-đun hóa CSS\n * lessLoader: Loader được sử dụng để biên dịch tệp Less thành CSS\n * styleResourcesLoader: Loader được sử dụng để tự động nhập tài nguyên kiểu\n   toàn cục (như biến, mixins)\n * workerRspackLoader: Loader được sử dụng để xử lý tệp Web Worker\n\nSử dụng các hằng số này để tham chiếu các loader tích hợp trong cấu hình, tránh\nnhập chuỗi thủ công:\n\n\n\nLưu ý:\n\n * Các loader này đã được tích hợp sẵn trong Rspack, không cần cài đặt thêm\n * Khi cấu hình loader tùy chỉnh, có thể sử dụng các hằng số này để thay thế\n   triển khai loader mặc định\n * Một số loader (như builtinSwcLoader) có các tùy chọn cấu hình cụ thể, vui\n   lòng tham khảo tài liệu cấu hình tương ứng\n\n\nXuất mô-đun#\n\n\nrspack#\n\nXuất lại tất cả nội dung của gói @rspack/core, cung cấp đầy đủ chức năng cốt lõi\ncủa Rspack.","routePath":"/vi/api/app/rspack","lang":"vi","toc":[{"text":"Cài đặt","id":"cài-đặt","depth":2,"charIndex":139},{"text":"Xuất kiểu","id":"xuất-kiểu","depth":2,"charIndex":222},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":235},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":590},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":910},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1319},{"text":"Xuất hàm","id":"xuất-hàm","depth":2,"charIndex":1437},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1449},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1692},{"text":"Xuất hằng số","id":"xuất-hằng-số","depth":2,"charIndex":1941},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":1957},{"text":"Xuất mô-đun","id":"xuất-mô-đun","depth":2,"charIndex":3114},{"text":"rspack","id":"rspack","depth":3,"charIndex":3129}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rspack Build Tool","description":"Công cụ xây dựng Rspack của Gez Framework, cung cấp khả năng xây dựng ứng dụng hiệu suất cao, hỗ trợ phát triển và xây dựng ứng dụng tiêu chuẩn và ứng dụng HTML, tích hợp nhiều bộ xử lý tài nguyên và cấu hình tối ưu hóa.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, công cụ xây dựng, xây dựng ứng dụng, ứng dụng HTML, TypeScript, CSS, xử lý tài nguyên, tối ưu hóa hiệu suất"}]]},"version":""},{"id":277,"title":"App","content":"#\n\nApp là một abstraction (trừu tượng hóa) ứng dụng của framework Gez, cung cấp một\ngiao diện thống nhất để quản lý vòng đời ứng dụng, tài nguyên tĩnh và render\nphía máy chủ.\n\n\n\n\nĐịnh nghĩa kiểu#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Kiểu: Middleware\n\nMiddleware xử lý tài nguyên tĩnh.\n\nMôi trường phát triển:\n\n * Xử lý yêu cầu tài nguyên tĩnh từ mã nguồn\n * Hỗ trợ biên dịch thời gian thực và cập nhật nóng\n * Sử dụng chính sách cache no-cache\n\nMôi trường sản xuất:\n\n * Xử lý tài nguyên tĩnh đã được build\n * Hỗ trợ cache dài hạn cho các file không thay đổi (.final.xxx)\n * Chiến lược tải tài nguyên tối ưu\n\n\n\nrender#\n\n * Kiểu: (options?: RenderContextOptions) => Promise\n\nHàm render phía máy chủ. Cung cấp các triển khai khác nhau tùy theo môi trường\nchạy:\n\n * Môi trường sản xuất (start): Tải file entry phía máy chủ đã được build\n   (entry.server) để thực hiện render\n * Môi trường phát triển (dev): Tải file entry phía máy chủ từ mã nguồn để thực\n   hiện render\n\n\n\nbuild#\n\n * Kiểu: () => Promise\n\nHàm build cho môi trường sản xuất. Được sử dụng để đóng gói và tối ưu hóa tài\nnguyên. Trả về true nếu build thành công, false nếu thất bại.\n\ndestroy#\n\n * Kiểu: () => Promise\n\nHàm dọn dẹp tài nguyên. Được sử dụng để đóng server, ngắt kết nối, v.v. Trả về\ntrue nếu dọn dẹp thành công, false nếu thất bại.","routePath":"/vi/api/core/app","lang":"vi","toc":[{"text":"Định nghĩa kiểu","id":"định-nghĩa-kiểu","depth":2,"charIndex":178},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":205},{"text":"render","id":"render","depth":4,"charIndex":598},{"text":"build","id":"build","depth":4,"charIndex":957},{"text":"destroy","id":"destroy","depth":4,"charIndex":1130}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Application Abstract Interface","description":"Chi tiết về giao diện App của framework Gez, bao gồm quản lý vòng đời ứng dụng, xử lý tài nguyên tĩnh và chức năng render phía máy chủ, giúp nhà phát triển hiểu và sử dụng các chức năng cốt lõi của ứng dụng.","head":[["meta",{"property":"keywords","content":"Gez, App, Application Abstract, Lifecycle, Static Resources, Server-side Rendering, API"}]]},"version":""},{"id":278,"title":"Gez","content":"#\n\n\nGiới thiệu#\n\nGez là một framework ứng dụng web hiệu suất cao dựa trên Rspack, cung cấp đầy đủ\ncác khả năng quản lý vòng đời ứng dụng, xử lý tài nguyên tĩnh và render phía máy\nchủ.\n\n\nĐịnh nghĩa kiểu#\n\n\nRuntimeTarget#\n\n * Định nghĩa kiểu:\n\n\n\nLoại môi trường thời gian chạy ứng dụng:\n\n * client: Chạy trong môi trường trình duyệt, hỗ trợ thao tác DOM và API trình\n   duyệt\n * server: Chạy trong môi trường Node.js, hỗ trợ hệ thống tệp và các chức năng\n   phía máy chủ\n\n\nImportMap#\n\n * Định nghĩa kiểu:\n\n\n\nLoại ánh xạ nhập khẩu module ES.\n\nSpecifierMap#\n\n * Định nghĩa kiểu:\n\n\n\nLoại ánh xạ định danh module, dùng để định nghĩa mối quan hệ ánh xạ đường dẫn\nnhập khẩu module.\n\nScopesMap#\n\n * Định nghĩa kiểu:\n\n\n\nLoại ánh xạ phạm vi, dùng để định nghĩa mối quan hệ ánh xạ nhập khẩu module\ntrong phạm vi cụ thể.\n\n\nCOMMAND#\n\n * Định nghĩa kiểu:\n\n\n\nLoại enum lệnh:\n\n * dev: Lệnh môi trường phát triển, khởi động máy chủ phát triển và hỗ trợ cập\n   nhật nóng\n * build: Lệnh build, tạo ra các sản phẩm build cho môi trường sản xuất\n * preview: Lệnh xem trước, khởi động máy chủ xem trước cục bộ\n * start: Lệnh khởi động, chạy máy chủ môi trường sản xuất\n\n\nTùy chọn instance#\n\nĐịnh nghĩa các tùy chọn cấu hình cốt lõi của framework Gez.\n\n\n\nroot#\n\n * Loại: string\n * Mặc định: process.cwd()\n\nĐường dẫn thư mục gốc của dự án. Có thể là đường dẫn tuyệt đối hoặc tương đối,\nđường dẫn tương đối được phân giải dựa trên thư mục làm việc hiện tại.\n\nisProd#\n\n * Loại: boolean\n * Mặc định: process.env.NODE_ENV === 'production'\n\nĐịnh danh môi trường.\n\n * true: Môi trường sản xuất\n * false: Môi trường phát triển\n\nbasePathPlaceholder#\n\n * Loại: string | false\n * Mặc định: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nCấu hình trình giữ chỗ đường dẫn cơ sở. Dùng để thay thế động đường dẫn cơ sở\ncủa tài nguyên trong thời gian chạy. Đặt thành false để vô hiệu hóa tính năng\nnày.\n\nmodules#\n\n * Loại: ModuleConfig\n\nTùy chọn cấu hình module. Dùng để cấu hình các quy tắc phân giải module của dự\nán, bao gồm bí danh module, các phụ thuộc bên ngoài, v.v.\n\npacks#\n\n * Loại: PackConfig\n\nTùy chọn cấu hình đóng gói. Dùng để đóng gói các sản phẩm build thành các gói\nphần mềm .tgz npm tiêu chuẩn.\n\ndevApp#\n\n * Loại: (gez: Gez) => Promise\n\nHàm tạo ứng dụng môi trường phát triển. Chỉ được sử dụng trong môi trường phát\ntriển, dùng để tạo instance ứng dụng cho máy chủ phát triển.\n\n\n\nserver#\n\n * Loại: (gez: Gez) => Promise\n\nHàm cấu hình khởi động máy chủ. Dùng để cấu hình và khởi động máy chủ HTTP, có\nthể sử dụng trong cả môi trường phát triển và sản xuất.\n\n\n\npostBuild#\n\n * Loại: (gez: Gez) => Promise\n\nHàm xử lý hậu build. Được thực thi sau khi dự án build xong, có thể dùng để:\n\n * Thực hiện xử lý tài nguyên bổ sung\n * Thực hiện các thao tác triển khai\n * Tạo các tệp tĩnh\n * Gửi thông báo build\n\n\nThuộc tính instance#\n\n\nname#\n\n * Loại: string\n * Chỉ đọc: true\n\nTên module hiện tại, được lấy từ cấu hình module.\n\n\nvarName#\n\n * Loại: string\n * Chỉ đọc: true\n\nTên biến JavaScript hợp lệ được tạo dựa trên tên module.\n\n\nroot#\n\n * Loại: string\n * Chỉ đọc: true\n\nĐường dẫn tuyệt đối của thư mục gốc dự án. Nếu root được cấu hình là đường dẫn\ntương đối, nó sẽ được phân giải dựa trên thư mục làm việc hiện tại.\n\n\nisProd#\n\n * Loại: boolean\n * Chỉ đọc: true\n\nXác định xem hiện tại có phải là môi trường sản xuất hay không. Ưu tiên sử dụng\nisProd trong cấu hình, nếu không được cấu hình thì sẽ xác định dựa trên\nprocess.env.NODE_ENV.\n\n\nbasePath#\n\n * Loại: string\n * Chỉ đọc: true\n * Ném ra: NotReadyError - Khi framework chưa được khởi tạo\n\nLấy đường dẫn cơ sở của module bắt đầu và kết thúc bằng dấu gạch chéo. Định dạng\ntrả về là /${name}/, trong đó name được lấy từ cấu hình module.\n\n\nbasePathPlaceholder#\n\n * Loại: string\n * Chỉ đọc: true\n\nLấy trình giữ chỗ đường dẫn cơ sở dùng để thay thế động trong thời gian chạy. Có\nthể vô hiệu hóa thông qua cấu hình.\n\n\nmiddleware#\n\n * Loại: Middleware\n * Chỉ đọc: true\n\nLấy middleware xử lý tài nguyên tĩnh. Cung cấp các triển khai khác nhau tùy theo\nmôi trường:\n\n * Môi trường phát triển: Hỗ trợ biên dịch mã nguồn thời gian thực, cập nhật\n   nóng\n * Môi trường sản xuất: Hỗ trợ bộ nhớ đệm dài hạn cho tài nguyên tĩnh\n\n\n\n\nrender#\n\n * Loại: (options?: RenderContextOptions) => Promise\n * Chỉ đọc: true\n\nLấy hàm render phía máy chủ. Cung cấp các triển khai khác nhau tùy theo môi\ntrường:\n\n * Môi trường phát triển: Hỗ trợ cập nhật nóng và xem trước thời gian thực\n * Môi trường sản xuất: Cung cấp hiệu suất render tối ưu\n\n\n\n\nCOMMAND#\n\n * Loại: typeof COMMAND\n * Chỉ đọc: true\n\nLấy định nghĩa loại enum lệnh.\n\n\nmoduleConfig#\n\n * Loại: ParsedModuleConfig\n * Chỉ đọc: true\n * Ném ra: NotReadyError - Khi framework chưa được khởi tạo\n\nLấy thông tin cấu hình đầy đủ của module hiện tại, bao gồm các quy tắc phân giải\nmodule, cấu hình bí danh, v.v.\n\n\npackConfig#\n\n * Loại: ParsedPackConfig\n * Chỉ đọc: true\n * Ném ra: NotReadyError - Khi framework chưa được khởi tạo\n\nLấy cấu hình liên quan đến đóng gói của module hiện tại, bao gồm đường dẫn đầu\nra, xử lý package.json, v.v.\n\n\nPhương thức instance#\n\n\nconstructor()#\n\n * Tham số:\n   * options?: GezOptions - Tùy chọn cấu hình framework\n * Giá trị trả về: Gez\n\nTạo instance framework Gez.\n\n\n\n\ninit()#\n\n * Tham số: command: COMMAND\n * Giá trị trả về: Promise\n * Ném ra:\n   * Error: Khi khởi tạo lại\n   * NotReadyError: Khi truy cập instance chưa được khởi tạo\n\nKhởi tạo instance framework Gez. Thực hiện các quy trình khởi tạo cốt lõi sau:\n\n 1. Phân giải cấu hình dự án (package.json, cấu hình module, cấu hình đóng gói,\n    v.v.)\n 2. Tạo instance ứng dụng (môi trường phát triển hoặc sản xuất)\n 3. Thực thi các phương thức vòng đời tương ứng dựa trên lệnh\n\nLưu ý\n * Ném lỗi khi khởi tạo lại\n * Ném NotReadyError khi truy cập instance chưa được khởi tạo\n\n\n\n\ndestroy()#\n\n * Giá trị trả về: Promise\n\nHủy instance framework Gez, thực hiện các thao tác dọn dẹp tài nguyên và đóng\nkết nối. Chủ yếu dùng để:\n\n * Đóng máy chủ phát triển\n * Dọn dẹp các tệp tạm thời và bộ nhớ đệm\n * Giải phóng tài nguyên hệ thống\n\n\n\n\nbuild()#\n\n * Giá trị trả về: Promise\n\nThực thi quy trình build ứng dụng, bao gồm:\n\n * Biên dịch mã nguồn\n * Tạo ra các sản phẩm build cho môi trường sản xuất\n * Tối ưu hóa và nén mã\n * Tạo danh sách tài nguyên\n\nLưu ý\n\nNém NotReadyError khi gọi mà instance framework chưa được khởi tạo\n\n\n\n\nserver()#\n\n * Giá trị trả về: Promise\n * Ném ra: NotReadyError - Khi framework chưa được khởi tạo\n\nKhởi động máy chủ HTTP và cấu hình instance máy chủ. Được gọi trong các vòng đời\nsau:\n\n * Môi trường phát triển (dev): Khởi động máy chủ phát triển, cung cấp cập nhật\n   nóng\n * Môi trường sản xuất (start): Khởi động máy chủ sản xuất, cung cấp hiệu suất\n   cấp sản xuất\n\n\n\n\npostBuild()#\n\n * Giá trị trả về: Promise\n\nThực thi logic xử lý hậu build, dùng để:\n\n * Tạo các tệp HTML tĩnh\n * Xử lý các sản phẩm build\n * Thực hiện các tác vụ triển khai\n * Gửi thông báo build\n\n\n\n\nresolvePath#\n\nPhân giải đường dẫn dự án, chuyển đổi đường dẫn tương đối thành đường dẫn tuyệt\nđối.\n\n * Tham số:\n   \n   * projectPath: ProjectPath - Loại đường dẫn dự án\n   * ...args: string[] - Các đoạn đường dẫn\n\n * Giá trị trả về: string - Đường dẫn tuyệt đối đã phân giải\n\n * Ví dụ:\n\n\n\n\nwriteSync()#\n\nGhi đồng bộ nội dung tệp.\n\n * Tham số","routePath":"/vi/api/core/gez","lang":"vi","toc":[{"text":"Giới thiệu","id":"giới-thiệu","depth":2,"charIndex":3},{"text":"Định nghĩa kiểu","id":"định-nghĩa-kiểu","depth":2,"charIndex":185},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":204},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":470},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":539},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":674},{"text":"COMMAND","id":"command","depth":3,"charIndex":809},{"text":"Tùy chọn instance","id":"tùy-chọn-instance","depth":2,"charIndex":1147},{"text":"root","id":"root","depth":4,"charIndex":1230},{"text":"isProd","id":"isprod","depth":4,"charIndex":1432},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1595},{"text":"modules","id":"modules","depth":4,"charIndex":1848},{"text":"packs","id":"packs","depth":4,"charIndex":2019},{"text":"devApp","id":"devapp","depth":4,"charIndex":2157},{"text":"server","id":"server","depth":4,"charIndex":2341},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":2520},{"text":"Thuộc tính instance","id":"thuộc-tính-instance","depth":2,"charIndex":2762},{"text":"name","id":"name","depth":3,"charIndex":2785},{"text":"varName","id":"varname","depth":3,"charIndex":2878},{"text":"root","id":"root-1","depth":3,"charIndex":2981},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3171},{"text":"basePath","id":"basepath","depth":3,"charIndex":3391},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":3643},{"text":"middleware","id":"middleware","depth":3,"charIndex":3818},{"text":"render","id":"render","depth":3,"charIndex":4122},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":4423},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":4508},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":4743},{"text":"Phương thức instance","id":"phương-thức-instance","depth":2,"charIndex":4970},{"text":"constructor()","id":"constructor","depth":3,"charIndex":4994},{"text":"init()","id":"init","depth":3,"charIndex":5134},{"text":"destroy()","id":"destroy","depth":3,"charIndex":5698},{"text":"build()","id":"build","depth":3,"charIndex":5950},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":6811},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":7101}],"domain":"","frontmatter":{"titleSuffix":"Tài liệu tham khảo API lớp lõi framework","description":"Tài liệu chi tiết về API lớp lõi của framework Gez, bao gồm quản lý vòng đời ứng dụng, xử lý tài nguyên tĩnh và khả năng render phía máy chủ, giúp nhà phát triển hiểu sâu về các chức năng cốt lõi của framework.","head":[["meta",{"property":"keywords","content":"Gez, API, quản lý vòng đời, tài nguyên tĩnh, render phía máy chủ, Rspack, Web application framework"}]]},"version":""},{"id":279,"title":"ManifestJson","content":"#\n\nmanifest.json là tệp manifest được tạo ra trong quá trình build của khung Gez,\ndùng để ghi lại thông tin sản phẩm build của dịch vụ. Nó cung cấp một giao diện\nthống nhất để quản lý sản phẩm build, tệp xuất và thống kê kích thước tài\nnguyên.\n\n\n\n\nĐịnh nghĩa kiểu#\n\n\nManifestJson#\n\n\n\nname#\n\n * Kiểu: string\n\nTên dịch vụ, được lấy từ cấu hình GezOptions.name.\n\nexports#\n\n * Kiểu: Record\n\nÁnh xạ tệp xuất ra ngoài, key là đường dẫn tệp nguồn, value là đường dẫn tệp sau\nkhi build.\n\nbuildFiles#\n\n * Kiểu: string[]\n\nDanh sách đầy đủ các tệp sản phẩm build, bao gồm tất cả các đường dẫn tệp được\ntạo ra.\n\nchunks#\n\n * Kiểu: Record\n\nMối quan hệ tương ứng giữa tệp nguồn và sản phẩm biên dịch, key là đường dẫn tệp\nnguồn, value là thông tin biên dịch.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Kiểu: string\n\nĐường dẫn tệp JS sau khi biên dịch tệp nguồn hiện tại.\n\ncss#\n\n * Kiểu: string[]\n\nDanh sách đường dẫn tệp CSS liên quan đến tệp nguồn hiện tại.\n\nresources#\n\n * Kiểu: string[]\n\nDanh sách đường dẫn tệp tài nguyên khác liên quan đến tệp nguồn hiện tại.\n\nsizes#\n\n * Kiểu: ManifestJsonChunkSizes\n\nThông tin thống kê kích thước sản phẩm build.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Kiểu: number\n\nKích thước tệp JS (byte).\n\ncss#\n\n * Kiểu: number\n\nKích thước tệp CSS (byte).\n\nresource#\n\n * Kiểu: number\n\nKích thước tệp tài nguyên (byte).","routePath":"/vi/api/core/manifest-json","lang":"vi","toc":[{"text":"Định nghĩa kiểu","id":"định-nghĩa-kiểu","depth":2,"charIndex":247},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":283},{"text":"exports","id":"exports","depth":4,"charIndex":359},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":479},{"text":"chunks","id":"chunks","depth":4,"charIndex":599},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":745},{"text":"js","id":"js","depth":4,"charIndex":768},{"text":"css","id":"css","depth":4,"charIndex":846},{"text":"resources","id":"resources","depth":4,"charIndex":934},{"text":"sizes","id":"sizes","depth":4,"charIndex":1040},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1129},{"text":"js","id":"js-1","depth":4,"charIndex":1156},{"text":"css","id":"css-1","depth":4,"charIndex":1205},{"text":"resource","id":"resource","depth":4,"charIndex":1256}],"domain":"","frontmatter":{"titleSuffix":"Tài liệu tham khảo tệp manifest của khung Gez","description":"Tài liệu chi tiết về cấu trúc tệp manifest (manifest.json) của khung Gez, bao gồm quản lý sản phẩm build, ánh xạ tệp xuất và thống kê tài nguyên, giúp nhà phát triển hiểu và sử dụng hệ thống build.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, Tệp manifest, Quản lý tài nguyên, Sản phẩm build, Ánh xạ tệp, API"}]]},"version":""},{"id":280,"title":"ModuleConfig","content":"#\n\nModuleConfig cung cấp chức năng cấu hình module cho framework Gez, dùng để định\nnghĩa các quy tắc nhập/xuất module, cấu hình bí danh và phụ thuộc bên ngoài.\n\n\nĐịnh nghĩa kiểu#\n\n\nPathType#\n\n * Định nghĩa kiểu:\n\n\n\nEnum loại đường dẫn module:\n\n * npm: Đại diện cho các phụ thuộc trong node_modules\n * root: Đại diện cho các file trong thư mục gốc của dự án\n\n\nModuleConfig#\n\n * Định nghĩa kiểu:\n\n\n\nGiao diện cấu hình module, dùng để định nghĩa cấu hình xuất, nhập và phụ thuộc\nbên ngoài của dịch vụ.\n\nexports#\n\nDanh sách cấu hình xuất, xuất các đơn vị mã cụ thể trong dịch vụ (như component,\nhàm tiện ích, v.v.) dưới dạng ESM.\n\nHỗ trợ hai loại:\n\n * root:*: Xuất file mã nguồn, ví dụ: 'root:src/components/button.vue'\n * npm:*: Xuất phụ thuộc bên thứ ba, ví dụ: 'npm:vue'\n\nimports#\n\nBản đồ cấu hình nhập, cấu hình các module từ xa cần nhập và đường dẫn cục bộ của\nchúng.\n\nCách cài đặt khác nhau, cấu hình cũng khác nhau:\n\n * Cài đặt mã nguồn (Workspace, Git): Cần trỏ đến thư mục dist\n * Cài đặt gói phần mềm (Link, máy chủ tĩnh, nguồn gương riêng, File): Trực tiếp\n   trỏ đến thư mục gói\n\nexternals#\n\nBản đồ phụ thuộc bên ngoài, cấu hình các phụ thuộc bên ngoài cần sử dụng, thường\nlà sử dụng phụ thuộc từ các module từ xa.\n\nVí dụ:\n\n\n\n\nParsedModuleConfig#\n\n * Định nghĩa kiểu:\n\n\n\nCấu hình module đã được phân tích, chuyển đổi cấu hình module gốc sang định dạng\nnội bộ chuẩn hóa:\n\nname#\n\nTên của dịch vụ hiện tại\n\n * Dùng để định danh module và tạo đường dẫn nhập\n\nroot#\n\nĐường dẫn thư mục gốc của dịch vụ hiện tại\n\n * Dùng để phân giải đường dẫn tương đối và lưu trữ sản phẩm build\n\nexports#\n\nDanh sách cấu hình xuất\n\n * name: Đường dẫn xuất gốc, ví dụ: 'npm:vue' hoặc 'root:src/components'\n * type: Loại đường dẫn (npm hoặc root)\n * importName: Tên nhập, định dạng: '${serviceName}/${type}/${path}'\n * exportName: Đường dẫn xuất, tương đối với thư mục gốc của dịch vụ\n * exportPath: Đường dẫn file thực tế\n * externalName: Tên phụ thuộc bên ngoài, dùng để định danh khi các dịch vụ khác\n   nhập module này\n\nimports#\n\nDanh sách cấu hình nhập\n\n * name: Tên của dịch vụ bên ngoài\n * localPath: Đường dẫn lưu trữ cục bộ, dùng để lưu trữ sản phẩm build của\n   module bên ngoài\n\nexternals#\n\nBản đồ phụ thuộc bên ngoài\n\n * Ánh xạ đường dẫn nhập module đến vị trí thực tế của module\n * match: Biểu thức chính quy dùng để khớp câu lệnh nhập\n * import: Đường dẫn thực tế của module","routePath":"/vi/api/core/module-config","lang":"vi","toc":[{"text":"Định nghĩa kiểu","id":"định-nghĩa-kiểu","depth":2,"charIndex":161},{"text":"PathType","id":"pathtype","depth":3,"charIndex":180},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":499},{"text":"imports","id":"imports","depth":4,"charIndex":770},{"text":"externals","id":"externals","depth":4,"charIndex":1087},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1234},{"text":"name","id":"name","depth":4,"charIndex":1378},{"text":"root","id":"root","depth":4,"charIndex":1462},{"text":"exports","id":"exports-1","depth":4,"charIndex":1581},{"text":"imports","id":"imports-1","depth":4,"charIndex":2006},{"text":"externals","id":"externals-1","depth":4,"charIndex":2172}],"domain":"","frontmatter":{"titleSuffix":"Tham chiếu API cấu hình module của framework Gez","description":"Tài liệu chi tiết về giao diện cấu hình ModuleConfig của framework Gez, bao gồm các quy tắc nhập/xuất module, cấu hình bí danh và quản lý phụ thuộc bên ngoài, giúp nhà phát triển hiểu sâu hơn về hệ thống module hóa của framework.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, cấu hình module, nhập/xuất module, phụ thuộc bên ngoài, cấu hình bí danh, quản lý phụ thuộc, framework ứng dụng web"}]]},"version":""},{"id":281,"title":"PackConfig","content":"#\n\nPackConfig là giao diện cấu hình đóng gói gói phần mềm, được sử dụng để đóng gói\ncác sản phẩm xây dựng của dịch vụ thành gói phần mềm định dạng .tgz tiêu chuẩn\ncủa npm.\n\n * Tiêu chuẩn hóa: Sử dụng định dạng đóng gói .tgz tiêu chuẩn của npm\n * Tính toàn vẹn: Bao gồm mã nguồn, khai báo kiểu và các tệp cấu hình cần thiết\n   khác của mô-đun\n * Tính tương thích: Hoàn toàn tương thích với hệ sinh thái npm, hỗ trợ quy\n   trình làm việc quản lý gói tiêu chuẩn\n\n\nĐịnh nghĩa kiểu#\n\n\n\n\nPackConfig#\n\nenable#\n\nCó kích hoạt chức năng đóng gói hay không. Khi được kích hoạt, các sản phẩm xây\ndựng sẽ được đóng gói thành gói phần mềm định dạng .tgz tiêu chuẩn của npm.\n\n * Kiểu: boolean\n * Giá trị mặc định: false\n\noutputs#\n\nChỉ định đường dẫn tệp gói phần mềm đầu ra. Hỗ trợ các cách cấu hình sau:\n\n * string: Một đường dẫn đầu ra duy nhất, ví dụ: 'dist/versions/my-app.tgz'\n * string[]: Nhiều đường dẫn đầu ra, dùng để tạo nhiều phiên bản cùng lúc\n * boolean: Khi là true, sử dụng đường dẫn mặc định\n   'dist/client/versions/latest.tgz'\n\npackageJson#\n\nHàm callback tùy chỉnh nội dung package.json. Được gọi trước khi đóng gói, dùng\nđể tùy chỉnh nội dung của package.json.\n\n * Tham số:\n   * gez: Gez - Thể hiện Gez\n   * pkg: any - Nội dung package.json gốc\n * Giá trị trả về: Promise - Nội dung package.json đã được sửa đổi\n\nCông dụng phổ biến:\n\n * Sửa đổi tên gói và số phiên bản\n * Thêm hoặc cập nhật các phụ thuộc\n * Thêm các trường tùy chỉnh\n * Cấu hình thông tin phát hành\n\nVí dụ:\n\n\n\nonBefore#\n\nHàm callback chuẩn bị trước khi đóng gói.\n\n * Tham số:\n   * gez: Gez - Thể hiện Gez\n   * pkg: Record - Nội dung package.json\n * Giá trị trả về: Promise\n\nCông dụng phổ biến:\n\n * Thêm các tệp bổ sung (README, LICENSE, v.v.)\n * Thực hiện kiểm tra hoặc xác minh xây dựng\n * Tạo tài liệu hoặc siêu dữ liệu\n * Dọn dẹp các tệp tạm thời\n\nVí dụ:\n\n\n\nonAfter#\n\nHàm callback xử lý sau khi đóng gói hoàn tất. Được gọi sau khi tệp .tgz được\ntạo, dùng để xử lý sản phẩm đóng gói.\n\n * Tham số:\n   * gez: Gez - Thể hiện Gez\n   * pkg: Record - Nội dung package.json\n   * file: Buffer - Nội dung tệp đã đóng gói\n * Giá trị trả về: Promise\n\nCông dụng phổ biến:\n\n * Phát hành lên kho lưu trữ npm (công khai hoặc riêng tư)\n * Tải lên máy chủ tài nguyên tĩnh\n * Quản lý phiên bản\n * Kích hoạt quy trình CI/CD\n\nVí dụ:\n\n\n\n\nVí dụ sử dụng#\n\n","routePath":"/vi/api/core/pack-config","lang":"vi","toc":[{"text":"Định nghĩa kiểu","id":"định-nghĩa-kiểu","depth":2,"charIndex":460},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":494},{"text":"outputs","id":"outputs","depth":4,"charIndex":705},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":1030},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1480},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1831},{"text":"Ví dụ sử dụng","id":"ví-dụ-sử-dụng","depth":2,"charIndex":2289}],"domain":"","frontmatter":{"titleSuffix":"Tham chiếu API cấu hình đóng gói của khung Gez","description":"Tài liệu chi tiết về giao diện cấu hình PackConfig của khung Gez, bao gồm quy tắc đóng gói gói phần mềm, cấu hình đầu ra và các hook vòng đời, giúp nhà phát triển thực hiện quy trình xây dựng tiêu chuẩn.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, đóng gói gói phần mềm, cấu hình xây dựng, hook vòng đời, cấu hình đóng gói, khung ứng dụng Web"}]]},"version":""},{"id":282,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/vi/api/core/render-context","lang":"vi","toc":[{"text":"Định nghĩa kiểu","id":"định-nghĩa-kiểu","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Tùy chọn thể hiện","id":"tùy-chọn-thể-hiện","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Thuộc tính thể hiện","id":"thuộc-tính-thể-hiện","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Phương thức thể hiện","id":"phương-thức-thể-hiện","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Tài liệu tham khảo API RenderContext của framework Gez","description":"Tài liệu chi tiết về lớp RenderContext cốt lõi của framework Gez, bao gồm các chức năng như điều khiển render, quản lý tài nguyên, đồng bộ trạng thái và điều khiển định tuyến, giúp nhà phát triển thực hiện render phía máy chủ hiệu quả.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, render phía máy chủ, render context, đồng bộ trạng thái, quản lý tài nguyên, framework ứng dụng web"}]]},"version":""},{"id":283,"title":"Từ chia sẻ component đến module hóa nguyên bản: Hành trình phát triển của framework micro frontend Gez","content":"Từ chia sẻ component đến module hóa nguyên bản: Hành trình phát triển của\nframework micro frontend Gez#\n\n\nBối cảnh dự án#\n\nTrong những năm qua, kiến trúc micro frontend luôn tìm kiếm một con đường đúng\nđắn. Tuy nhiên, chúng ta thấy rằng các giải pháp kỹ thuật phức tạp đã sử dụng\nnhiều lớp bao bọc và cách ly thủ công để mô phỏng một thế giới micro frontend lý\ntưởng. Những giải pháp này mang lại gánh nặng hiệu suất lớn, khiến việc phát\ntriển đơn giản trở nên phức tạp và làm cho quy trình tiêu chuẩn trở nên khó\nhiểu.\n\n\nHạn chế của các giải pháp truyền thống#\n\nTrong quá trình thực hiện kiến trúc micro frontend, chúng tôi nhận thấy nhiều\nhạn chế của các giải pháp truyền thống:\n\n * Tổn thất hiệu suất: Tiêm phụ thuộc tại thời điểm chạy, proxy sandbox JS, mỗi\n   thao tác đều tiêu tốn hiệu suất quý giá\n * Cách ly mong manh: Môi trường sandbox được tạo thủ công không bao giờ đạt\n   được khả năng cách ly nguyên bản của trình duyệt\n * Độ phức tạp của quá trình xây dựng: Để xử lý các mối quan hệ phụ thuộc, buộc\n   phải sửa đổi công cụ xây dựng, khiến các dự án đơn giản trở nên khó bảo trì\n * Quy tắc tùy chỉnh: Chiến lược triển khai đặc biệt, xử lý tại thời điểm chạy,\n   khiến mỗi bước đều lệch khỏi quy trình phát triển hiện đại tiêu chuẩn\n * Hạn chế hệ sinh thái: Liên kết framework, API tùy chỉnh, khiến việc lựa chọn\n   công nghệ bị ràng buộc vào một hệ sinh thái cụ thể\n\nNhững vấn đề này đặc biệt nổi bật trong một dự án cấp doanh nghiệp của chúng tôi\nvào năm 2019. Khi đó, một sản phẩm lớn được chia thành hơn mười hệ thống con\nnghiệp vụ độc lập, các hệ thống con này cần chia sẻ một bộ component cơ sở và\ncomponent nghiệp vụ. Giải pháp chia sẻ component dựa trên npm ban đầu đã bộc lộ\nvấn đề nghiêm trọng về hiệu quả bảo trì: khi component chia sẻ được cập nhật,\ntất cả các hệ thống con phụ thuộc vào component đó đều phải trải qua quy trình\nxây dựng và triển khai đầy đủ.\n\n\nTiến hóa công nghệ#\n\n\nv1.0: Khám phá component từ xa#\n\nĐể giải quyết vấn đề hiệu quả chia sẻ component, Gez v1.0 đã giới thiệu cơ chế\nRemoteView component dựa trên giao thức HTTP. Giải pháp này thực hiện lắp ráp mã\ntheo yêu cầu giữa các dịch vụ thông qua yêu cầu động tại thời điểm chạy, giải\nquyết thành công vấn đề chuỗi phụ thuộc xây dựng quá dài. Tuy nhiên, do thiếu cơ\nchế giao tiếp tiêu chuẩn tại thời điểm chạy, việc đồng bộ trạng thái và truyền\nsự kiện giữa các dịch vụ vẫn gặp phải vấn đề về hiệu suất.\n\n\nv2.0: Thử nghiệm Module Federation#\n\nTrong phiên bản v2.0, chúng tôi đã sử dụng công nghệ Module Federation của\nWebpack 5.0. Công nghệ này thông qua cơ chế tải module thống nhất và container\ntại thời điểm chạy, đã cải thiện đáng kể hiệu quả phối hợp giữa các dịch vụ. Tuy\nnhiên, trong thực tiễn quy mô lớn, cơ chế triển khai đóng của Module Federation\nđã mang lại thách thức mới: khó thực hiện quản lý phiên bản phụ thuộc chính xác,\nđặc biệt khi thống nhất các phụ thuộc chia sẻ của nhiều dịch vụ, thường gặp phải\nxung đột phiên bản và ngoại lệ tại thời điểm chạy.\n\n\nĐón nhận kỷ nguyên mới của ESM#\n\nKhi lên kế hoạch cho phiên bản v3.0, chúng tôi đã quan sát sâu sắc xu hướng phát\ntriển của hệ sinh thái frontend và nhận thấy rằng sự tiến bộ của khả năng nguyên\nbản trình duyệt đã mang lại khả năng mới cho kiến trúc micro frontend:\n\n\nHệ thống module tiêu chuẩn#\n\nVới sự hỗ trợ toàn diện của các trình duyệt chính cho ES Modules và sự trưởng\nthành của tiêu chuẩn Import Maps, phát triển frontend đã bước vào kỷ nguyên\nmodule hóa thực sự. Theo thống kê của Can I Use, hiện tại tỷ lệ hỗ trợ nguyên\nbản ESM của các trình duyệt chính (Chrome >= 89, Edge >= 89, Firefox >= 108,\nSafari >= 16.4) đã đạt 93.5%, mang lại cho chúng tôi những lợi thế sau:\n\n * Quản lý phụ thuộc tiêu chuẩn: Import Maps cung cấp khả năng phân giải phụ\n   thuộc module ở cấp trình duyệt, không cần tiêm phức tạp tại thời điểm chạy\n * Tối ưu hóa tải tài nguyên: Cơ chế cache module nguyên bản của trình duyệt cải\n   thiện đáng kể hiệu quả tải tài nguyên\n * Đơn giản hóa quy trình xây dựng: Mô hình phát triển dựa trên ESM giúp quy\n   trình xây dựng môi trường phát triển và sản xuất trở nên nhất quán hơn\n\nĐồng thời, thông qua hỗ trợ chế độ tương thích (Chrome >= 87, Edge >= 88,\nFirefox >= 78, Safari >= 14), chúng tôi có thể nâng cao tỷ lệ phủ sóng trình\nduyệt lên 96.81%, cho phép chúng tôi duy trì hiệu suất cao mà không hy sinh hỗ\ntrợ cho các trình duyệt cũ.\n\n\nĐột phá về hiệu suất và cách ly#\n\nHệ thống module nguyên bản mang lại không chỉ sự tiêu chuẩn hóa mà còn là sự cải\nthiện đáng kể về hiệu suất và khả năng cách ly:\n\n * Không chi phí tại thời điểm chạy: Loại bỏ proxy sandbox JavaScript và tiêm\n   tại thời điểm chạy trong các giải pháp micro frontend truyền thống\n * Cơ chế cách ly đáng tin cậy: Phạm vi module nghiêm ngặt của ESM cung cấp khả\n   năng cách ly đáng tin cậy nhất\n * Quản lý phụ thuộc chính xác: Phân tích nhập tĩnh giúp mối quan hệ phụ thuộc\n   rõ ràng hơn, kiểm soát phiên bản chính xác hơn\n\n\nLựa chọn công cụ xây dựng#\n\nTrong quá trình triển khai giải pháp kỹ thuật, việc lựa chọn công cụ xây dựng là\nmột quyết định quan trọng. Sau gần một năm nghiên cứu và thực tiễn kỹ thuật, lựa\nchọn của chúng tôi đã trải qua các giai đoạn phát triển sau:\n\n 1. Khám phá Vite\n    \n    * Ưu điểm: Máy chủ phát triển dựa trên ESM, mang lại trải nghiệm phát triển\n      tối ưu\n    * Thách thức: Sự khác biệt giữa môi trường phát triển và xây dựng sản xuất\n      mang lại một số bất ổn\n\n 2. Xác lập Rspack\n    \n    * Ưu điểm hiệu suất: Biên dịch hiệu suất cao dựa trên Rust, cải thiện đáng\n      kể tốc độ xây dựng\n    * Hỗ trợ hệ sinh thái: Tương thích cao với hệ sinh thái Webpack, giảm chi\n      phí di chuyển\n    * Hỗ trợ ESM: Thông qua thực tiễn dự án Rslib, xác nhận độ tin cậy trong xây\n      dựng ESM\n\nQuyết định này giúp chúng tôi duy trì trải nghiệm phát triển đồng thời đạt được\nhỗ trợ môi trường sản xuất ổn định hơn. Dựa trên sự kết hợp ESM và Rspack, chúng\ntôi cuối cùng đã xây dựng một giải pháp micro frontend hiệu suất cao, ít xâm\nnhập.\n\n\nTriển vọng tương lai#\n\nTrong kế hoạch phát triển tương lai, framework Gez sẽ tập trung vào ba hướng\nchính:\n\n\nTối ưu hóa sâu Import Maps#\n\n * Quản lý phụ thuộc động: Thực hiện điều phối phiên bản phụ thuộc thông minh\n   tại thời điểm chạy, giải quyết xung đột phụ thuộc giữa nhiều ứng dụng\n * Chiến lược tải trước: Tải trước thông minh dựa trên phân tích tuyến đường,\n   cải thiện hiệu quả tải tài nguyên\n * Tối ưu hóa xây dựng: Tự động tạo cấu hình Import Maps tối ưu, giảm chi phí\n   cấu hình thủ công của nhà phát triển\n\n\nGiải pháp định tuyến độc lập framework#\n\n * Trừu tượng hóa định tuyến thống nhất: Thiết kế giao diện định tuyến độc lập\n   framework, hỗ trợ các framework chính như Vue, React\n * Định tuyến micro app: Thực hiện liên kết định tuyến giữa các ứng dụng, duy\n   trì sự nhất quán giữa URL và trạng thái ứng dụng\n * Middleware định tuyến: Cung cấp cơ chế middleware mở rộng, hỗ trợ kiểm soát\n   quyền, chuyển trang, v.v.\n\n\nThực tiễn tốt nhất về giao tiếp đa framework#\n\n * Ứng dụng mẫu: Cung cấp ví dụ đầy đủ về giao tiếp đa framework, bao gồm các\n   framework chính như Vue, React, Preact\n * Đồng bộ trạng thái: Giải pháp chia sẻ trạng thái nhẹ dựa trên ESM\n * Bus sự kiện: Cơ chế giao tiếp sự kiện tiêu chuẩn, hỗ trợ giao tiếp tách rời\n   giữa các ứng dụng\n\nThông qua các tối ưu hóa và mở rộng này, chúng tôi mong muốn biến Gez thành một\ngiải pháp micro frontend hoàn thiện hơn, dễ sử dụng hơn, mang lại trải nghiệm\nphát triển tốt hơn và hiệu quả phát triển cao hơn cho các nhà phát triển.","routePath":"/vi/blog/birth-of-gez","lang":"vi","toc":[{"text":"Bối cảnh dự án","id":"bối-cảnh-dự-án","depth":2,"charIndex":105},{"text":"Hạn chế của các giải pháp truyền thống","id":"hạn-chế-của-các-giải-pháp-truyền-thống","depth":3,"charIndex":521},{"text":"Tiến hóa công nghệ","id":"tiến-hóa-công-nghệ","depth":2,"charIndex":1886},{"text":"v1.0: Khám phá component từ xa","id":"v10-khám-phá-component-từ-xa","depth":3,"charIndex":1908},{"text":"v2.0: Thử nghiệm Module Federation","id":"v20-thử-nghiệm-module-federation","depth":3,"charIndex":2400},{"text":"Đón nhận kỷ nguyên mới của ESM","id":"đón-nhận-kỷ-nguyên-mới-của-esm","depth":2,"charIndex":2967},{"text":"Hệ thống module tiêu chuẩn","id":"hệ-thống-module-tiêu-chuẩn","depth":3,"charIndex":3235},{"text":"Đột phá về hiệu suất và cách ly","id":"đột-phá-về-hiệu-suất-và-cách-ly","depth":3,"charIndex":4335},{"text":"Lựa chọn công cụ xây dựng","id":"lựa-chọn-công-cụ-xây-dựng","depth":3,"charIndex":4892},{"text":"Triển vọng tương lai","id":"triển-vọng-tương-lai","depth":2,"charIndex":5938},{"text":"Tối ưu hóa sâu Import Maps","id":"tối-ưu-hóa-sâu-import-maps","depth":3,"charIndex":6047},{"text":"Giải pháp định tuyến độc lập framework","id":"giải-pháp-định-tuyến-độc-lập-framework","depth":3,"charIndex":6462},{"text":"Thực tiễn tốt nhất về giao tiếp đa framework","id":"thực-tiễn-tốt-nhất-về-giao-tiếp-đa-framework","depth":3,"charIndex":6878}],"domain":"","frontmatter":{"titleSuffix":"Từ khó khăn của micro frontend đến đổi mới ESM: Hành trình phát triển của framework Gez","description":"Khám phá sâu về hành trình phát triển của framework Gez từ những khó khăn của kiến trúc micro frontend truyền thống đến đột phá đổi mới dựa trên ESM, chia sẻ kinh nghiệm thực tiễn về tối ưu hiệu suất, quản lý phụ thuộc và lựa chọn công cụ xây dựng.","head":[["meta",{"property":"keywords","content":"Gez, framework micro frontend, ESM, Import Maps, Rspack, Module Federation, quản lý phụ thuộc, tối ưu hiệu suất, tiến hóa công nghệ, server-side rendering"}]],"sidebar":false},"version":""},{"id":284,"title":"Blog của nhóm","content":"#\n\nChào mừng bạn đến với blog công nghệ của nhóm Gez! Tại đây, chúng tôi sẽ chia sẻ\nkinh nghiệm trong quá trình phát triển framework, các đổi mới công nghệ và\nphương pháp tốt nhất.\n\n\nBài viết mới nhất#\n\n * 2025-02-25 Từ chia sẻ component đến module hóa gốc: Hành trình phát triển của\n   framework Gez\n   \n   > Khám phá hành trình phát triển của framework Gez từ chia sẻ component\n   > truyền thống đến module hóa gốc dựa trên ESM, chia sẻ kinh nghiệm thực tiễn\n   > về tối ưu hiệu suất, quản lý phụ thuộc và lựa chọn công cụ xây dựng.","routePath":"/vi/blog/","lang":"vi","toc":[{"text":"Bài viết mới nhất","id":"bài-viết-mới-nhất","depth":2,"charIndex":182}],"domain":"","frontmatter":{"titleSuffix":"Blog của nhóm Gez","description":"Blog công nghệ của nhóm Gez, chia sẻ kinh nghiệm phát triển framework, các phương pháp tốt nhất và đổi mới công nghệ.","head":[["meta",{"property":"keywords","content":"Gez, blog nhóm, chia sẻ công nghệ, phương pháp tốt nhất, kinh nghiệm phát triển"}]],"sidebar":false},"version":""},{"id":285,"title":"Bí danh đường dẫn","content":"#\n\nBí danh đường dẫn (Path Alias) là một cơ chế ánh xạ đường dẫn nhập module, cho\nphép nhà phát triển sử dụng các định danh ngắn gọn và có ý nghĩa để thay thế cho\nđường dẫn module đầy đủ. Trong Gez, cơ chế bí danh đường dẫn có các ưu điểm sau:\n\n * Đơn giản hóa đường dẫn nhập: Sử dụng bí danh có ý nghĩa thay thế cho đường\n   dẫn tương đối dài, cải thiện khả năng đọc mã\n * Tránh lồng ghép sâu: Loại bỏ khó khăn bảo trì do tham chiếu thư mục nhiều cấp\n   (ví dụ: ../../../../)\n * An toàn kiểu: Tích hợp hoàn toàn với hệ thống kiểu của TypeScript, cung cấp\n   bổ sung mã và kiểm tra kiểu\n * Tối ưu hóa phân giải module: Cải thiện hiệu suất phân giải module thông qua\n   ánh xạ đường dẫn được định nghĩa trước\n\n\nCơ chế bí danh mặc định#\n\nGez sử dụng cơ chế bí danh tự động dựa trên tên dịch vụ (Service Name), thiết kế\ntheo quy ước ưu tiên hơn cấu hình này có các đặc điểm sau:\n\n * Cấu hình tự động: Tự động tạo bí danh dựa trên trường name trong\n   package.json, không cần cấu hình thủ công\n * Quy chuẩn thống nhất: Đảm bảo tất cả các module dịch vụ tuân theo quy tắc đặt\n   tên và tham chiếu nhất quán\n * Hỗ trợ kiểu: Kết hợp với lệnh npm run build:dts, tự động tạo tệp khai báo\n   kiểu, thực hiện suy luận kiểu giữa các dịch vụ\n * Khả năng dự đoán: Có thể suy ra đường dẫn tham chiếu module thông qua tên\n   dịch vụ, giảm chi phí bảo trì\n\n\nHướng dẫn cấu hình#\n\n\nCấu hình package.json#\n\nTrong package.json, sử dụng trường name để định nghĩa tên dịch vụ, tên này sẽ\nđược sử dụng làm tiền tố bí danh mặc định của dịch vụ:\n\n\n\n\nCấu hình tsconfig.json#\n\nĐể TypeScript có thể phân giải chính xác đường dẫn bí danh, cần cấu hình ánh xạ\npaths trong tsconfig.json:\n\n\n\n\nVí dụ sử dụng#\n\n\nNhập module nội bộ dịch vụ#\n\n\n\n\nNhập module từ dịch vụ khác#\n\n\n\nThực hành tốt nhất\n * Ưu tiên sử dụng đường dẫn bí danh thay vì đường dẫn tương đối\n * Duy trì tính ngữ nghĩa và nhất quán của đường dẫn bí danh\n * Tránh sử dụng quá nhiều cấp thư mục trong đường dẫn bí danh\n\n\n\n\nNhập liên dịch vụ#\n\nKhi đã cấu hình liên kết module (Module Link), có thể sử dụng cách tương tự để\nnhập module từ dịch vụ khác:\n\n\n\n\nBí danh tùy chỉnh#\n\nĐối với các gói bên thứ ba hoặc các tình huống đặc biệt, có thể tùy chỉnh bí\ndanh thông qua tệp cấu hình Gez:\n\n\n\nLưu ý\n 1. Đối với các module nghiệp vụ, nên luôn sử dụng cơ chế bí danh mặc định để\n    duy trì tính nhất quán của dự án\n 2. Bí danh tùy chỉnh chủ yếu được sử dụng để xử lý các yêu cầu đặc biệt của gói\n    bên thứ ba hoặc tối ưu hóa trải nghiệm phát triển\n 3. Sử dụng quá nhiều bí danh tùy chỉnh có thể ảnh hưởng đến khả năng bảo trì mã\n    và tối ưu hóa build","routePath":"/vi/guide/essentials/alias","lang":"vi","toc":[{"text":"Cơ chế bí danh mặc định","id":"cơ-chế-bí-danh-mặc-định","depth":2,"charIndex":709},{"text":"Hướng dẫn cấu hình","id":"hướng-dẫn-cấu-hình","depth":2,"charIndex":1340},{"text":"Cấu hình package.json","id":"cấu-hình-packagejson","depth":3,"charIndex":1362},{"text":"Cấu hình tsconfig.json","id":"cấu-hình-tsconfigjson","depth":3,"charIndex":1523},{"text":"Ví dụ sử dụng","id":"ví-dụ-sử-dụng","depth":2,"charIndex":1659},{"text":"Nhập module nội bộ dịch vụ","id":"nhập-module-nội-bộ-dịch-vụ","depth":3,"charIndex":1676},{"text":"Nhập module từ dịch vụ khác","id":"nhập-module-từ-dịch-vụ-khác","depth":3,"charIndex":1708},{"text":"Nhập liên dịch vụ","id":"nhập-liên-dịch-vụ","depth":3,"charIndex":1952},{"text":"Bí danh tùy chỉnh","id":"bí-danh-tùy-chỉnh","depth":3,"charIndex":2084}],"domain":"","frontmatter":{"titleSuffix":"Hướng dẫn ánh xạ đường dẫn nhập module trong Gez","description":"Hướng dẫn chi tiết về cơ chế bí danh đường dẫn trong Gez, bao gồm các tính năng như đơn giản hóa đường dẫn nhập, tránh lồng ghép sâu, an toàn kiểu và tối ưu hóa phân giải module, giúp nhà phát triển nâng cao khả năng bảo trì mã.","head":[["meta",{"property":"keywords","content":"Gez, Bí danh đường dẫn, Path Alias, TypeScript, Nhập module, Ánh xạ đường dẫn, Bảo trì mã"}]]},"version":""},{"id":286,"title":"Đường dẫn cơ bản","content":"#\n\nĐường dẫn cơ bản (Base Path) là tiền tố đường dẫn truy cập cho các tài nguyên\ntĩnh (như JavaScript, CSS, hình ảnh, v.v.) trong ứng dụng. Trong Gez, việc cấu\nhình đường dẫn cơ bản một cách hợp lý là rất quan trọng cho các tình huống sau:\n\n * Triển khai đa môi trường: Hỗ trợ truy cập tài nguyên trong các môi trường\n   khác nhau như môi trường phát triển, môi trường kiểm thử, môi trường sản xuất\n * Triển khai đa khu vực: Đáp ứng nhu cầu triển khai cụm ở các khu vực hoặc quốc\n   gia khác nhau\n * Phân phối CDN: Thực hiện phân phối và tăng tốc tài nguyên tĩnh trên toàn cầu\n\n\nCơ chế đường dẫn mặc định#\n\nGez sử dụng cơ chế tự động tạo đường dẫn dựa trên tên dịch vụ. Theo mặc định,\nframework sẽ đọc trường name trong package.json của dự án để tạo đường dẫn cơ\nbản cho tài nguyên tĩnh: /your-app-name/.\n\n\n\nThiết kế này ưu tiên quy ước hơn cấu hình có các ưu điểm sau:\n\n * Tính nhất quán: Đảm bảo tất cả các tài nguyên tĩnh sử dụng cùng một đường dẫn\n   truy cập\n * Tính dự đoán được: Có thể suy ra đường dẫn truy cập tài nguyên thông qua\n   trường name trong package.json\n * Tính bảo trì: Không cần cấu hình thêm, giảm chi phí bảo trì\n\n\nCấu hình đường dẫn động#\n\nTrong các dự án thực tế, chúng ta thường cần triển khai cùng một bộ mã lên các\nmôi trường hoặc khu vực khác nhau. Gez cung cấp hỗ trợ cho đường dẫn cơ bản\nđộng, giúp ứng dụng có thể thích ứng với các tình huống triển khai khác nhau.\n\n\nCác tình huống sử dụng#\n\nTriển khai thư mục cấp hai#\n\n\n\nTriển khai tên miền độc lập#\n\n\n\n\nPhương pháp cấu hình#\n\nThông qua tham số base của phương thức gez.render(), bạn có thể thiết lập đường\ndẫn cơ bản một cách động dựa trên ngữ cảnh yêu cầu:\n\n","routePath":"/vi/guide/essentials/base-path","lang":"vi","toc":[{"text":"Cơ chế đường dẫn mặc định","id":"cơ-chế-đường-dẫn-mặc-định","depth":2,"charIndex":578},{"text":"Cấu hình đường dẫn động","id":"cấu-hình-đường-dẫn-động","depth":2,"charIndex":1138},{"text":"Các tình huống sử dụng","id":"các-tình-huống-sử-dụng","depth":3,"charIndex":1399},{"text":"Triển khai thư mục cấp hai","id":"triển-khai-thư-mục-cấp-hai","depth":4,"charIndex":1424},{"text":"Triển khai tên miền độc lập","id":"triển-khai-tên-miền-độc-lập","depth":4,"charIndex":1455},{"text":"Phương pháp cấu hình","id":"phương-pháp-cấu-hình","depth":3,"charIndex":1488}],"domain":"","frontmatter":{"titleSuffix":"Hướng dẫn cấu hình đường dẫn tài nguyên tĩnh trong Gez Framework","description":"Hướng dẫn chi tiết về cấu hình đường dẫn cơ bản trong Gez Framework, bao gồm triển khai đa môi trường, phân phối CDN và thiết lập đường dẫn truy cập tài nguyên, giúp nhà phát triển quản lý tài nguyên tĩnh một cách linh hoạt.","head":[["meta",{"property":"keywords","content":"Gez, Đường dẫn cơ bản, Base Path, CDN, Tài nguyên tĩnh, Triển khai đa môi trường, Quản lý tài nguyên"}]]},"version":""},{"id":287,"title":"Client-Side Rendering","content":"\n${rc.importmap()} // Import map ${rc.moduleEntry()} // Module entry\n${rc.modulePreload()} // Preload module","routePath":"/vi/guide/essentials/csr","lang":"vi","toc":[{"text":"Các trường hợp sử dụng","id":"các-trường-hợp-sử-dụng","depth":2,"charIndex":-1},{"text":"Hướng dẫn cấu hình","id":"hướng-dẫn-cấu-hình","depth":2,"charIndex":-1},{"text":"Cấu hình template HTML","id":"cấu-hình-template-html","depth":3,"charIndex":-1},{"text":"Tạo HTML tĩnh","id":"tạo-html-tĩnh","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Hướng dẫn triển khai Client-Side Rendering với Gez Framework","description":"Hướng dẫn chi tiết cơ chế Client-Side Rendering của Gez Framework, bao gồm xây dựng tĩnh, chiến lược triển khai và các thực hành tốt nhất, giúp nhà phát triển thực hiện render phía client hiệu quả trong môi trường không có server.","head":[["meta",{"property":"keywords","content":"Gez, Client-Side Rendering, CSR, Xây dựng tĩnh, Render phía client, Triển khai không server, Tối ưu hiệu suất"}]]},"version":""},{"id":288,"title":"Liên kết module","content":"#\n\nGez Framework cung cấp một cơ chế liên kết module hoàn chỉnh để quản lý việc\nchia sẻ mã và các mối quan hệ phụ thuộc giữa các dịch vụ. Cơ chế này được triển\nkhai dựa trên tiêu chuẩn ESM (ECMAScript Module), hỗ trợ xuất và nhập module ở\ncấp độ mã nguồn, cùng với các chức năng quản lý phụ thuộc đầy đủ.\n\n\nKhái niệm cốt lõi#\n\nXuất module#\n\nXuất module là quá trình đưa các đơn vị mã cụ thể trong dịch vụ (như component,\nhàm tiện ích, v.v.) ra ngoài dưới định dạng ESM. Hỗ trợ hai loại xuất:\n\n * Xuất mã nguồn: Xuất trực tiếp các tệp mã nguồn trong dự án\n * Xuất phụ thuộc: Xuất các gói phụ thuộc bên thứ ba mà dự án sử dụng\n\nNhập module#\n\nNhập module là quá trình tham chiếu các đơn vị mã được xuất từ các dịch vụ khác\ntrong một dịch vụ. Hỗ trợ nhiều cách cài đặt:\n\n * Cài đặt mã nguồn: Phù hợp cho môi trường phát triển, hỗ trợ sửa đổi thời gian\n   thực và cập nhật nóng\n * Cài đặt gói phần mềm: Phù hợp cho môi trường sản xuất, sử dụng trực tiếp sản\n   phẩm đã được build\n\n\nCơ chế tải trước#\n\nĐể tối ưu hóa hiệu suất dịch vụ, Gez đã triển khai cơ chế tải trước module thông\nminh:\n\n 1. Phân tích phụ thuộc\n    \n    * Phân tích các mối quan hệ phụ thuộc giữa các component trong quá trình\n      build\n    * Xác định các module cốt lõi trên đường dẫn quan trọng\n    * Xác định mức độ ưu tiên tải của các module\n\n 2. Chiến lược tải\n    \n    * Tải ngay lập tức: Các module cốt lõi trên đường dẫn quan trọng\n    * Tải trễ: Các module chức năng không quan trọng\n    * Tải theo yêu cầu: Các module được render có điều kiện\n\n 3. Tối ưu hóa tài nguyên\n    \n    * Chiến lược phân chia mã thông minh\n    * Quản lý bộ nhớ đệm ở cấp độ module\n    * Biên dịch và đóng gói theo yêu cầu\n\n\nXuất module#\n\n\nCấu hình#\n\nCấu hình các module cần xuất trong entry.node.ts:\n\n\n\nCấu hình xuất hỗ trợ hai loại:\n\n * root:*: Xuất tệp mã nguồn, đường dẫn tương đối so với thư mục gốc của dự án\n * npm:*: Xuất phụ thuộc bên thứ ba, chỉ định trực tiếp tên gói\n\n\nNhập module#\n\n\nCấu hình#\n\nCấu hình các module cần nhập trong entry.node.ts:\n\n\n\nGiải thích cấu hình:\n\n 1. imports: Cấu hình đường dẫn cục bộ của module từ xa\n    \n    * Cài đặt mã nguồn: Trỏ đến thư mục sản phẩm build (dist)\n    * Cài đặt gói phần mềm: Trỏ trực tiếp đến thư mục gói\n\n 2. externals: Cấu hình phụ thuộc bên ngoài\n    \n    * Dùng để chia sẻ phụ thuộc từ module từ xa\n    * Tránh đóng gói trùng lặp các phụ thuộc giống nhau\n    * Hỗ trợ chia sẻ phụ thuộc giữa nhiều module\n\n\nCách cài đặt#\n\nCài đặt mã nguồn#\n\nPhù hợp cho môi trường phát triển, hỗ trợ sửa đổi thời gian thực và cập nhật\nnóng.\n\n 1. Cách Workspace Khuyến nghị sử dụng trong dự án Monorepo:\n\n\n\n 2. Cách Link Dùng để debug phát triển cục bộ:\n\n\n\nCài đặt gói phần mềm#\n\nPhù hợp cho môi trường sản xuất, sử dụng trực tiếp sản phẩm đã được build.\n\n 1. NPM Registry Cài đặt qua npm registry:\n\n\n\n 2. Máy chủ tĩnh Cài đặt qua giao thức HTTP/HTTPS:\n\n\n\n\nĐóng gói phần mềm#\n\n\nCấu hình#\n\nCấu hình các tùy chọn build trong entry.node.ts:\n\n\n\n\nSản phẩm build#\n\n\n\n\nQuy trình phát hành#\n\n\n\n\nThực tiễn tốt nhất#\n\n\nCấu hình môi trường phát triển#\n\n * Quản lý phụ thuộc\n   \n   * Sử dụng cách Workspace hoặc Link để cài đặt phụ thuộc\n   * Quản lý phiên bản phụ thuộc thống nhất\n   * Tránh cài đặt trùng lặp các phụ thuộc giống nhau\n\n * Trải nghiệm phát triển\n   \n   * Kích hoạt tính năng cập nhật nóng\n   * Cấu hình chiến lược tải trước phù hợp\n   * Tối ưu hóa tốc độ build\n\n\nCấu hình môi trường sản xuất#\n\n * Chiến lược triển khai\n   \n   * Sử dụng NPM Registry hoặc máy chủ tĩnh\n   * Đảm bảo tính toàn vẹn của sản phẩm build\n   * Áp dụng cơ chế phát hành thử nghiệm\n\n * Tối ưu hóa hiệu suất\n   \n   * Cấu hình tải trước tài nguyên hợp lý\n   * Tối ưu hóa thứ tự tải module\n   * Áp dụng chiến lược bộ nhớ đệm hiệu quả\n\n\nQuản lý phiên bản#\n\n * Quy tắc phiên bản\n   \n   * Tuân thủ quy tắc phiên bản ngữ nghĩa\n   * Duy trì nhật ký cập nhật chi tiết\n   * Kiểm tra tính tương thích phiên bản kỹ lưỡng\n\n * Cập nhật phụ thuộc\n   \n   * Cập nhật các gói phụ thuộc kịp thời\n   * Kiểm tra bảo mật định kỳ\n   * Duy trì tính nhất quán phiên bản phụ thuộc\n\n","routePath":"/vi/guide/essentials/module-link","lang":"vi","toc":[{"text":"Khái niệm cốt lõi","id":"khái-niệm-cốt-lõi","depth":3,"charIndex":306},{"text":"Xuất module","id":"xuất-module","depth":4,"charIndex":326},{"text":"Nhập module","id":"nhập-module","depth":4,"charIndex":625},{"text":"Cơ chế tải trước","id":"cơ-chế-tải-trước","depth":3,"charIndex":976},{"text":"Xuất module","id":"xuất-module-1","depth":2,"charIndex":1674},{"text":"Cấu hình","id":"cấu-hình","depth":3,"charIndex":1689},{"text":"Nhập module","id":"nhập-module-1","depth":2,"charIndex":1930},{"text":"Cấu hình","id":"cấu-hình-1","depth":3,"charIndex":1945},{"text":"Cách cài đặt","id":"cách-cài-đặt","depth":3,"charIndex":2417},{"text":"Cài đặt mã nguồn","id":"cài-đặt-mã-nguồn","depth":4,"charIndex":2432},{"text":"Cài đặt gói phần mềm","id":"cài-đặt-gói-phần-mềm","depth":4,"charIndex":2649},{"text":"Đóng gói phần mềm","id":"đóng-gói-phần-mềm","depth":2,"charIndex":2849},{"text":"Cấu hình","id":"cấu-hình-2","depth":3,"charIndex":2870},{"text":"Sản phẩm build","id":"sản-phẩm-build","depth":3,"charIndex":2934},{"text":"Quy trình phát hành","id":"quy-trình-phát-hành","depth":3,"charIndex":2954},{"text":"Thực tiễn tốt nhất","id":"thực-tiễn-tốt-nhất","depth":2,"charIndex":2979},{"text":"Cấu hình môi trường phát triển","id":"cấu-hình-môi-trường-phát-triển","depth":3,"charIndex":3001},{"text":"Cấu hình môi trường sản xuất","id":"cấu-hình-môi-trường-sản-xuất","depth":3,"charIndex":3360},{"text":"Quản lý phiên bản","id":"quản-lý-phiên-bản","depth":3,"charIndex":3702}],"domain":"","frontmatter":{"titleSuffix":"Cơ chế chia sẻ mã giữa các dịch vụ trong Gez Framework","description":"Giới thiệu chi tiết cơ chế liên kết module trong Gez Framework, bao gồm chia sẻ mã giữa các dịch vụ, quản lý phụ thuộc và triển khai tiêu chuẩn ESM, giúp nhà phát triển xây dựng ứng dụng micro frontend hiệu quả.","head":[["meta",{"property":"keywords","content":"Gez, Liên kết module, Module Link, ESM, Chia sẻ mã, Quản lý phụ thuộc, Micro frontend"}]]},"version":""},{"id":289,"title":"Ngữ cảnh Render (RenderContext)","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/vi/guide/essentials/render-context","lang":"vi","toc":[{"text":"Cách sử dụng","id":"cách-sử-dụng","depth":2,"charIndex":-1},{"text":"Chức năng chính","id":"chức-năng-chính","depth":2,"charIndex":-1},{"text":"Thu thập phụ thuộc","id":"thu-thập-phụ-thuộc","depth":3,"charIndex":-1},{"text":"Thu thập theo yêu cầu","id":"thu-thập-theo-yêu-cầu","depth":4,"charIndex":-1},{"text":"Xử lý tự động","id":"xử-lý-tự-động","depth":4,"charIndex":-1},{"text":"Tối ưu hiệu suất","id":"tối-ưu-hiệu-suất","depth":4,"charIndex":-1},{"text":"Chèn tài nguyên","id":"chèn-tài-nguyên","depth":3,"charIndex":-1},{"text":"Thứ tự chèn tài nguyên","id":"thứ-tự-chèn-tài-nguyên","depth":3,"charIndex":-1},{"text":"Quy trình render hoàn chỉnh","id":"quy-trình-render-hoàn-chỉnh","depth":2,"charIndex":-1},{"text":"Tính năng nâng cao","id":"tính-năng-nâng-cao","depth":2,"charIndex":-1},{"text":"Cấu hình đường dẫn cơ sở","id":"cấu-hình-đường-dẫn-cơ-sở","depth":3,"charIndex":-1},{"text":"Chế độ ánh xạ import","id":"chế-độ-ánh-xạ-import","depth":3,"charIndex":-1},{"text":"Cấu hình hàm entry","id":"cấu-hình-hàm-entry","depth":3,"charIndex":-1},{"text":"Thực hành tốt nhất","id":"thực-hành-tốt-nhất","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Cơ chế lõi render phía máy chủ của framework Gez","description":"Giới thiệu chi tiết cơ chế RenderContext (Ngữ cảnh Render) trong framework Gez, bao gồm quản lý tài nguyên, tạo HTML và hệ thống module ESM, giúp nhà phát triển hiểu và sử dụng tính năng render phía máy chủ.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, Render phía máy chủ, ESM, Quản lý tài nguyên"}]]},"version":""},{"id":290,"title":"Rspack","content":"#\n\nGez được xây dựng dựa trên hệ thống xây dựng Rspack, tận dụng tối đa khả năng\nxây dựng hiệu suất cao của Rspack. Tài liệu này sẽ giới thiệu vị trí và các chức\nnăng cốt lõi của Rspack trong Gez Framework.\n\n\nTính năng#\n\nRspack là hệ thống xây dựng cốt lõi của Gez Framework, cung cấp các tính năng\nchính sau:\n\n * Xây dựng hiệu suất cao: Động cơ xây dựng được triển khai bằng Rust, cung cấp\n   tốc độ biên dịch cực nhanh, cải thiện đáng kể tốc độ xây dựng cho các dự án\n   lớn\n * Tối ưu hóa trải nghiệm phát triển: Hỗ trợ các tính năng phát triển hiện đại\n   như cập nhật nóng (HMR), biên dịch tăng dần, mang lại trải nghiệm phát triển\n   mượt mà\n * Xây dựng đa môi trường: Cấu hình xây dựng thống nhất hỗ trợ môi trường\n   client, server và Node.js, đơn giản hóa quy trình phát triển đa nền tảng\n * Tối ưu hóa tài nguyên: Khả năng xử lý và tối ưu hóa tài nguyên tích hợp, hỗ\n   trợ các tính năng như phân chia mã, Tree Shaking, nén tài nguyên\n\n\nXây dựng ứng dụng#\n\nHệ thống xây dựng Rspack của Gez được thiết kế theo mô-đun, bao gồm các mô-đun\ncốt lõi sau:\n\n\n@gez/rspack#\n\nMô-đun xây dựng cơ bản, cung cấp các khả năng cốt lõi sau:\n\n * Quản lý cấu hình xây dựng thống nhất: Cung cấp quản lý cấu hình xây dựng tiêu\n   chuẩn, hỗ trợ cấu hình đa môi trường\n * Xử lý tài nguyên: Hỗ trợ tích hợp xử lý các tài nguyên như TypeScript, CSS,\n   hình ảnh\n * Tối ưu hóa xây dựng: Cung cấp các tính năng tối ưu hóa hiệu suất như phân\n   chia mã, Tree Shaking\n * Máy chủ phát triển: Tích hợp máy chủ phát triển hiệu suất cao, hỗ trợ HMR\n\n\n@gez/rspack-vue#\n\nMô-đun xây dựng chuyên dụng cho Vue Framework, cung cấp:\n\n * Biên dịch component Vue: Hỗ trợ biên dịch hiệu quả các component Vue 2/3\n * Tối ưu hóa SSR: Tối ưu hóa cụ thể cho các tình huống render phía server\n * Tăng cường phát triển: Các chức năng tăng cường cụ thể cho môi trường phát\n   triển Vue\n\n\nQuy trình xây dựng#\n\nQuy trình xây dựng của Gez chủ yếu bao gồm các giai đoạn sau:\n\n 1. Khởi tạo cấu hình\n    \n    * Tải cấu hình dự án\n    * Kết hợp cấu hình mặc định và cấu hình người dùng\n    * Điều chỉnh cấu hình dựa trên biến môi trường\n\n 2. Biên dịch tài nguyên\n    \n    * Phân tích các phụ thuộc mã nguồn\n    * Chuyển đổi các loại tài nguyên (TypeScript, CSS, v.v.)\n    * Xử lý nhập/xuất mô-đun\n\n 3. Xử lý tối ưu hóa\n    \n    * Thực hiện phân chia mã\n    * Áp dụng Tree Shaking\n    * Nén mã và tài nguyên\n\n 4. Tạo đầu ra\n    \n    * Tạo các tệp đích\n    * Xuất bản đồ tài nguyên\n    * Tạo báo cáo xây dựng\n\n\nThực tiễn tốt nhất#\n\n\nTối ưu hóa môi trường phát triển#\n\n * Cấu hình biên dịch tăng dần: Cấu hình hợp lý tùy chọn cache, sử dụng bộ nhớ\n   đệm để tăng tốc độ xây dựng\n * Tối ưu hóa HMR: Cấu hình phạm vi cập nhật nóng một cách có chọn lọc, tránh\n   cập nhật các mô-đun không cần thiết\n * Tối ưu hóa xử lý tài nguyên: Sử dụng cấu hình loader phù hợp, tránh xử lý\n   trùng lặp\n\n\nTối ưu hóa môi trường sản xuất#\n\n * Chiến lược phân chia mã: Cấu hình hợp lý splitChunks, tối ưu hóa tải tài\n   nguyên\n * Nén tài nguyên: Kích hoạt cấu hình nén phù hợp, cân bằng thời gian xây dựng\n   và kích thước sản phẩm\n * Tối ưu hóa bộ nhớ đệm: Sử dụng băm nội dung và chiến lược bộ nhớ đệm dài hạn,\n   cải thiện hiệu suất tải\n\n\nVí dụ cấu hình#\n\n\n\nTIP\n\nĐể biết thêm chi tiết về API và các tùy chọn cấu hình, vui lòng tham khảo Tài\nliệu API Rspack.","routePath":"/vi/guide/essentials/rspack","lang":"vi","toc":[{"text":"Tính năng","id":"tính-năng","depth":2,"charIndex":208},{"text":"Xây dựng ứng dụng","id":"xây-dựng-ứng-dụng","depth":2,"charIndex":945},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1059},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1526},{"text":"Quy trình xây dựng","id":"quy-trình-xây-dựng","depth":2,"charIndex":1846},{"text":"Thực tiễn tốt nhất","id":"thực-tiễn-tốt-nhất","depth":2,"charIndex":2460},{"text":"Tối ưu hóa môi trường phát triển","id":"tối-ưu-hóa-môi-trường-phát-triển","depth":3,"charIndex":2482},{"text":"Tối ưu hóa môi trường sản xuất","id":"tối-ưu-hóa-môi-trường-sản-xuất","depth":3,"charIndex":2836},{"text":"Ví dụ cấu hình","id":"ví-dụ-cấu-hình","depth":2,"charIndex":3170}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework - Công cụ xây dựng hiệu suất cao","description":"Phân tích sâu về hệ thống xây dựng Rspack trong Gez Framework, bao gồm các tính năng cốt lõi như biên dịch hiệu suất cao, xây dựng đa môi trường, tối ưu hóa tài nguyên, giúp nhà phát triển xây dựng các ứng dụng Web hiện đại hiệu quả và đáng tin cậy.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, hệ thống xây dựng, biên dịch hiệu suất cao, cập nhật nóng, xây dựng đa môi trường, Tree Shaking, phân chia mã, SSR, tối ưu hóa tài nguyên, hiệu quả phát triển, công cụ xây dựng"}]]},"version":""},{"id":291,"title":"Quy chuẩn Tiêu chuẩn","content":"#\n\nGez là một framework SSR hiện đại, sử dụng cấu trúc dự án tiêu chuẩn và cơ chế\nphân giải đường dẫn để đảm bảo tính nhất quán và khả năng bảo trì của dự án\ntrong cả môi trường phát triển và sản xuất.\n\n\nQuy chuẩn Cấu trúc Dự án#\n\n\nCấu trúc Thư mục Tiêu chuẩn#\n\n\n\nKiến thức Mở rộng\n * gez.name được lấy từ trường name trong package.json\n * dist/package.json được lấy từ package.json ở thư mục gốc\n * Chỉ khi đặt packs.enable thành true, thư mục dist mới được lưu trữ\n\n\nQuy chuẩn Tệp tin Đầu vào#\n\n\nentry.client.ts#\n\nTệp tin đầu vào phía máy khách chịu trách nhiệm:\n\n * Khởi tạo ứng dụng: Cấu hình các thiết lập cơ bản cho ứng dụng máy khách\n * Quản lý định tuyến: Xử lý định tuyến và điều hướng phía máy khách\n * Quản lý trạng thái: Thực hiện lưu trữ và cập nhật trạng thái máy khách\n * Xử lý tương tác: Quản lý sự kiện người dùng và tương tác giao diện\n\n\nentry.server.ts#\n\nTệp tin đầu vào phía máy chủ chịu trách nhiệm:\n\n * Kết xuất phía máy chủ: Thực hiện quy trình kết xuất SSR\n * Tạo HTML: Xây dựng cấu trúc trang ban đầu\n * Lấy dữ liệu trước: Xử lý việc lấy dữ liệu phía máy chủ\n * Tiêm trạng thái: Truyền trạng thái từ máy chủ sang máy khách\n * Tối ưu SEO: Đảm bảo tối ưu hóa công cụ tìm kiếm cho trang\n\n\nentry.node.ts#\n\nTệp tin đầu vào máy chủ Node.js chịu trách nhiệm:\n\n * Cấu hình máy chủ: Thiết lập các tham số máy chủ HTTP\n * Xử lý định tuyến: Quản lý các quy tắc định tuyến phía máy chủ\n * Tích hợp middleware: Cấu hình các middleware của máy chủ\n * Quản lý môi trường: Xử lý biến môi trường và cấu hình\n * Xử lý yêu cầu và phản hồi: Xử lý các yêu cầu và phản hồi HTTP\n\n\nQuy chuẩn Cấu hình#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/vi/guide/essentials/std","lang":"vi","toc":[{"text":"Quy chuẩn Cấu trúc Dự án","id":"quy-chuẩn-cấu-trúc-dự-án","depth":2,"charIndex":203},{"text":"Cấu trúc Thư mục Tiêu chuẩn","id":"cấu-trúc-thư-mục-tiêu-chuẩn","depth":3,"charIndex":231},{"text":"Quy chuẩn Tệp tin Đầu vào","id":"quy-chuẩn-tệp-tin-đầu-vào","depth":2,"charIndex":468},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":497},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":855},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1210},{"text":"Quy chuẩn Cấu hình","id":"quy-chuẩn-cấu-hình","depth":2,"charIndex":1582},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1604},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1622}],"domain":"","frontmatter":{"titleSuffix":"Hướng dẫn Cấu trúc và Quy chuẩn Dự án Gez Framework","description":"Hướng dẫn chi tiết về cấu trúc dự án tiêu chuẩn, quy chuẩn tệp tin đầu vào và cấu hình của Gez framework, giúp nhà phát triển xây dựng ứng dụng SSR chuẩn hóa và dễ bảo trì.","head":[["meta",{"property":"keywords","content":"Gez, Cấu trúc dự án, Tệp tin đầu vào, Quy chuẩn cấu hình, SSR framework, TypeScript, Quy chuẩn dự án, Tiêu chuẩn phát triển"}]]},"version":""},{"id":292,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/vi/guide/frameworks/html","lang":"vi","toc":[{"text":"Cấu trúc dự án","id":"cấu-trúc-dự-án","depth":2,"charIndex":-1},{"text":"Cấu hình dự án","id":"cấu-hình-dự-án","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Cấu trúc mã nguồn","id":"cấu-trúc-mã-nguồn","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Chạy dự án","id":"chạy-dự-án","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Ví dụ ứng dụng HTML SSR với Gez Framework","description":"Hướng dẫn xây dựng ứng dụng HTML SSR từ đầu dựa trên Gez, thông qua ví dụ minh họa cách sử dụng cơ bản của framework, bao gồm khởi tạo dự án, cấu hình HTML và thiết lập tệp đầu vào.","head":[["meta",{"property":"keywords","content":"Gez, HTML, Ứng dụng SSR, Cấu hình TypeScript, Khởi tạo dự án, Render phía máy chủ, Tương tác phía máy khách"}]]},"version":""},{"id":293,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/vi/guide/frameworks/preact-htm","lang":"vi","toc":[{"text":"Cấu trúc dự án","id":"cấu-trúc-dự-án","depth":2,"charIndex":-1},{"text":"Cấu hình dự án","id":"cấu-hình-dự-án","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Cấu trúc mã nguồn","id":"cấu-trúc-mã-nguồn","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Chạy dự án","id":"chạy-dự-án","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Ví dụ ứng dụng Preact+HTM SSR với Gez Framework","description":"Hướng dẫn xây dựng ứng dụng Preact+HTM SSR từ đầu với Gez, qua ví dụ minh họa cách sử dụng cơ bản của framework, bao gồm khởi tạo dự án, cấu hình Preact và thiết lập file entry.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, Ứng dụng SSR, Cấu hình TypeScript, Khởi tạo dự án, Render phía server, Tương tác phía client"}]]},"version":""},{"id":294,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/vi/guide/frameworks/vue2","lang":"vi","toc":[{"text":"Cấu trúc dự án","id":"cấu-trúc-dự-án","depth":2,"charIndex":-1},{"text":"Cấu hình dự án","id":"cấu-hình-dự-án","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Cấu trúc mã nguồn","id":"cấu-trúc-mã-nguồn","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Chạy dự án","id":"chạy-dự-án","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Ví dụ ứng dụng Vue2 SSR với Gez Framework","description":"Hướng dẫn xây dựng ứng dụng Vue2 SSR từ đầu với Gez, qua ví dụ minh họa cách sử dụng cơ bản của framework, bao gồm khởi tạo dự án, cấu hình Vue2 và thiết lập file entry.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, Ứng dụng SSR, Cấu hình TypeScript, Khởi tạo dự án, Render phía server, Tương tác phía client"}]]},"version":""},{"id":295,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/vi/guide/frameworks/vue3","lang":"vi","toc":[{"text":"Cấu trúc dự án","id":"cấu-trúc-dự-án","depth":2,"charIndex":-1},{"text":"Cấu hình dự án","id":"cấu-hình-dự-án","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Cấu trúc mã nguồn","id":"cấu-trúc-mã-nguồn","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Chạy dự án","id":"chạy-dự-án","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Ví dụ ứng dụng Vue3 SSR với Gez Framework","description":"Hướng dẫn xây dựng ứng dụng Vue3 SSR từ đầu với Gez, qua ví dụ minh họa cách sử dụng cơ bản của framework, bao gồm khởi tạo dự án, cấu hình Vue3 và thiết lập file entry.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, Ứng dụng SSR, Cấu hình TypeScript, Khởi tạo dự án, Render phía server, Tương tác phía client, Composition API"}]]},"version":""},{"id":296,"title":"Yêu cầu môi trường","content":"#\n\nTài liệu này mô tả các yêu cầu môi trường cần thiết để sử dụng khung này, bao\ngồm môi trường Node.js và tương thích trình duyệt.\n\n\nMôi trường Node.js#\n\nKhung yêu cầu Node.js phiên bản >= 22.6, chủ yếu để hỗ trợ nhập kiểu TypeScript\n(thông qua cờ --experimental-strip-types), không cần bước biên dịch bổ sung.\n\n\nTương thích trình duyệt#\n\nKhung mặc định được xây dựng ở chế độ tương thích để hỗ trợ nhiều trình duyệt\nhơn. Tuy nhiên, cần lưu ý rằng để đạt được hỗ trợ tương thích trình duyệt đầy\nđủ, cần thêm thủ công phụ thuộc es-module-shims.\n\n\nChế độ tương thích (mặc định)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nTheo thống kê từ Can I Use, tỷ lệ phủ sóng trình duyệt ở chế độ tương thích đạt\n96.81%.\n\n\nChế độ hỗ trợ gốc#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nChế độ hỗ trợ gốc có các ưu điểm sau:\n\n * Không có chi phí thời gian chạy, không cần bộ tải mô-đun bổ sung\n * Trình duyệt phân tích gốc, tốc độ thực thi nhanh hơn\n * Khả năng phân chia mã và tải theo yêu cầu tốt hơn\n\nTheo thống kê từ Can I Use, tỷ lệ phủ sóng trình duyệt ở chế độ tương thích đạt\n93.5%.\n\n\nKích hoạt hỗ trợ tương thích#\n\nLưu ý quan trọng\n\nMặc dù khung mặc định được xây dựng ở chế độ tương thích, nhưng để đạt được hỗ\ntrợ đầy đủ cho các trình duyệt cũ, bạn cần thêm phụ thuộc es-module-shims vào dự\nán.\n\nThêm các tập lệnh sau vào tệp HTML:\n\n\n\nThực hành tốt nhất\n 1. Đề xuất cho môi trường sản xuất:\n    * Triển khai es-module-shims lên máy chủ riêng\n    * Đảm bảo tính ổn định và tốc độ truy cập của tài nguyên\n    * Tránh các rủi ro bảo mật tiềm ẩn\n 2. Xem xét hiệu suất:\n    * Chế độ tương thích sẽ mang lại một chút chi phí hiệu suất\n    * Có thể quyết định có kích hoạt hay không dựa trên phân bố trình duyệt của\n      nhóm người dùng mục tiêu","routePath":"/vi/guide/start/environment","lang":"vi","toc":[{"text":"Môi trường Node.js","id":"môi-trường-nodejs","depth":2,"charIndex":133},{"text":"Tương thích trình duyệt","id":"tương-thích-trình-duyệt","depth":2,"charIndex":313},{"text":"Chế độ tương thích (mặc định)","id":"chế-độ-tương-thích-mặc-định","depth":3,"charIndex":546},{"text":"Chế độ hỗ trợ gốc","id":"chế-độ-hỗ-trợ-gốc","depth":3,"charIndex":748},{"text":"Kích hoạt hỗ trợ tương thích","id":"kích-hoạt-hỗ-trợ-tương-thích","depth":3,"charIndex":1157}],"domain":"","frontmatter":{"titleSuffix":"Hướng dẫn tương thích khung Gez","description":"Chi tiết các yêu cầu môi trường của khung Gez, bao gồm yêu cầu phiên bản Node.js và hướng dẫn tương thích trình duyệt, giúp nhà phát triển cấu hình đúng môi trường phát triển.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, tương thích trình duyệt, TypeScript, es-module-shims, cấu hình môi trường"}]]},"version":""},{"id":297,"title":"Bắt đầu nhanh","content":"#\n\n\nKhởi tạo dự án#\n\nĐể tạo và khởi tạo một dự án Gez mới, hãy làm theo các bước sau:\n\n\n\n\nLựa chọn phiên bản khung#\n\nKhung Gez cung cấp nhiều phiên bản công nghệ, mỗi phiên bản được tối ưu hóa cho\ncác tình huống ứng dụng khác nhau. Vui lòng chọn phiên bản phù hợp với nhu cầu\ndự án của bạn:\n\n\nHTML#\n\nPhù hợp cho các dự án theo đuổi kiến trúc tối giản:\n\n * Không phụ thuộc bên ngoài, sẵn sàng sử dụng ngay\n * Trải nghiệm phát triển JavaScript thuần\n * Phù hợp để xây dựng trang web tĩnh và ứng dụng nhẹ\n * Hỗ trợ mở rộng tính năng dần dần\n\nXem tài liệu chi tiết về phiên bản HTML\n\n\nVue2#\n\nPhù hợp cho phát triển ứng dụng doanh nghiệp:\n\n * Hỗ trợ TypeScript đầy đủ\n * Hệ sinh thái thành phần bên thứ ba phong phú\n * Chuỗi công cụ phát triển trưởng thành\n * Độ ổn định đã được kiểm chứng trong môi trường sản xuất\n\nXem tài liệu chi tiết về phiên bản Vue2\n\n\nVue3#\n\nPhù hợp cho phát triển ứng dụng Web hiện đại:\n\n * Hệ thống phản ứng dựa trên Proxy\n * Hỗ trợ API tổ hợp\n * Hiệu suất thời gian chạy tốt hơn\n * Kích thước gói nhỏ hơn\n\nXem tài liệu chi tiết về phiên bản Vue3\n\n\nPreact+HTM#\n\nPhù hợp cho các dự án theo đuổi sự nhẹ nhàng và hiệu suất cao:\n\n * Kích thước thời gian chạy cực nhỏ (3KB)\n * Cú pháp mẫu JavaScript thuần\n * API tương thích với React\n * Hiệu suất xuất sắc\n\nXem tài liệu chi tiết về phiên bản Preact+HTM\n\n\nPhát triển hỗ trợ AI#\n\nKhung Gez cung cấp khả năng phát triển hỗ trợ AI, có thể nâng cao đáng kể hiệu\nquả phát triển:\n\n 1. Chọn tài liệu phiên bản khung phù hợp\n 2. Cung cấp nội dung tài liệu cho trợ lý AI\n 3. AI sẽ tự động tạo bộ khung dự án và tệp cấu hình\n\nMẹo\n\nPhát triển hỗ trợ AI không chỉ tăng tốc độ khởi tạo dự án mà còn đảm bảo cấu\ntrúc dự án tuân thủ các phương pháp tốt nhất.","routePath":"/vi/guide/start/getting-started","lang":"vi","toc":[{"text":"Khởi tạo dự án","id":"khởi-tạo-dự-án","depth":2,"charIndex":3},{"text":"Lựa chọn phiên bản khung","id":"lựa-chọn-phiên-bản-khung","depth":2,"charIndex":89},{"text":"HTML","id":"html","depth":3,"charIndex":292},{"text":"Vue2","id":"vue2","depth":3,"charIndex":580},{"text":"Vue3","id":"vue3","depth":3,"charIndex":853},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1069},{"text":"Phát triển hỗ trợ AI","id":"phát-triển-hỗ-trợ-ai","depth":2,"charIndex":1321}],"domain":"","frontmatter":{"titleSuffix":"Hướng dẫn nhanh về khung Gez","description":"Hướng dẫn nhanh về khung Gez, giúp bạn xây dựng dự án từ đầu, bao gồm khởi tạo dự án, lựa chọn phiên bản khung và phát triển hỗ trợ AI.","head":[["meta",{"name":"keywords","content":"Khung Gez, Bắt đầu nhanh, Khởi tạo dự án, Phát triển Vue, Phát triển HTML, Hỗ trợ AI"}]]},"version":""},{"id":298,"title":"Giới thiệu","content":"#\n\n\nBối cảnh dự án#\n\nGez là một khung vi frontend hiện đại dựa trên ECMAScript Modules (ESM), tập\ntrung vào việc xây dựng các ứng dụng render phía máy chủ (SSR) hiệu suất cao và\ncó thể mở rộng. Là sản phẩm thế hệ thứ ba của dự án Genesis, Gez không ngừng đổi\nmới trong quá trình tiến hóa công nghệ:\n\n * v1.0: Thực hiện tải các thành phần từ xa theo yêu cầu dựa trên yêu cầu HTTP\n * v2.0: Thực hiện tích hợp ứng dụng dựa trên Webpack Module Federation\n * v3.0: Thiết kế lại hệ thống liên kết module dựa trên ESM gốc của trình duyệt\n\n\nBối cảnh công nghệ#\n\nTrong quá trình phát triển kiến trúc vi frontend, các giải pháp truyền thống chủ\nyếu có các hạn chế sau:\n\n\nThách thức của các giải pháp hiện có#\n\n * Nút cổ chai hiệu suất: Tiêm phụ thuộc thời gian chạy và proxy sandbox\n   JavaScript mang lại chi phí hiệu suất đáng kể\n * Cơ chế cách ly: Môi trường sandbox tự phát triển khó đạt được khả năng cách\n   ly module gốc của trình duyệt\n * Độ phức tạp xây dựng: Cải tiến công cụ xây dựng để chia sẻ phụ thuộc làm tăng\n   chi phí bảo trì dự án\n * Lệch chuẩn: Chiến lược triển khai đặc biệt và cơ chế xử lý thời gian chạy đi\n   ngược lại tiêu chuẩn phát triển Web hiện đại\n * Giới hạn hệ sinh thái: Khung kết hợp và API tùy chỉnh hạn chế lựa chọn công\n   nghệ\n\n\nĐổi mới công nghệ#\n\nGez dựa trên tiêu chuẩn Web hiện đại, cung cấp giải pháp mới:\n\n * Hệ thống module gốc: Sử dụng ESM gốc của trình duyệt và Import Maps để quản\n   lý phụ thuộc, có tốc độ phân tích và thực thi nhanh hơn\n * Cơ chế cách ly chuẩn: Thực hiện cách ly ứng dụng đáng tin cậy dựa trên phạm\n   vi module ECMAScript\n * Công nghệ mở: Hỗ trợ tích hợp liền mạch với bất kỳ khung frontend hiện đại\n   nào\n * Tối ưu trải nghiệm phát triển: Cung cấp chế độ phát triển trực quan và khả\n   năng gỡ lỗi đầy đủ\n * Tối ưu hiệu suất tối đa: Đạt được chi phí thời gian chạy bằng không thông qua\n   khả năng gốc, kết hợp với chiến lược bộ nhớ đệm thông minh\n\nTIP\n\nGez tập trung vào việc xây dựng cơ sở hạ tầng vi frontend hiệu suất cao, dễ mở\nrộng, đặc biệt phù hợp với các ứng dụng render phía máy chủ quy mô lớn.\n\n\nQuy chuẩn công nghệ#\n\n\nPhụ thuộc môi trường#\n\nVui lòng tham khảo tài liệu yêu cầu môi trường để biết chi tiết về yêu cầu trình\nduyệt và môi trường Node.js.\n\n\nCông nghệ cốt lõi#\n\n * Quản lý phụ thuộc: Sử dụng Import Maps để ánh xạ module, sử dụng\n   es-module-shims để cung cấp hỗ trợ tương thích\n * Hệ thống xây dựng: Dựa trên module-import của Rspack để xử lý phụ thuộc bên\n   ngoài\n * Công cụ phát triển: Hỗ trợ cập nhật nóng ESM và thực thi TypeScript gốc\n\n\nĐịnh vị khung#\n\nGez khác với Next.js hoặc Nuxt.js, tập trung vào việc cung cấp cơ sở hạ tầng vi\nfrontend:\n\n * Hệ thống liên kết module: Thực hiện nhập xuất module hiệu quả, đáng tin cậy\n * Render phía máy chủ: Cung cấp cơ chế thực hiện SSR linh hoạt\n * Hỗ trợ hệ thống kiểu: Tích hợp định nghĩa kiểu TypeScript đầy đủ\n * Tính trung lập khung: Hỗ trợ tích hợp với các khung frontend chính\n\n\nThiết kế kiến trúc#\n\n\nQuản lý phụ thuộc tập trung#\n\n * Nguồn phụ thuộc thống nhất: Quản lý phụ thuộc bên thứ ba tập trung\n * Phân phối tự động: Đồng bộ hóa tự động toàn cầu khi cập nhật phụ thuộc\n * Nhất quán phiên bản: Kiểm soát phiên bản phụ thuộc chính xác\n\n\nThiết kế module hóa#\n\n * Tách biệt trách nhiệm: Tách biệt logic nghiệp vụ và cơ sở hạ tầng\n * Cơ chế plugin: Hỗ trợ kết hợp và thay thế module linh hoạt\n * Giao diện chuẩn: Giao thức giao tiếp chuẩn hóa giữa các module\n\n\nTối ưu hiệu suất#\n\n * Nguyên tắc chi phí bằng không: Tận dụng tối đa khả năng gốc của trình duyệt\n * Bộ nhớ đệm thông minh: Chiến lược bộ nhớ đệm chính xác dựa trên băm nội dung\n * Tải theo yêu cầu: Quản lý phụ thuộc và phân chia mã tinh vi\n\n\nĐộ trưởng thành dự án#\n\nGez đã trải qua gần 5 năm lặp lại và tiến hóa (từ v1.0 đến v3.0), đã được kiểm\nchứng toàn diện trong môi trường doanh nghiệp. Hiện tại hỗ trợ hàng chục dự án\nnghiệp vụ hoạt động ổn định và tiếp tục thúc đẩy nâng cấp công nghệ hiện đại.\nTính ổn định, độ tin cậy và lợi thế hiệu suất của khung đã được kiểm chứng đầy\nđủ trong thực tế, cung cấp nền tảng công nghệ đáng tin cậy cho phát triển ứng\ndụng quy mô lớn.","routePath":"/vi/guide/start/introduction","lang":"vi","toc":[{"text":"Bối cảnh dự án","id":"bối-cảnh-dự-án","depth":2,"charIndex":3},{"text":"Bối cảnh công nghệ","id":"bối-cảnh-công-nghệ","depth":2,"charIndex":532},{"text":"Thách thức của các giải pháp hiện có","id":"thách-thức-của-các-giải-pháp-hiện-có","depth":3,"charIndex":660},{"text":"Đổi mới công nghệ","id":"đổi-mới-công-nghệ","depth":3,"charIndex":1256},{"text":"Quy chuẩn công nghệ","id":"quy-chuẩn-công-nghệ","depth":2,"charIndex":2067},{"text":"Phụ thuộc môi trường","id":"phụ-thuộc-môi-trường","depth":3,"charIndex":2090},{"text":"Công nghệ cốt lõi","id":"công-nghệ-cốt-lõi","depth":3,"charIndex":2225},{"text":"Định vị khung","id":"định-vị-khung","depth":2,"charIndex":2528},{"text":"Thiết kế kiến trúc","id":"thiết-kế-kiến-trúc","depth":2,"charIndex":2918},{"text":"Quản lý phụ thuộc tập trung","id":"quản-lý-phụ-thuộc-tập-trung","depth":3,"charIndex":2940},{"text":"Thiết kế module hóa","id":"thiết-kế-module-hóa","depth":3,"charIndex":3180},{"text":"Tối ưu hiệu suất","id":"tối-ưu-hiệu-suất","depth":3,"charIndex":3401},{"text":"Độ trưởng thành dự án","id":"độ-trưởng-thành-dự-án","depth":2,"charIndex":3644}],"domain":"","frontmatter":{"titleSuffix":"Tổng quan về khung Gez và đổi mới công nghệ","description":"Tìm hiểu sâu về bối cảnh dự án, tiến hóa công nghệ và lợi thế cốt lõi của khung vi frontend Gez, khám phá giải pháp render phía máy chủ hiện đại dựa trên ESM.","head":[["meta",{"property":"keywords","content":"Gez, vi frontend, ESM, render phía máy chủ, SSR, đổi mới công nghệ, liên bang module"}]]},"version":""}]