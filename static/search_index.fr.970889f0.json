[{"id":75,"title":"@gez/rspack-vue","content":"#\n\nLe package Rspack Vue fournit un ensemble d'API pour créer et configurer des\napplications Rspack basées sur le framework Vue, prenant en charge le\ndéveloppement de composants Vue, la construction et le rendu côté serveur.\n\n\nInstallation#\n\nInstallez @gez/rspack-vue en tant que dépendance de développement à l'aide d'un\ngestionnaire de paquets :\n\n\nExportation des types#\n\n\nBuildTarget#\n\n\n\nType d'environnement cible de construction, définissant l'environnement cible de\nl'application pour configurer des optimisations et fonctionnalités spécifiques\nlors du processus de construction :\n\n * node : Code exécuté dans un environnement Node.js\n * client : Code exécuté dans un environnement navigateur\n * server : Code exécuté dans un environnement serveur\n\n\nRspackAppConfigContext#\n\n\n\nInterface de contexte de configuration d'application Rspack, fournissant des\ninformations de contexte accessibles dans les fonctions de rappel de\nconfiguration :\n\n * gez : Instance du framework Gez\n * buildTarget : Cible de construction actuelle (client/serveur/node)\n * config : Objet de configuration Rspack\n * options : Options de configuration de l'application\n\n\nRspackAppOptions#\n\n\n\nInterface des options de configuration d'application Rspack :\n\n * css : Méthode de sortie CSS, option 'css' (fichier séparé) ou 'style' (style\n   en ligne)\n * loaders : Configuration personnalisée des loaders\n * styleLoader : Options de configuration de style-loader\n * cssLoader : Options de configuration de css-loader\n * target : Configuration de compatibilité des cibles de construction\n * definePlugin : Définition de constantes globales\n * config : Fonction de rappel de configuration\n\n\nRspackHtmlAppOptions#\n\nHérite de RspackAppOptions, utilisé pour configurer des options spécifiques aux\napplications HTML.\n\n\nExportation des fonctions#\n\n\ncreateRspackApp#\n\n\n\nCrée une instance d'application Rspack standard.\n\nParamètres :\n\n * gez : Instance du framework Gez\n * options : Options de configuration de l'application Rspack\n\nValeur de retour :\n\n * Retourne une Promise qui se résout en l'instance d'application créée\n\n\ncreateRspackHtmlApp#\n\n\n\nCrée une instance d'application Rspack de type HTML.\n\nParamètres :\n\n * gez : Instance du framework Gez\n * options : Options de configuration de l'application HTML\n\nValeur de retour :\n\n * Retourne une Promise qui se résout en l'instance d'application HTML créée\n\n\nExportation des constantes#\n\n\nRSPACK_LOADER#\n\n\n\nObjet de mappage des identifiants de loaders intégrés à Rspack, fournissant des\nconstantes de noms de loaders couramment utilisés :\n\n * builtinSwcLoader : Loader SWC intégré à Rspack, utilisé pour traiter les\n   fichiers TypeScript/JavaScript\n * lightningcssLoader : Loader lightningcss intégré à Rspack, utilisé pour\n   compiler les fichiers CSS avec des performances élevées\n * styleLoader : Loader utilisé pour injecter le CSS dans le DOM\n * cssLoader : Loader utilisé pour analyser les fichiers CSS et gérer la\n   modularisation CSS\n * lessLoader : Loader utilisé pour compiler les fichiers Less en CSS\n * styleResourcesLoader : Loader utilisé pour importer automatiquement des\n   ressources de style globales (comme des variables, des mixins)\n * workerRspackLoader : Loader utilisé pour traiter les fichiers Web Worker\n\nUtiliser ces constantes permet de référencer les loaders intégrés dans la\nconfiguration, évitant ainsi de saisir manuellement des chaînes de caractères :\n\n\n\nRemarques :\n\n * Ces loaders sont déjà intégrés à Rspack, aucune installation supplémentaire\n   n'est nécessaire\n * Lors de la configuration personnalisée des loaders, ces constantes peuvent\n   être utilisées pour remplacer l'implémentation par défaut des loaders\n * Certains loaders (comme builtinSwcLoader) ont des options de configuration\n   spécifiques, veuillez consulter la documentation de configuration\n   correspondante\n\n\nExportation des modules#\n\n\nrspack#\n\nRéexporte tout le contenu du package @rspack/core, fournissant toutes les\nfonctionnalités principales de Rspack.","routePath":"/fr/api/app/rspack-vue","lang":"fr","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":226},{"text":"Exportation des types","id":"exportation-des-types","depth":2,"charIndex":349},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":374},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":755},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1149},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1663},{"text":"Exportation des fonctions","id":"exportation-des-fonctions","depth":2,"charIndex":1787},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1816},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":2092},{"text":"Exportation des constantes","id":"exportation-des-constantes","depth":2,"charIndex":2379},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2409},{"text":"Exportation des modules","id":"exportation-des-modules","depth":2,"charIndex":3839},{"text":"rspack","id":"rspack","depth":3,"charIndex":3866}],"domain":"","frontmatter":{"titleSuffix":"Outil de construction Vue pour le framework Gez","description":"Outil de construction dédié à Vue pour le framework Gez, offrant un support complet pour la construction d'applications Vue 2/3, y compris le développement de composants, le rendu SSR et l'optimisation des performances.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, outil de construction, développement de composants, rendu côté serveur, optimisation des performances"}]]},"version":""},{"id":76,"title":"@gez/rspack","content":"#\n\nLe package Rspack fournit un ensemble d'API pour créer et configurer des\napplications Rspack, prenant en charge la construction et le développement\nd'applications standard et d'applications HTML.\n\n\nInstallation#\n\nInstallez la dépendance de développement @gez/rspack à l'aide d'un gestionnaire\nde paquets :\n\n\nExportation des types#\n\n\nBuildTarget#\n\n\n\nType d'environnement cible de construction, définissant l'environnement cible de\nconstruction de l'application, utilisé pour configurer des optimisations et\nfonctionnalités spécifiques lors du processus de construction :\n\n * node : Construction de code exécuté dans un environnement Node.js\n * client : Construction de code exécuté dans un environnement navigateur\n * server : Construction de code exécuté dans un environnement serveur\n\n\nRspackAppConfigContext#\n\n\n\nInterface de contexte de configuration d'application Rspack, fournissant des\ninformations de contexte accessibles dans les fonctions de rappel de\nconfiguration :\n\n * gez : Instance du framework Gez\n * buildTarget : Cible de construction actuelle (client/serveur/node)\n * config : Objet de configuration Rspack\n * options : Options de configuration de l'application\n\n\nRspackAppOptions#\n\n\n\nInterface des options de configuration d'application Rspack :\n\n * css : Méthode de sortie CSS, option 'css' (fichier séparé) ou 'style' (style\n   en ligne)\n * loaders : Configuration personnalisée des loaders\n * styleLoader : Options de configuration de style-loader\n * cssLoader : Options de configuration de css-loader\n * target : Configuration de compatibilité de la cible de construction\n * definePlugin : Définition de constantes globales\n * config : Fonction de rappel de configuration\n\n\nRspackHtmlAppOptions#\n\nHérite de RspackAppOptions, utilisé pour configurer des options spécifiques aux\napplications HTML.\n\n\nExportation des fonctions#\n\n\ncreateRspackApp#\n\n\n\nCrée une instance d'application Rspack standard.\n\nParamètres :\n\n * gez : Instance du framework Gez\n * options : Options de configuration de l'application Rspack\n\nValeur de retour :\n\n * Retourne une Promise qui se résout en une instance d'application créée\n\n\ncreateRspackHtmlApp#\n\n\n\nCrée une instance d'application Rspack de type HTML.\n\nParamètres :\n\n * gez : Instance du framework Gez\n * options : Options de configuration de l'application HTML\n\nValeur de retour :\n\n * Retourne une Promise qui se résout en une instance d'application HTML créée\n\n\nExportation des constantes#\n\n\nRSPACK_LOADER#\n\n\n\nObjet de mappage des identifiants de loaders intégrés à Rspack, fournissant des\nconstantes de noms de loaders couramment utilisés :\n\n * builtinSwcLoader : Loader SWC intégré à Rspack, utilisé pour traiter les\n   fichiers TypeScript/JavaScript\n * lightningcssLoader : Loader lightningcss intégré à Rspack, utilisé pour\n   traiter les fichiers CSS avec un compilateur haute performance\n * styleLoader : Loader utilisé pour injecter le CSS dans le DOM\n * cssLoader : Loader utilisé pour analyser les fichiers CSS et gérer la\n   modularisation CSS\n * lessLoader : Loader utilisé pour compiler les fichiers Less en CSS\n * styleResourcesLoader : Loader utilisé pour importer automatiquement des\n   ressources de style globales (comme des variables, mixins)\n * workerRspackLoader : Loader utilisé pour traiter les fichiers Web Worker\n\nUtiliser ces constantes permet de référencer les loaders intégrés dans la\nconfiguration, évitant de saisir manuellement des chaînes de caractères :\n\n\n\nRemarques :\n\n * Ces loaders sont déjà intégrés à Rspack, aucune installation supplémentaire\n   n'est nécessaire\n * Lors de la configuration personnalisée des loaders, ces constantes peuvent\n   être utilisées pour remplacer l'implémentation par défaut des loaders\n * Certains loaders (comme builtinSwcLoader) ont des options de configuration\n   spécifiques, veuillez consulter la documentation de configuration\n   correspondante\n\n\nExportation des modules#\n\n\nrspack#\n\nRéexporte tout le contenu du package @rspack/core, fournissant toutes les\nfonctionnalités principales de Rspack.","routePath":"/fr/api/app/rspack","lang":"fr","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":200},{"text":"Exportation des types","id":"exportation-des-types","depth":2,"charIndex":310},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":335},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":789},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1183},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1698},{"text":"Exportation des fonctions","id":"exportation-des-fonctions","depth":2,"charIndex":1822},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1851},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":2129},{"text":"Exportation des constantes","id":"exportation-des-constantes","depth":2,"charIndex":2418},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2448},{"text":"Exportation des modules","id":"exportation-des-modules","depth":2,"charIndex":3875},{"text":"rspack","id":"rspack","depth":3,"charIndex":3902}],"domain":"","frontmatter":{"titleSuffix":"Outil de construction Rspack du framework Gez","description":"L'outil de construction Rspack du framework Gez offre des capacités de construction d'applications hautes performances, prenant en charge le développement et la construction d'applications standard et d'applications HTML, avec des processeurs de ressources intégrés et des configurations d'optimisation.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, outil de construction, construction d'applications, application HTML, TypeScript, CSS, traitement des ressources, optimisation des performances"}]]},"version":""},{"id":77,"title":"App","content":"#\n\nApp est l'abstraction d'application du framework Gez, fournissant une interface\nunifiée pour gérer le cycle de vie de l'application, les ressources statiques et\nle rendu côté serveur.\n\n\n\n\nDéfinitions de types#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Type: Middleware\n\nMiddleware de traitement des ressources statiques.\n\nEnvironnement de développement :\n\n * Traite les requêtes de ressources statiques du code source\n * Supporte la compilation en temps réel et le rechargement à chaud\n * Utilise une stratégie de cache no-cache\n\nEnvironnement de production :\n\n * Traite les ressources statiques après la construction\n * Supporte le cache à long terme des fichiers immuables (.final.xxx)\n * Stratégie optimisée de chargement des ressources\n\n\n\nrender#\n\n * Type: (options?: RenderContextOptions) => Promise\n\nFonction de rendu côté serveur. Fournit différentes implémentations selon\nl'environnement d'exécution :\n\n * Environnement de production (start) : Charge le fichier d'entrée côté serveur\n   construit (entry.server) pour exécuter le rendu\n * Environnement de développement (dev) : Charge le fichier d'entrée côté\n   serveur du code source pour exécuter le rendu\n\n\n\nbuild#\n\n * Type: () => Promise\n\nFonction de construction pour l'environnement de production. Utilisée pour\nl'empaquetage et l'optimisation des ressources. Retourne true en cas de succès,\nfalse en cas d'échec.\n\ndestroy#\n\n * Type: () => Promise\n\nFonction de nettoyage des ressources. Utilisée pour fermer le serveur,\ndéconnecter les connexions, etc. Retourne true en cas de succès, false en cas\nd'échec.","routePath":"/fr/api/core/app","lang":"fr","toc":[{"text":"Définitions de types","id":"définitions-de-types","depth":2,"charIndex":190},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":222},{"text":"render","id":"render","depth":4,"charIndex":729},{"text":"build","id":"build","depth":4,"charIndex":1155},{"text":"destroy","id":"destroy","depth":4,"charIndex":1365}],"domain":"","frontmatter":{"titleSuffix":"Interface d'application abstraite du framework Gez","description":"Détaille l'interface App du framework Gez, incluant la gestion du cycle de vie des applications, le traitement des ressources statiques et le rendu côté serveur, pour aider les développeurs à comprendre et utiliser les fonctionnalités clés de l'application.","head":[["meta",{"property":"keywords","content":"Gez, App, abstraction d'application, cycle de vie, ressources statiques, rendu côté serveur, API"}]]},"version":""},{"id":78,"title":"Gez","content":"#\n\n\nIntroduction#\n\nGez est un framework d'application Web haute performance basé sur Rspack,\noffrant une gestion complète du cycle de vie des applications, le traitement des\nressources statiques et des capacités de rendu côté serveur.\n\n\nDéfinitions de types#\n\n\nRuntimeTarget#\n\n * Définition de type:\n\n\n\nTypes d'environnements d'exécution des applications :\n\n * client : Fonctionne dans un environnement de navigateur, supporte les\n   opérations DOM et les API du navigateur\n * server : Fonctionne dans un environnement Node.js, supporte le système de\n   fichiers et les fonctionnalités côté serveur\n\n\nImportMap#\n\n * Définition de type:\n\n\n\nType de mappage d'importation des modules ES.\n\nSpecifierMap#\n\n * Définition de type:\n\n\n\nType de mappage des identifiants de modules, utilisé pour définir les relations\nde mappage des chemins d'importation des modules.\n\nScopesMap#\n\n * Définition de type:\n\n\n\nType de mappage des portées, utilisé pour définir les relations de mappage des\nimportations de modules dans des portées spécifiques.\n\n\nCOMMAND#\n\n * Définition de type:\n\n\n\nEnumération des types de commandes :\n\n * dev : Commande pour l'environnement de développement, démarre le serveur de\n   développement avec support du rechargement à chaud\n * build : Commande de construction, génère les artefacts de production\n * preview : Commande de prévisualisation, démarre un serveur de\n   prévisualisation local\n * start : Commande de démarrage, exécute le serveur de production\n\n\nOptions d'instance#\n\nDéfinit les options de configuration principales du framework Gez.\n\n\n\nroot#\n\n * Type : string\n * Valeur par défaut : process.cwd()\n\nChemin du répertoire racine du projet. Peut être un chemin absolu ou relatif,\nles chemins relatifs sont résolus par rapport au répertoire de travail actuel.\n\nisProd#\n\n * Type : boolean\n * Valeur par défaut : process.env.NODE_ENV === 'production'\n\nIdentifiant d'environnement.\n\n * true : Environnement de production\n * false : Environnement de développement\n\nbasePathPlaceholder#\n\n * Type : string | false\n * Valeur par défaut : '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nConfiguration de l'espace réservé pour le chemin de base. Utilisé pour remplacer\ndynamiquement le chemin de base des ressources à l'exécution. Définir à false\ndésactive cette fonctionnalité.\n\nmodules#\n\n * Type : ModuleConfig\n\nOptions de configuration des modules. Utilisé pour configurer les règles de\nrésolution des modules du projet, incluant les alias de modules, les dépendances\nexternes, etc.\n\npacks#\n\n * Type : PackConfig\n\nOptions de configuration de l'empaquetage. Utilisé pour empaqueter les artefacts\nde construction en paquets logiciels .tgz standard npm.\n\ndevApp#\n\n * Type : (gez: Gez) => Promise\n\nFonction de création d'application pour l'environnement de développement.\nUtilisé uniquement dans l'environnement de développement pour créer une instance\nd'application pour le serveur de développement.\n\n\n\nserver#\n\n * Type : (gez: Gez) => Promise\n\nFonction de configuration et de démarrage du serveur HTTP. Utilisé pour\nconfigurer et démarrer le serveur HTTP, utilisable à la fois dans les\nenvironnements de développement et de production.\n\n\n\npostBuild#\n\n * Type : (gez: Gez) => Promise\n\nFonction de post-traitement après la construction. Exécutée après la\nconstruction du projet, peut être utilisée pour :\n\n * Exécuter un traitement supplémentaire des ressources\n * Effectuer des opérations de déploiement\n * Générer des fichiers statiques\n * Envoyer des notifications de construction\n\n\nPropriétés d'instance#\n\n\nname#\n\n * Type : string\n * Lecture seule : true\n\nNom du module actuel, provenant de la configuration du module.\n\n\nvarName#\n\n * Type : string\n * Lecture seule : true\n\nNom de variable JavaScript valide généré à partir du nom du module.\n\n\nroot#\n\n * Type : string\n * Lecture seule : true\n\nChemin absolu du répertoire racine du projet. Si le root configuré est un chemin\nrelatif, il est résolu par rapport au répertoire de travail actuel.\n\n\nisProd#\n\n * Type : boolean\n * Lecture seule : true\n\nDétermine si l'environnement actuel est un environnement de production. Utilise\nen priorité l'option de configuration isProd, sinon détermine en fonction de\nprocess.env.NODE_ENV.\n\n\nbasePath#\n\n * Type : string\n * Lecture seule : true\n * Lève : NotReadyError - Si le framework n'est pas initialisé\n\nObtient le chemin de base du module commençant et se terminant par une barre\noblique. Le format de retour est /${name}/, où name provient de la configuration\ndu module.\n\n\nbasePathPlaceholder#\n\n * Type : string\n * Lecture seule : true\n\nObtient l'espace réservé pour le remplacement dynamique du chemin de base à\nl'exécution. Peut être désactivé via la configuration.\n\n\nmiddleware#\n\n * Type : Middleware\n * Lecture seule : true\n\nObtient le middleware de traitement des ressources statiques. Fournit des\nimplémentations différentes selon l'environnement :\n\n * Environnement de développement : Supporte la compilation en temps réel et le\n   rechargement à chaud\n * Environnement de production : Supporte la mise en cache à long terme des\n   ressources statiques\n\n\n\n\nrender#\n\n * Type : (options?: RenderContextOptions) => Promise\n * Lecture seule : true\n\nObtient la fonction de rendu côté serveur. Fournit des implémentations\ndifférentes selon l'environnement :\n\n * Environnement de développement : Supporte le rechargement à chaud et la\n   prévisualisation en temps réel\n * Environnement de production : Fournit des performances de rendu optimisées\n\n\n\n\nCOMMAND#\n\n * Type : typeof COMMAND\n * Lecture seule : true\n\nObtient la définition du type d'énumération des commandes.\n\n\nmoduleConfig#\n\n * Type : ParsedModuleConfig\n * Lecture seule : true\n * Lève : NotReadyError - Si le framework n'est pas initialisé\n\nObtient les informations de configuration complètes du module actuel, incluant\nles règles de résolution des modules, les configurations d'alias, etc.\n\n\npackConfig#\n\n * Type : ParsedPackConfig\n * Lecture seule : true\n * Lève : NotReadyError - Si le framework n'est pas initialisé\n\nObtient les configurations relatives à l'empaquetage du module actuel, incluant\nle chemin de sortie, le traitement de package.json, etc.\n\n\nMéthodes d'instance#\n\n\nconstructor()#\n\n * Paramètres :\n   * options?: GezOptions - Options de configuration du framework\n * Retour : Gez\n\nCrée une instance du framework Gez.\n\n\n\n\ninit()#\n\n * Paramètres : command: COMMAND\n * Retour : Promise\n * Lève :\n   * Error : En cas de réinitialisation\n   * NotReadyError : Lors de l'accès à une instance non initialisée\n\nInitialise l'instance du framework Gez. Exécute les processus d'initialisation\nprincipaux suivants :\n\n 1. Analyse la configuration du projet (package.json, configuration des modules,\n    configuration de l'empaquetage, etc.)\n 2. Crée une instance d'application (environnement de développement ou de\n    production)\n 3. Exécute les méthodes du cycle de vie correspondantes en fonction de la\n    commande\n\nAttention\n * Une réinitialisation lève une erreur\n * L'accès à une instance non initialisée lève NotReadyError\n\n\n\n\ndestroy()#\n\n * Retour : Promise\n\nDétruit l'instance du framework Gez, exécute le nettoyage des ressources et la\nfermeture des connexions. Principalement utilisé pour :\n\n * Fermer le serveur de développement\n * Nettoyer les fichiers temporaires et le cache\n * Libérer les ressources système\n\n\n\n\nbuild()#\n\n * Retour : Promise\n\nExécute le processus de construction de l'application, incluant :\n\n * Compilation du code source\n * Génération des artefacts de production\n * Optimisation et compression du code\n * Génération du manifeste des ressources\n\nAttention\n\nL'appel avant l'initialisation du framework lève NotReadyError\n\n\n\n\nserver()#\n\n * Retour : Promise\n * Lève : NotReadyError - Si le framework n'est pas initialisé\n\nDémarre le serveur HTTP et configure l'instance du serveur. Appelé dans les\ncycles de vie suivants :\n\n * Environnement de développement (dev) : Démarre le serveur de développement\n   avec rechargement à chaud\n * Environnement de production (start) : Démarre le serveur de production avec\n   des performances de niveau production\n\n\n\n\npostBuild()#\n\n * Retour : Promise\n\nExécute la logique de post-traitement après la construction, utilisée pour :\n\n * Générer des fichiers HTML statiques\n * Traiter les artefacts de construction\n * Exécuter des tâches de déploiement\n * Envoyer des notifications de construction\n\n\n\n\nresolvePath#\n\nRésout les chemins du projet, convertit les chemins relatifs en chemins absolus.\n\n * Paramètres :\n   \n   * projectPath: ProjectPath - Type de chemin du projet\n   * ...args: string[] - Segments de chemin\n\n * Retour : string - Chemin absolu résolu\n\n * Exemple :\n\n\n\n\nwriteSync()#\n\nÉcrit de manière synchrone le contenu d'un fichier.\n\n * Paramètres :\n   \n   * filepath : string - Chemin absolu du fichier\n   * data : any - Données à écrire, peut être une chaîne, un Buffer ou un objet\n\n * Retour : boolean - Indique si l'écriture a réussi\n\n * Exemple :\n\n\n\n\nreadJsonSync()#\n\nLit et analyse de manière synchrone un fichier JSON.\n\n * Paramètres :\n   \n   * filename : string - Chemin absolu du fichier JSON\n\n * Retour : any - Objet JSON analysé\n\n * Exception : Lève une exception si le fichier n'existe pas ou si le format\n   JSON est incorrect\n\n * Exemple :\n\n\n\n\nreadJson()#\n\nLit et analyse de manière asynchrone un fichier JSON.\n\n * Paramètres :\n   \n   * filename : string - Chemin absolu du fichier JSON\n\n * Retour : Promise - Objet JSON analysé\n\n * Exception : Lève une exception si le fichier n'existe pas ou si le format\n   JSON est incorrect\n\n * Exemple :\n\n\n\n\ngetManifestList()#\n\nObtient la liste des manifestes de construction.\n\n * Paramètres :\n   \n   * target : RuntimeTarget - Type d'environnement cible\n     * 'client' : Environnement client\n     * 'server' : Environnement serveur\n\n * Retour : Promise - Liste en lecture seule des manifestes de construction\n\n * Exception : Lève NotReadyError si l'instance du framework n'est pas\n   initialisée\n\nCette méthode est utilisée pour obtenir la liste des manifestes de construction\npour l'environnement cible spécifié, incluant les fonctionnalités suivantes :\n\n 1. Gestion du cache\n    \n    * Utilise un mécanisme de cache interne pour éviter les chargements répétés\n    * Retourne une liste de manifestes immuable\n\n 2. Adaptation à l'environnement\n    \n    * Supporte les environnements client et serveur\n    * Retourne les informations de manifeste correspondantes en fonction de\n      l'environnement c","routePath":"/fr/api/core/gez","lang":"fr","toc":[{"text":"Introduction","id":"introduction","depth":2,"charIndex":3},{"text":"Définitions de types","id":"définitions-de-types","depth":2,"charIndex":236},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":260},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":600},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":685},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":857},{"text":"COMMAND","id":"command","depth":3,"charIndex":1030},{"text":"Options d'instance","id":"options-dinstance","depth":2,"charIndex":1469},{"text":"root","id":"root","depth":4,"charIndex":1560},{"text":"isProd","id":"isprod","depth":4,"charIndex":1780},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1980},{"text":"modules","id":"modules","depth":4,"charIndex":2274},{"text":"packs","id":"packs","depth":4,"charIndex":2481},{"text":"devApp","id":"devapp","depth":4,"charIndex":2649},{"text":"server","id":"server","depth":4,"charIndex":2897},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":3134},{"text":"Propriétés d'instance","id":"propriétés-dinstance","depth":2,"charIndex":3479},{"text":"name","id":"name","depth":3,"charIndex":3504},{"text":"varName","id":"varname","depth":3,"charIndex":3618},{"text":"root","id":"root-1","depth":3,"charIndex":3740},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3940},{"text":"basePath","id":"basepath","depth":3,"charIndex":4173},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":4460},{"text":"middleware","id":"middleware","depth":3,"charIndex":4657},{"text":"render","id":"render","depth":3,"charIndex":5051},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":5438},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":5559},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":5843},{"text":"Méthodes d'instance","id":"méthodes-dinstance","depth":2,"charIndex":6110},{"text":"constructor()","id":"constructor","depth":3,"charIndex":6133},{"text":"init()","id":"init","depth":3,"charIndex":6288},{"text":"destroy()","id":"destroy","depth":3,"charIndex":6988},{"text":"build()","id":"build","depth":3,"charIndex":7282},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":8320},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":8598},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":8887},{"text":"readJson()","id":"readjson","depth":3,"charIndex":9189},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":9492}],"domain":"","frontmatter":{"titleSuffix":"Référence de l'API des classes principales du framework","description":"Documentation détaillée de l'API des classes principales du framework Gez, incluant la gestion du cycle de vie des applications, le traitement des ressources statiques et les capacités de rendu côté serveur, pour aider les développeurs à comprendre en profondeur les fonctionnalités clés du framework.","head":[["meta",{"property":"keywords","content":"Gez, API, gestion du cycle de vie, ressources statiques, rendu côté serveur, Rspack, framework d'application Web"}]]},"version":""},{"id":79,"title":"ManifestJson","content":"#\n\nmanifest.json est un fichier manifeste généré par le framework Gez lors du\nprocessus de construction, utilisé pour enregistrer les informations sur les\nartefacts de construction du service. Il fournit une interface unifiée pour\ngérer les artefacts de construction, les fichiers exportés et les statistiques\nde taille des ressources.\n\n\n\n\nDéfinitions de types#\n\n\nManifestJson#\n\n\n\nname#\n\n * Type: string\n\nNom du service, provenant de la configuration GezOptions.name.\n\nexports#\n\n * Type: Record\n\nRelation de mappage des fichiers exportés, où la clé est le chemin du fichier\nsource et la valeur est le chemin du fichier après construction.\n\nbuildFiles#\n\n * Type: string[]\n\nListe complète des fichiers des artefacts de construction, incluant tous les\nchemins de fichiers générés.\n\nchunks#\n\n * Type: Record\n\nRelation entre les fichiers sources et les artefacts compilés, où la clé est le\nchemin du fichier source et la valeur est l'information de compilation.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Type: string\n\nChemin du fichier JS compilé pour le fichier source actuel.\n\ncss#\n\n * Type: string[]\n\nListe des chemins des fichiers CSS associés au fichier source actuel.\n\nresources#\n\n * Type: string[]\n\nListe des chemins des autres fichiers de ressources associés au fichier source\nactuel.\n\nsizes#\n\n * Type: ManifestJsonChunkSizes\n\nInformations sur la taille des artefacts de construction.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Type: number\n\nTaille du fichier JS (en octets).\n\ncss#\n\n * Type: number\n\nTaille du fichier CSS (en octets).\n\nresource#\n\n * Type: number\n\nTaille des fichiers de ressources (en octets).","routePath":"/fr/api/core/manifest-json","lang":"fr","toc":[{"text":"Définitions de types","id":"définitions-de-types","depth":2,"charIndex":339},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":380},{"text":"exports","id":"exports","depth":4,"charIndex":468},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":639},{"text":"chunks","id":"chunks","depth":4,"charIndex":778},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":958},{"text":"js","id":"js","depth":4,"charIndex":981},{"text":"css","id":"css","depth":4,"charIndex":1064},{"text":"resources","id":"resources","depth":4,"charIndex":1160},{"text":"sizes","id":"sizes","depth":4,"charIndex":1279},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1380},{"text":"js","id":"js-1","depth":4,"charIndex":1407},{"text":"css","id":"css-1","depth":4,"charIndex":1464},{"text":"resource","id":"resource","depth":4,"charIndex":1523}],"domain":"","frontmatter":{"titleSuffix":"Référence du fichier manifeste de construction du framework Gez","description":"Documentation détaillée sur la structure du fichier manifeste de construction (manifest.json) du framework Gez, incluant la gestion des artefacts de construction, le mappage des fichiers exportés et les statistiques de ressources, pour aider les développeurs à comprendre et utiliser le système de construction.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, Manifeste de construction, Gestion des ressources, Artefacts de construction, Mappage de fichiers, API"}]]},"version":""},{"id":80,"title":"ModuleConfig","content":"#\n\nModuleConfig fournit les fonctionnalités de configuration des modules du\nframework Gez, permettant de définir les règles d'import/export de modules, la\nconfiguration des alias et les dépendances externes.\n\n\nDéfinitions de types#\n\n\nPathType#\n\n * Définition de type:\n\n\n\nÉnumération des types de chemins de modules :\n\n * npm: représente les dépendances dans node_modules\n * root: représente les fichiers dans le répertoire racine du projet\n\n\nModuleConfig#\n\n * Définition de type:\n\n\n\nInterface de configuration des modules, utilisée pour définir les configurations\nd'export, d'import et de dépendances externes d'un service.\n\nexports#\n\nListe de configuration des exports, exposant des unités de code spécifiques\n(composants, fonctions utilitaires, etc.) du service au format ESM.\n\nSupporte deux types :\n\n * root:*: exporte les fichiers sources, par exemple :\n   'root:src/components/button.vue'\n * npm:*: exporte des dépendances tierces, par exemple : 'npm:vue'\n\nimports#\n\nMappage de configuration des imports, configurant les modules distants à\nimporter et leurs chemins locaux.\n\nLa configuration varie selon le mode d'installation :\n\n * Installation depuis les sources (Workspace, Git) : doit pointer vers le\n   répertoire dist\n * Installation depuis un package (Link, serveur statique, miroir privé, File) :\n   pointe directement vers le répertoire du package\n\nexternals#\n\nMappage des dépendances externes, configurant les dépendances externes à\nutiliser, généralement des dépendances provenant de modules distants.\n\nExemple :\n\n\n\n\nParsedModuleConfig#\n\n * Définition de type:\n\n\n\nConfiguration des modules après analyse, convertissant la configuration\noriginale des modules en un format interne standardisé :\n\nname#\n\nNom du service actuel\n\n * Utilisé pour identifier le module et générer les chemins d'import\n\nroot#\n\nChemin du répertoire racine du service actuel\n\n * Utilisé pour résoudre les chemins relatifs et stocker les artefacts de\n   construction\n\nexports#\n\nListe de configuration des exports\n\n * name: chemin d'export original, par exemple : 'npm:vue' ou\n   'root:src/components'\n * type: type de chemin (npm ou root)\n * importName: nom d'import, format : '${serviceName}/${type}/${path}'\n * exportName: chemin d'export, relatif au répertoire racine du service\n * exportPath: chemin réel du fichier\n * externalName: nom de la dépendance externe, utilisé comme identifiant lors de\n   l'import de ce module par d'autres services\n\nimports#\n\nListe de configuration des imports\n\n * name: nom du service externe\n * localPath: chemin de stockage local, utilisé pour stocker les artefacts de\n   construction des modules externes\n\nexternals#\n\nMappage des dépendances externes\n\n * Mappe les chemins d'import des modules vers leurs emplacements réels\n * match: expression régulière utilisée pour correspondre aux instructions\n   d'import\n * import: chemin réel du module\n\n","routePath":"/fr/api/core/module-config","lang":"fr","toc":[{"text":"Définitions de types","id":"définitions-de-types","depth":2,"charIndex":209},{"text":"PathType","id":"pathtype","depth":3,"charIndex":233},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":624},{"text":"imports","id":"imports","depth":4,"charIndex":961},{"text":"externals","id":"externals","depth":4,"charIndex":1362},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1532},{"text":"name","id":"name","depth":4,"charIndex":1709},{"text":"root","id":"root","depth":4,"charIndex":1809},{"text":"exports","id":"exports-1","depth":4,"charIndex":1954},{"text":"imports","id":"imports-1","depth":4,"charIndex":2435},{"text":"externals","id":"externals-1","depth":4,"charIndex":2629}],"domain":"","frontmatter":{"titleSuffix":"Référence de l'API de configuration des modules du framework Gez","description":"Documentation détaillée de l'interface de configuration ModuleConfig du framework Gez, incluant les règles d'import/export de modules, la configuration des alias et la gestion des dépendances externes, pour aider les développeurs à comprendre en profondeur le système de modularité du framework.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, configuration de modules, import/export de modules, dépendances externes, configuration d'alias, gestion des dépendances, framework d'application Web"}]]},"version":""},{"id":81,"title":"PackConfig","content":"#\n\nPackConfig est une interface de configuration de packaging de paquets, utilisée\npour empaqueter les artefacts de construction d'un service dans un format de\npaquet npm standard .tgz.\n\n * Standardisation : Utilisation du format de packaging .tgz standard de npm\n * Intégrité : Inclut tous les fichiers nécessaires tels que le code source du\n   module, les déclarations de types et les fichiers de configuration\n * Compatibilité : Complètement compatible avec l'écosystème npm, supporte les\n   workflows standard de gestion de paquets\n\n\nDéfinition de type#\n\n\n\n\nPackConfig#\n\nenable#\n\nActive ou désactive la fonctionnalité de packaging. Lorsqu'elle est activée, les\nartefacts de construction sont empaquetés dans un format de paquet npm standard\n.tgz.\n\n * Type : boolean\n * Valeur par défaut : false\n\noutputs#\n\nSpécifie le chemin de sortie du fichier de paquet. Supporte les configurations\nsuivantes :\n\n * string : Un seul chemin de sortie, par exemple 'dist/versions/my-app.tgz'\n * string[] : Plusieurs chemins de sortie, pour générer plusieurs versions\n   simultanément\n * boolean : true pour utiliser le chemin par défaut\n   'dist/client/versions/latest.tgz'\n\npackageJson#\n\nFonction de rappel pour personnaliser le contenu de package.json. Appelée avant\nle packaging pour personnaliser le contenu de package.json.\n\n * Paramètres :\n   * gez: Gez - Instance de Gez\n   * pkg: any - Contenu original de package.json\n * Valeur de retour : Promise - Contenu modifié de package.json\n\nUtilisations courantes :\n\n * Modifier le nom et la version du paquet\n * Ajouter ou mettre à jour des dépendances\n * Ajouter des champs personnalisés\n * Configurer les informations de publication\n\nExemple :\n\n\n\nonBefore#\n\nFonction de rappel pour les préparatifs avant le packaging.\n\n * Paramètres :\n   * gez: Gez - Instance de Gez\n   * pkg: Record - Contenu de package.json\n * Valeur de retour : Promise\n\nUtilisations courantes :\n\n * Ajouter des fichiers supplémentaires (README, LICENSE, etc.)\n * Exécuter des tests ou des validations de construction\n * Générer de la documentation ou des métadonnées\n * Nettoyer les fichiers temporaires\n\nExemple :\n\n\n\nonAfter#\n\nFonction de rappel pour le traitement après le packaging. Appelée après la\ngénération du fichier .tgz, pour traiter les artefacts de packaging.\n\n * Paramètres :\n   * gez: Gez - Instance de Gez\n   * pkg: Record - Contenu de package.json\n   * file: Buffer - Contenu du fichier empaqueté\n * Valeur de retour : Promise\n\nUtilisations courantes :\n\n * Publier sur un registre npm (public ou privé)\n * Téléverser sur un serveur de ressources statiques\n * Gérer les versions\n * Déclencher des processus CI/CD\n\nExemple :\n\n\n\n\nExemple d'utilisation#\n\n","routePath":"/fr/api/core/pack-config","lang":"fr","toc":[{"text":"Définition de type","id":"définition-de-type","depth":2,"charIndex":537},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":574},{"text":"outputs","id":"outputs","depth":4,"charIndex":799},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":1161},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1687},{"text":"onAfter","id":"onafter","depth":4,"charIndex":2129},{"text":"Exemple d'utilisation","id":"exemple-dutilisation","depth":2,"charIndex":2654}],"domain":"","frontmatter":{"titleSuffix":"Référence de l'API de configuration de packaging du framework Gez","description":"Documentation détaillée de l'interface de configuration PackConfig du framework Gez, incluant les règles de packaging des paquets, la configuration de sortie et les hooks de cycle de vie, pour aider les développeurs à mettre en œuvre des processus de construction standardisés.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, packaging de paquets, configuration de build, hooks de cycle de vie, configuration de packaging, framework d'application Web"}]]},"version":""},{"id":82,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/fr/api/core/render-context","lang":"fr","toc":[{"text":"Définitions de types","id":"définitions-de-types","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Options d'instance","id":"options-dinstance","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Propriétés d'instance","id":"propriétés-dinstance","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Méthodes d'instance","id":"méthodes-dinstance","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1},{"text":"importmap()","id":"importmap","depth":3,"charIndex":-1},{"text":"moduleEntry()","id":"moduleentry","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Référence de l'API du contexte de rendu du framework Gez","description":"Documentation détaillée de la classe principale RenderContext du framework Gez, incluant le contrôle du rendu, la gestion des ressources, la synchronisation des états et le contrôle du routage, pour aider les développeurs à implémenter un rendu côté serveur efficace.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, rendu côté serveur, contexte de rendu, synchronisation des états, gestion des ressources, framework d'application Web"}]]},"version":""},{"id":83,"title":"Du partage de composants à la modularité native : L'évolution du framework de micro-frontends Gez","content":"Du partage de composants à la modularité native : L'évolution du framework de\nmicro-frontends Gez#\n\n\nContexte du projet#\n\nAu cours des dernières années, l'architecture des micro-frontends a cherché à\ntrouver la bonne voie. Cependant, nous avons été témoins de diverses solutions\ntechniques complexes qui, à travers des couches d'emballage et d'isolation\nartificielle, tentent de simuler un monde idéal de micro-frontends. Ces\nsolutions ont entraîné une lourde charge de performance, rendant le\ndéveloppement simple complexe et les processus standard obscurs.\n\n\nLimites des solutions traditionnelles#\n\nDans la pratique de l'architecture des micro-frontends, nous avons profondément\nressenti les nombreuses limitations des solutions traditionnelles :\n\n * Perte de performance : L'injection de dépendances à l'exécution, le proxy du\n   bac à sable JS, chaque opération consomme des performances précieuses.\n * Isolation fragile : L'environnement de bac à sable artificiellement créé ne\n   peut jamais atteindre la capacité d'isolation native du navigateur.\n * Complexité de construction : Pour gérer les relations de dépendance, il a\n   fallu modifier les outils de construction, rendant les projets simples\n   difficiles à maintenir.\n * Règles de personnalisation : Les stratégies de déploiement spéciales, le\n   traitement à l'exécution, chaque étape s'écarte des processus de\n   développement modernes standard.\n * Limites de l'écosystème : Le couplage des frameworks, les API personnalisées,\n   forcent le choix technologique à se lier à un écosystème spécifique.\n\nCes problèmes ont été particulièrement évidents dans un projet d'entreprise en\n2019. À l'époque, un grand produit a été divisé en une dizaine de sous-systèmes\nmétiers indépendants, qui devaient partager un ensemble de composants de base et\nde composants métiers. La solution initiale de partage de composants basée sur\ndes paquets npm a révélé de graves problèmes d'efficacité de maintenance :\nlorsque les composants partagés étaient mis à jour, tous les sous-systèmes\ndépendant de ces composants devaient subir un processus complet de construction\net de déploiement.\n\n\nÉvolution technique#\n\n\nv1.0 : Exploration des composants distants#\n\nPour résoudre le problème d'efficacité du partage de composants, Gez v1.0 a\nintroduit un mécanisme de composants RemoteView basé sur le protocole HTTP.\nCette solution a permis l'assemblage à la demande du code entre les services via\ndes requêtes dynamiques à l'exécution, résolvant ainsi le problème de la chaîne\nde dépendances de construction trop longue. Cependant, en raison du manque de\nmécanisme de communication standardisé à l'exécution, la synchronisation des\nétats et la transmission des événements entre les services restaient\ninefficaces.\n\n\nv2.0 : Tentative de Module Federation#\n\nDans la version v2.0, nous avons adopté la technologie de Module Federation de\nWebpack 5.0. Cette technologie, grâce à un mécanisme de chargement de modules\nunifié et à un conteneur d'exécution, a considérablement amélioré l'efficacité\nde la collaboration entre les services. Cependant, dans la pratique à grande\néchelle, le mécanisme de mise en œuvre fermé de Module Federation a posé de\nnouveaux défis : il était difficile de gérer précisément les versions des\ndépendances, en particulier lors de l'unification des dépendances partagées\nentre plusieurs services, où des conflits de version et des anomalies\nd'exécution étaient fréquents.\n\n\nEmbrasser l'ère nouvelle de l'ESM#\n\nLors de la planification de la version v3.0, nous avons observé en profondeur\nles tendances de développement de l'écosystème frontend et constaté que les\nprogrès des capacités natives des navigateurs offraient de nouvelles\npossibilités pour l'architecture des micro-frontends :\n\n\nSystème de modules standardisé#\n\nAvec le support complet des ES Modules par les principaux navigateurs et la\nmaturité de la spécification Import Maps, le développement frontend est entré\ndans une véritable ère de modularité. Selon les statistiques de Can I Use, le\ntaux de support natif de l'ESM par les principaux navigateurs (Chrome >= 89,\nEdge >= 89, Firefox >= 108, Safari >= 16.4) a atteint 93.5%, ce qui nous offre\nles avantages suivants :\n\n * Gestion des dépendances standardisée : Import Maps fournit la capacité de\n   résolution des dépendances de modules au niveau du navigateur, sans injection\n   complexe à l'exécution.\n * Optimisation du chargement des ressources : Le mécanisme de cache natif des\n   modules du navigateur améliore considérablement l'efficacité du chargement\n   des ressources.\n * Simplification du processus de construction : Le mode de développement basé\n   sur ESM rend les processus de construction des environnements de\n   développement et de production plus cohérents.\n\nEn outre, grâce au support du mode de compatibilité (Chrome >= 87, Edge >= 88,\nFirefox >= 78, Safari >= 14), nous pouvons augmenter encore la couverture des\nnavigateurs à 96.81%, ce qui nous permet de maintenir des performances élevées\ntout en ne sacrifiant pas le support des anciens navigateurs.\n\n\nPercées en matière de performance et d'isolation#\n\nLe système de modules natif apporte non seulement la standardisation, mais aussi\nune amélioration qualitative de la performance et de l'isolation :\n\n * Aucun surcoût à l'exécution : Adieu au proxy de bac à sable JavaScript et à\n   l'injection à l'exécution des solutions traditionnelles de micro-frontends.\n * Mécanisme d'isolation fiable : La portée stricte des modules ESM fournit\n   naturellement la capacité d'isolation la plus fiable.\n * Gestion précise des dépendances : L'analyse statique des importations rend\n   les relations de dépendance plus claires et le contrôle des versions plus\n   précis.\n\n\nChoix des outils de construction#\n\nDans la mise en œuvre de la solution technique, le choix des outils de\nconstruction a été un point de décision clé. Après près d'un an de recherche\ntechnique et de pratique, notre choix a évolué comme suit :\n\n 1. Exploration de Vite\n    \n    * Avantage : Serveur de développement basé sur ESM, offrant une expérience\n      de développement ultime.\n    * Défi : Les différences de construction entre les environnements de\n      développement et de production introduisent une certaine incertitude.\n\n 2. Établissement de Rspack\n    \n    * Avantage de performance : Compilation haute performance basée sur Rust,\n      améliorant considérablement la vitesse de construction.\n    * Support de l'écosystème : Haute compatibilité avec l'écosystème Webpack,\n      réduisant les coûts de migration.\n    * Support ESM : La pratique du projet Rslib a validé sa fiabilité dans la\n      construction ESM.\n\nCette décision nous a permis de maintenir une expérience de développement tout\nen obtenant un support plus stable pour l'environnement de production. Basé sur\nla combinaison d'ESM et de Rspack, nous avons finalement construit une solution\nde micro-frontends haute performance et peu intrusive.\n\n\nPerspectives futures#\n\nDans le plan de développement futur, le framework Gez se concentrera sur les\ntrois directions suivantes :\n\n\nOptimisation approfondie d'Import Maps#\n\n * Gestion dynamique des dépendances : Mise en œuvre d'une planification\n   intelligente des versions des dépendances à l'exécution, résolvant les\n   conflits de dépendances entre plusieurs applications.\n * Stratégie de préchargement : Préchargement intelligent basé sur l'analyse des\n   routes, améliorant l'efficacité du chargement des ressources.\n * Optimisation de la construction : Génération automatique de la configuration\n   optimale d'Import Maps, réduisant les coûts de configuration manuelle pour\n   les développeurs.\n\n\nSolution de routage indépendante du framework#\n\n * Abstraction de routage unifiée : Conception d'une interface de routage\n   indépendante du framework, supportant Vue, React et d'autres frameworks\n   populaires.\n * Routage des micro-applications : Mise en œuvre de l'interaction des routes\n   entre les applications, maintenant la cohérence entre l'URL et l'état de\n   l'application.\n * Middleware de routage : Fourniture d'un mécanisme de middleware extensible,\n   supportant le contrôle des permissions, les transitions de page, etc.\n\n\nMeilleures pratiques de communication inter-frameworks#\n\n * Application exemple : Fourniture d'un exemple complet de communication\n   inter-frameworks, couvrant Vue, React, Preact et d'autres frameworks\n   populaires.\n * Synchronisation des états : Solution légère de partage d'état basée sur ESM.\n * Bus d'événements : Mécanisme de communication d'événements standardisé,\n   supportant la communication découplée entre les applications.\n\nGrâce à ces optimisations et extensions, nous espérons faire de Gez une solution\nde micro-frontends plus complète et facile à utiliser, offrant aux développeurs\nune meilleure expérience de développement et une efficacité accrue.","routePath":"/fr/blog/birth-of-gez","lang":"fr","toc":[{"text":"Contexte du projet","id":"contexte-du-projet","depth":2,"charIndex":100},{"text":"Limites des solutions traditionnelles","id":"limites-des-solutions-traditionnelles","depth":3,"charIndex":560},{"text":"Évolution technique","id":"évolution-technique","depth":2,"charIndex":2135},{"text":"v1.0 : Exploration des composants distants","id":"v10--exploration-des-composants-distants","depth":3,"charIndex":2158},{"text":"v2.0 : Tentative de Module Federation","id":"v20--tentative-de-module-federation","depth":3,"charIndex":2755},{"text":"Embrasser l'ère nouvelle de l'ESM","id":"embrasser-lère-nouvelle-de-lesm","depth":2,"charIndex":3437},{"text":"Système de modules standardisé","id":"système-de-modules-standardisé","depth":3,"charIndex":3753},{"text":"Percées en matière de performance et d'isolation","id":"percées-en-matière-de-performance-et-disolation","depth":3,"charIndex":5059},{"text":"Choix des outils de construction","id":"choix-des-outils-de-construction","depth":3,"charIndex":5718},{"text":"Perspectives futures","id":"perspectives-futures","depth":2,"charIndex":6942},{"text":"Optimisation approfondie d'Import Maps","id":"optimisation-approfondie-dimport-maps","depth":3,"charIndex":7073},{"text":"Solution de routage indépendante du framework","id":"solution-de-routage-indépendante-du-framework","depth":3,"charIndex":7645},{"text":"Meilleures pratiques de communication inter-frameworks","id":"meilleures-pratiques-de-communication-inter-frameworks","depth":3,"charIndex":8183}],"domain":"","frontmatter":{"titleSuffix":"Des défis des micro-frontends à l'innovation ESM : L'évolution du framework Gez","description":"Une exploration approfondie de l'évolution du framework Gez, des défis de l'architecture traditionnelle des micro-frontends aux innovations basées sur ESM, partageant les expériences techniques en matière d'optimisation des performances, de gestion des dépendances et de choix d'outils de construction.","head":[["meta",{"property":"keywords","content":"Gez, framework de micro-frontends, ESM, Import Maps, Rspack, Module Federation, gestion des dépendances, optimisation des performances, évolution technique, rendu côté serveur"}]],"sidebar":false},"version":""},{"id":84,"title":"Blog de l'équipe","content":"#\n\nBienvenue sur le blog technique de l'équipe Gez ! Ici, nous partagerons nos\nexpériences de développement de frameworks, nos innovations technologiques et\nnos meilleures pratiques.\n\n\nArticles récents#\n\n * 2025-02-25 Du partage de composants à la modularité native : l'évolution du\n   framework micro-frontend Gez\n   \n   > Explorez l'évolution du framework Gez, du partage traditionnel de\n   > composants à la modularité native basée sur ESM. Partage d'expériences\n   > techniques sur l'optimisation des performances, la gestion des dépendances\n   > et le choix des outils de build.","routePath":"/fr/blog/","lang":"fr","toc":[{"text":"Articles récents","id":"articles-récents","depth":2,"charIndex":184}],"domain":"","frontmatter":{"titleSuffix":"Blog de l'équipe Gez","description":"Blog technique de l'équipe Gez, partage d'expériences de développement de frameworks, meilleures pratiques et innovations technologiques.","head":[["meta",{"property":"keywords","content":"Gez, blog d'équipe, partage technique, meilleures pratiques, expérience de développement"}]],"sidebar":false},"version":""},{"id":85,"title":"Alias de chemin","content":"#\n\nL'alias de chemin (Path Alias) est un mécanisme de mappage des chemins\nd'importation des modules qui permet aux développeurs d'utiliser des\nidentifiants courts et sémantiques pour remplacer les chemins de module\ncomplets. Dans Gez, le mécanisme d'alias de chemin offre les avantages suivants\n:\n\n * Simplification des chemins d'importation : Utilisation d'alias sémantiques\n   pour remplacer les chemins relatifs longs, améliorant la lisibilité du code\n * Évitement des imbrications profondes : Élimination des difficultés de\n   maintenance causées par les références à des répertoires multi-niveaux (par\n   exemple ../../../../)\n * Sécurité des types : Intégration complète avec le système de types de\n   TypeScript, fournissant la complétion de code et la vérification des types\n * Optimisation de la résolution des modules : Amélioration des performances de\n   résolution des modules grâce à des mappages de chemins prédéfinis\n\n\nMécanisme d'alias par défaut#\n\nGez utilise un mécanisme d'alias automatique basé sur le nom du service (Service\nName). Cette conception basée sur des conventions plutôt que sur la\nconfiguration présente les caractéristiques suivantes :\n\n * Configuration automatique : Génération automatique d'alias basée sur le champ\n   name dans package.json, sans configuration manuelle\n * Uniformité des normes : Assure que tous les modules de service suivent une\n   norme de nommage et de référence cohérente\n * Support des types : En combinaison avec la commande npm run build:dts, génère\n   automatiquement des fichiers de déclaration de types, permettant une\n   inférence de types entre services\n * Prédictibilité : Permet de déduire le chemin de référence d'un module à\n   partir du nom du service, réduisant les coûts de maintenance\n\n\nConfiguration#\n\n\nConfiguration de package.json#\n\nDans package.json, définissez le nom du service via le champ name. Ce nom\nservira de préfixe d'alias par défaut pour le service :\n\n\n\n\nConfiguration de tsconfig.json#\n\nPour que TypeScript puisse correctement résoudre les chemins d'alias, il est\nnécessaire de configurer le mappage paths dans tsconfig.json :\n\n\n\n\nExemples d'utilisation#\n\n\nImportation de modules internes au service#\n\n\n\n\nImportation de modules d'autres services#\n\n\n\nBonnes pratiques\n * Privilégiez les chemins d'alias plutôt que les chemins relatifs\n * Maintenez la sémantique et la cohérence des chemins d'alias\n * Évitez d'utiliser trop de niveaux de répertoires dans les chemins d'alias\n\n\n\n\nImportation inter-services#\n\nLorsque la liaison de modules (Module Link) est configurée, vous pouvez importer\ndes modules d'autres services de la même manière :\n\n\n\n\nAlias personnalisés#\n\nPour les packages tiers ou des scénarios spécifiques, vous pouvez personnaliser\nles alias via le fichier de configuration de Gez :\n\n\n\nRemarques\n 1. Pour les modules métier, il est recommandé de toujours utiliser le mécanisme\n    d'alias par défaut pour maintenir la cohérence du projet\n 2. Les alias personnalisés sont principalement utilisés pour gérer des besoins\n    spécifiques de packages tiers ou pour optimiser l'expérience de\n    développement\n 3. Une utilisation excessive d'alias personnalisés peut affecter la\n    maintenabilité du code et l'optimisation de la construction","routePath":"/fr/guide/essentials/alias","lang":"fr","toc":[{"text":"Mécanisme d'alias par défaut","id":"mécanisme-dalias-par-défaut","depth":2,"charIndex":933},{"text":"Configuration","id":"configuration","depth":2,"charIndex":1761},{"text":"Configuration de package.json","id":"configuration-de-packagejson","depth":3,"charIndex":1778},{"text":"Configuration de tsconfig.json","id":"configuration-de-tsconfigjson","depth":3,"charIndex":1944},{"text":"Exemples d'utilisation","id":"exemples-dutilisation","depth":2,"charIndex":2121},{"text":"Importation de modules internes au service","id":"importation-de-modules-internes-au-service","depth":3,"charIndex":2147},{"text":"Importation de modules d'autres services","id":"importation-de-modules-dautres-services","depth":3,"charIndex":2195},{"text":"Importation inter-services","id":"importation-inter-services","depth":3,"charIndex":2468},{"text":"Alias personnalisés","id":"alias-personnalisés","depth":3,"charIndex":2633}],"domain":"","frontmatter":{"titleSuffix":"Guide de mappage des chemins d'importation des modules du framework Gez","description":"Détaille le mécanisme d'alias de chemin du framework Gez, y compris la simplification des chemins d'importation, l'évitement des imbrications profondes, la sécurité des types et l'optimisation de la résolution des modules, aidant les développeurs à améliorer la maintenabilité du code.","head":[["meta",{"property":"keywords","content":"Gez, Alias de chemin, Path Alias, TypeScript, Importation de modules, Mappage de chemin, Maintenabilité du code"}]]},"version":""},{"id":86,"title":"Chemin de base","content":"#\n\nLe chemin de base (Base Path) est le préfixe du chemin d'accès aux ressources\nstatiques (comme JavaScript, CSS, images, etc.) dans une application. Dans Gez,\nune configuration appropriée du chemin de base est cruciale pour les scénarios\nsuivants :\n\n * Déploiement multi-environnements : supporte l'accès aux ressources dans\n   différents environnements tels que développement, test et production\n * Déploiement multi-régions : s'adapte aux besoins de déploiement en cluster\n   dans différentes régions ou pays\n * Distribution CDN : permet la distribution et l'accélération globales des\n   ressources statiques\n\n\nMécanisme de chemin par défaut#\n\nGez utilise un mécanisme de génération automatique de chemin basé sur le nom du\nservice. Par défaut, le framework lit le champ name du fichier package.json du\nprojet pour générer le chemin de base des ressources statiques :\n/your-app-name/.\n\n\n\nCette conception basée sur la convention plutôt que la configuration présente\nles avantages suivants :\n\n * Cohérence : garantit que toutes les ressources statiques utilisent un chemin\n   d'accès uniforme\n * Prédictibilité : permet de déduire le chemin d'accès des ressources à partir\n   du champ name du fichier package.json\n * Maintenabilité : ne nécessite aucune configuration supplémentaire, réduisant\n   les coûts de maintenance\n\n\nConfiguration dynamique du chemin#\n\nDans les projets réels, nous devons souvent déployer le même code dans\ndifférents environnements ou régions. Gez offre un support pour les chemins de\nbase dynamiques, permettant à l'application de s'adapter à différents scénarios\nde déploiement.\n\n\nCas d'utilisation#\n\nDéploiement dans un sous-répertoire#\n\n\n\nDéploiement sur des domaines indépendants#\n\n\n\n\nMéthode de configuration#\n\nGrâce au paramètre base de la méthode gez.render(), vous pouvez définir\ndynamiquement le chemin de base en fonction du contexte de la requête :\n\n","routePath":"/fr/guide/essentials/base-path","lang":"fr","toc":[{"text":"Mécanisme de chemin par défaut","id":"mécanisme-de-chemin-par-défaut","depth":2,"charIndex":614},{"text":"Configuration dynamique du chemin","id":"configuration-dynamique-du-chemin","depth":2,"charIndex":1326},{"text":"Cas d'utilisation","id":"cas-dutilisation","depth":3,"charIndex":1610},{"text":"Déploiement dans un sous-répertoire","id":"déploiement-dans-un-sous-répertoire","depth":4,"charIndex":1630},{"text":"Déploiement sur des domaines indépendants","id":"déploiement-sur-des-domaines-indépendants","depth":4,"charIndex":1670},{"text":"Méthode de configuration","id":"méthode-de-configuration","depth":3,"charIndex":1717}],"domain":"","frontmatter":{"titleSuffix":"Guide de configuration des chemins des ressources statiques dans le framework Gez","description":"Détaille la configuration du chemin de base dans le framework Gez, y compris le déploiement multi-environnements, la distribution CDN et la configuration des chemins d'accès aux ressources, aidant les développeurs à gérer de manière flexible les ressources statiques.","head":[["meta",{"property":"keywords","content":"Gez, chemin de base, Base Path, CDN, ressources statiques, déploiement multi-environnements, gestion des ressources"}]]},"version":""},{"id":87,"title":"Rendu côté client","content":"\n${rc.importmap()} // Mappage des imports ${rc.moduleEntry()} // Module d'entrée\n${rc.modulePreload()} // Préchargement des modules","routePath":"/fr/guide/essentials/csr","lang":"fr","toc":[{"text":"Cas d'utilisation","id":"cas-dutilisation","depth":2,"charIndex":-1},{"text":"Configuration","id":"configuration","depth":2,"charIndex":-1},{"text":"Configuration du modèle HTML","id":"configuration-du-modèle-html","depth":3,"charIndex":-1},{"text":"Génération de HTML statique","id":"génération-de-html-statique","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Guide d'implémentation du rendu côté client avec le framework Gez","description":"Détaille le mécanisme de rendu côté client du framework Gez, incluant la construction statique, les stratégies de déploiement et les meilleures pratiques, pour aider les développeurs à réaliser un rendu front-end efficace dans un environnement sans serveur.","head":[["meta",{"property":"keywords","content":"Gez, rendu côté client, CSR, construction statique, rendu front-end, déploiement sans serveur, optimisation des performances"}]]},"version":""},{"id":88,"title":"Liaison de modules","content":"#\n\nLe framework Gez fournit un mécanisme complet de liaison de modules pour gérer\nle partage de code et les relations de dépendance entre services. Ce mécanisme\nest basé sur la spécification ESM (ECMAScript Module) et prend en charge\nl'exportation et l'importation de modules au niveau du code source, ainsi qu'une\ngestion complète des dépendances.\n\n\nConcepts clés#\n\nExportation de modules#\n\nL'exportation de modules est le processus d'exposition d'unités de code\nspécifiques (comme des composants, des fonctions utilitaires, etc.) d'un service\nau format ESM. Deux types d'exportation sont pris en charge :\n\n * Exportation de code source : Exportation directe des fichiers de code source\n   du projet\n * Exportation de dépendances : Exportation des packages de dépendances tiers\n   utilisés par le projet\n\nImportation de modules#\n\nL'importation de modules est le processus de référencement d'unités de code\nexportées par d'autres services dans un service. Plusieurs méthodes\nd'installation sont prises en charge :\n\n * Installation de code source : Adaptée à l'environnement de développement,\n   prend en charge les modifications en temps réel et la mise à jour à chaud\n * Installation de package : Adaptée à l'environnement de production, utilise\n   directement les artefacts de construction\n\n\nMécanisme de préchargement#\n\nPour optimiser les performances des services, Gez implémente un mécanisme\nintelligent de préchargement de modules :\n\n 1. Analyse des dépendances\n    \n    * Analyse des relations de dépendance entre les composants lors de la\n      construction\n    * Identification des modules critiques sur le chemin critique\n    * Détermination de la priorité de chargement des modules\n\n 2. Stratégie de chargement\n    \n    * Chargement immédiat : Modules critiques sur le chemin critique\n    * Chargement différé : Modules de fonctionnalités non critiques\n    * Chargement à la demande : Modules rendus conditionnellement\n\n 3. Optimisation des ressources\n    \n    * Stratégie intelligente de découpage de code\n    * Gestion du cache au niveau des modules\n    * Compilation et packaging à la demande\n\n\nExportation de modules#\n\n\nConfiguration#\n\nConfigurez les modules à exporter dans entry.node.ts :\n\n\n\nLa configuration d'exportation prend en charge deux types :\n\n * root:* : Exporter des fichiers de code source, chemin relatif à la racine du\n   projet\n * npm:* : Exporter des dépendances tierces, spécifiez directement le nom du\n   package\n\n\nImportation de modules#\n\n\nConfiguration#\n\nConfigurez les modules à importer dans entry.node.ts :\n\n\n\nExplication des options de configuration :\n\n 1. imports : Configure le chemin local des modules distants\n    \n    * Installation de code source : pointe vers le répertoire des artefacts de\n      construction (dist)\n    * Installation de package : pointe directement vers le répertoire du package\n\n 2. externals : Configure les dépendances externes\n    \n    * Utilisé pour partager les dépendances des modules distants\n    * Évite de packager plusieurs fois les mêmes dépendances\n    * Prend en charge le partage de dépendances entre plusieurs modules\n\n\nMéthodes d'installation#\n\nInstallation de code source#\n\nAdaptée à l'environnement de développement, prend en charge les modifications en\ntemps réel et la mise à jour à chaud.\n\n 1. Méthode Workspace Recommandé pour les projets Monorepo :\n\n\n\n 2. Méthode Link Utilisée pour le débogage local :\n\n\n\nInstallation de package#\n\nAdaptée à l'environnement de production, utilise directement les artefacts de\nconstruction.\n\n 1. NPM Registry Installation via npm registry :\n\n\n\n 2. Serveur statique Installation via le protocole HTTP/HTTPS :\n\n\n\n\nConstruction de packages#\n\n\nConfiguration#\n\nConfigurez les options de construction dans entry.node.ts :\n\n\n\n\nArtéfacts de construction#\n\n\n\n\nProcessus de publication#\n\n\n\n\nBonnes pratiques#\n\n\nConfiguration de l'environnement de développement#\n\n * Gestion des dépendances\n   \n   * Utiliser la méthode Workspace ou Link pour installer les dépendances\n   * Gérer uniformément les versions des dépendances\n   * Éviter d'installer plusieurs fois les mêmes dépendances\n\n * Expérience de développement\n   \n   * Activer la fonctionnalité de mise à jour à chaud\n   * Configurer une stratégie de préchargement appropriée\n   * Optimiser la vitesse de construction\n\n\nConfiguration de l'environnement de production#\n\n * Stratégie de déploiement\n   \n   * Utiliser NPM Registry ou un serveur statique\n   * Assurer l'intégrité des artefacts de construction\n   * Mettre en œuvre un mécanisme de déploiement progressif\n\n * Optimisation des performances\n   \n   * Configurer judicieusement le préchargement des ressources\n   * Optimiser l'ordre de chargement des modules\n   * Mettre en œuvre une stratégie de cache efficace\n\n\nGestion des versions#\n\n * Conventions de version\n   \n   * Suivre les conventions de version sémantique\n   * Maintenir un journal de modifications détaillé\n   * Effectuer des tests de compatibilité des versions\n\n * Mise à jour des dépendances\n   \n   * Mettre à jour régulièrement les packages de dépendances\n   * Effectuer des audits de sécurité réguliers\n   * Maintenir la cohérence des versions des dépendances\n\n","routePath":"/fr/guide/essentials/module-link","lang":"fr","toc":[{"text":"Concepts clés","id":"concepts-clés","depth":3,"charIndex":350},{"text":"Exportation de modules","id":"exportation-de-modules","depth":4,"charIndex":366},{"text":"Importation de modules","id":"importation-de-modules","depth":4,"charIndex":805},{"text":"Mécanisme de préchargement","id":"mécanisme-de-préchargement","depth":3,"charIndex":1293},{"text":"Exportation de modules","id":"exportation-de-modules-1","depth":2,"charIndex":2108},{"text":"Configuration","id":"configuration","depth":3,"charIndex":2134},{"text":"Importation de modules","id":"importation-de-modules-1","depth":2,"charIndex":2449},{"text":"Configuration","id":"configuration-1","depth":3,"charIndex":2475},{"text":"Méthodes d'installation","id":"méthodes-dinstallation","depth":3,"charIndex":3102},{"text":"Installation de code source","id":"installation-de-code-source","depth":4,"charIndex":3128},{"text":"Installation de package","id":"installation-de-package","depth":4,"charIndex":3396},{"text":"Construction de packages","id":"construction-de-packages","depth":2,"charIndex":3635},{"text":"Configuration","id":"configuration-2","depth":3,"charIndex":3663},{"text":"Artéfacts de construction","id":"artéfacts-de-construction","depth":3,"charIndex":3743},{"text":"Processus de publication","id":"processus-de-publication","depth":3,"charIndex":3774},{"text":"Bonnes pratiques","id":"bonnes-pratiques","depth":2,"charIndex":3804},{"text":"Configuration de l'environnement de développement","id":"configuration-de-lenvironnement-de-développement","depth":3,"charIndex":3824},{"text":"Configuration de l'environnement de production","id":"configuration-de-lenvironnement-de-production","depth":3,"charIndex":4287},{"text":"Gestion des versions","id":"gestion-des-versions","depth":3,"charIndex":4738}],"domain":"","frontmatter":{"titleSuffix":"Mécanisme de partage de code entre services dans le framework Gez","description":"Détails sur le mécanisme de liaison de modules dans le framework Gez, y compris le partage de code entre services, la gestion des dépendances et l'implémentation de la spécification ESM, aidant les développeurs à construire des applications micro-frontales efficaces.","head":[["meta",{"property":"keywords","content":"Gez, Liaison de modules, Module Link, ESM, Partage de code, Gestion des dépendances, Micro-frontend"}]]},"version":""},{"id":89,"title":"Contexte de rendu","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/fr/guide/essentials/render-context","lang":"fr","toc":[{"text":"Mode d'utilisation","id":"mode-dutilisation","depth":2,"charIndex":-1},{"text":"Fonctionnalités principales","id":"fonctionnalités-principales","depth":2,"charIndex":-1},{"text":"Collecte des dépendances","id":"collecte-des-dépendances","depth":3,"charIndex":-1},{"text":"Collecte à la demande","id":"collecte-à-la-demande","depth":4,"charIndex":-1},{"text":"Traitement automatisé","id":"traitement-automatisé","depth":4,"charIndex":-1},{"text":"Optimisation des performances","id":"optimisation-des-performances","depth":4,"charIndex":-1},{"text":"Injection des ressources","id":"injection-des-ressources","depth":3,"charIndex":-1},{"text":"Ordre d'injection des ressources","id":"ordre-dinjection-des-ressources","depth":3,"charIndex":-1},{"text":"Processus de rendu complet","id":"processus-de-rendu-complet","depth":2,"charIndex":-1},{"text":"Fonctionnalités avancées","id":"fonctionnalités-avancées","depth":2,"charIndex":-1},{"text":"Configuration du chemin de base","id":"configuration-du-chemin-de-base","depth":3,"charIndex":-1},{"text":"Modes de mappage d'importation","id":"modes-de-mappage-dimportation","depth":3,"charIndex":-1},{"text":"Configuration de la fonction d'entrée","id":"configuration-de-la-fonction-dentrée","depth":3,"charIndex":-1},{"text":"Bonnes pratiques","id":"bonnes-pratiques","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Mécanisme de rendu côté serveur du framework Gez","description":"Détails sur le mécanisme de contexte de rendu (RenderContext) du framework Gez, incluant la gestion des ressources, la génération de HTML et le système de modules ESM, pour aider les développeurs à comprendre et utiliser la fonctionnalité de rendu côté serveur.","head":[["meta",{"property":"keywords","content":"Gez, contexte de rendu, RenderContext, SSR, rendu côté serveur, ESM, gestion des ressources"}]]},"version":""},{"id":90,"title":"Rspack","content":"#\n\nGez est basé sur le système de construction Rspack, exploitant pleinement les\ncapacités de construction haute performance de Rspack. Ce document présente le\npositionnement et les fonctionnalités clés de Rspack dans le framework Gez.\n\n\nFonctionnalités#\n\nRspack est le système de construction central du framework Gez, offrant les\nfonctionnalités clés suivantes :\n\n * Construction haute performance : Moteur de construction implémenté en Rust,\n   offrant des performances de compilation extrêmement rapides, améliorant\n   significativement la vitesse de construction des projets de grande envergure.\n * Optimisation de l'expérience de développement : Prend en charge des\n   fonctionnalités modernes de développement telles que la mise à jour à chaud\n   (HMR) et la compilation incrémentale, offrant une expérience de développement\n   fluide.\n * Construction multi-environnements : Configuration de construction unifiée\n   prenant en charge les environnements client (client), serveur (server) et\n   Node.js (node), simplifiant le processus de développement multi-plateformes.\n * Optimisation des ressources : Capacités intégrées de traitement et\n   d'optimisation des ressources, prenant en charge le découpage de code, Tree\n   Shaking, la compression des ressources, etc.\n\n\nConstruction d'applications#\n\nLe système de construction Rspack de Gez est conçu de manière modulaire,\ncomprenant principalement les modules suivants :\n\n\n@gez/rspack#\n\nModule de construction de base, offrant les capacités suivantes :\n\n * Configuration de construction unifiée : Fournit une gestion standardisée de\n   la configuration de construction, prenant en charge les configurations\n   multi-environnements.\n * Traitement des ressources : Capacités intégrées de traitement des ressources\n   telles que TypeScript, CSS, images, etc.\n * Optimisation de la construction : Fournit des fonctionnalités d'optimisation\n   des performances telles que le découpage de code et Tree Shaking.\n * Serveur de développement : Intègre un serveur de développement haute\n   performance, prenant en charge HMR.\n\n\n@gez/rspack-vue#\n\nModule de construction dédié au framework Vue, offrant :\n\n * Compilation des composants Vue : Prend en charge la compilation efficace des\n   composants Vue 2/3.\n * Optimisation SSR : Optimisations spécifiques pour les scénarios de rendu côté\n   serveur.\n * Améliorations du développement : Fonctionnalités spécifiques pour\n   l'environnement de développement Vue.\n\n\nProcessus de construction#\n\nLe processus de construction de Gez se décompose principalement en les étapes\nsuivantes :\n\n 1. Initialisation de la configuration\n    \n    * Chargement de la configuration du projet\n    * Fusion des configurations par défaut et utilisateur\n    * Ajustement de la configuration en fonction des variables d'environnement\n\n 2. Compilation des ressources\n    \n    * Analyse des dépendances du code source\n    * Transformation des différentes ressources (TypeScript, CSS, etc.)\n    * Gestion des importations et exportations de modules\n\n 3. Traitement d'optimisation\n    \n    * Exécution du découpage de code\n    * Application de Tree Shaking\n    * Compression du code et des ressources\n\n 4. Génération de la sortie\n    \n    * Génération des fichiers cibles\n    * Sortie des mappages de ressources\n    * Génération du rapport de construction\n\n\nBonnes pratiques#\n\n\nOptimisation de l'environnement de développement#\n\n * Configuration de la compilation incrémentale : Configurer correctement\n   l'option cache pour accélérer la vitesse de construction grâce au cache.\n * Optimisation HMR : Configurer de manière ciblée la portée de la mise à jour à\n   chaud pour éviter les mises à jour inutiles de modules.\n * Optimisation du traitement des ressources : Utiliser des configurations de\n   loader appropriées pour éviter les traitements répétés.\n\n\nOptimisation de l'environnement de production#\n\n * Stratégie de découpage de code : Configurer correctement splitChunks pour\n   optimiser le chargement des ressources.\n * Compression des ressources : Activer des configurations de compression\n   appropriées pour équilibrer le temps de construction et la taille des\n   artefacts.\n * Optimisation du cache : Utiliser des stratégies de hachage de contenu et de\n   cache à long terme pour améliorer les performances de chargement.\n\n\nExemple de configuration#\n\n\n\nTIP\n\nPour plus de détails sur les API et les options de configuration, veuillez\nconsulter la documentation de l'API Rspack.","routePath":"/fr/guide/essentials/rspack","lang":"fr","toc":[{"text":"Fonctionnalités","id":"fonctionnalités","depth":2,"charIndex":237},{"text":"Construction d'applications","id":"construction-dapplications","depth":2,"charIndex":1275},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1429},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":2074},{"text":"Processus de construction","id":"processus-de-construction","depth":2,"charIndex":2458},{"text":"Bonnes pratiques","id":"bonnes-pratiques","depth":2,"charIndex":3325},{"text":"Optimisation de l'environnement de développement","id":"optimisation-de-lenvironnement-de-développement","depth":3,"charIndex":3345},{"text":"Optimisation de l'environnement de production","id":"optimisation-de-lenvironnement-de-production","depth":3,"charIndex":3825},{"text":"Exemple de configuration","id":"exemple-de-configuration","depth":2,"charIndex":4304}],"domain":"","frontmatter":{"titleSuffix":"Moteur de construction haute performance du framework Gez","description":"Une analyse approfondie du système de construction Rspack du framework Gez, incluant des fonctionnalités clés telles que la compilation haute performance, la construction multi-environnements, l'optimisation des ressources, etc., pour aider les développeurs à construire des applications Web modernes efficaces et fiables.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, système de construction, compilation haute performance, mise à jour à chaud, construction multi-environnements, Tree Shaking, découpage de code, SSR, optimisation des ressources, efficacité de développement, outils de construction"}]]},"version":""},{"id":91,"title":"Normes standards","content":"#\n\nGez est un framework SSR moderne qui adopte une structure de projet standardisée\net un mécanisme de résolution de chemins pour garantir la cohérence et la\nmaintenabilité du projet dans les environnements de développement et de\nproduction.\n\n\nNormes de structure de projet#\n\n\nStructure de répertoire standard#\n\n\n\nConnaissances supplémentaires\n * gez.name provient du champ name dans package.json\n * dist/package.json provient du package.json à la racine\n * Le répertoire dist est archivé uniquement lorsque packs.enable est défini sur\n   true\n\n\nNormes des fichiers d'entrée#\n\n\nentry.client.ts#\n\nLe fichier d'entrée client est responsable de :\n\n * Initialisation de l'application : Configuration des paramètres de base de\n   l'application client\n * Gestion des routes : Gestion des routes et de la navigation côté client\n * Gestion d'état : Stockage et mise à jour de l'état côté client\n * Gestion des interactions : Gestion des événements utilisateurs et des\n   interactions de l'interface\n\n\nentry.server.ts#\n\nLe fichier d'entrée serveur est responsable de :\n\n * Rendu côté serveur (SSR) : Exécution du processus de rendu SSR\n * Génération HTML : Construction de la structure initiale de la page\n * Pré-récupération des données : Gestion de la récupération des données côté\n   serveur\n * Injection d'état : Transfert de l'état serveur au client\n * Optimisation SEO : Assurance de l'optimisation pour les moteurs de recherche\n\n\nentry.node.ts#\n\nLe fichier d'entrée du serveur Node.js est responsable de :\n\n * Configuration du serveur : Définition des paramètres du serveur HTTP\n * Gestion des routes : Gestion des règles de routage côté serveur\n * Intégration des middlewares : Configuration des middlewares du serveur\n * Gestion de l'environnement : Gestion des variables d'environnement et des\n   configurations\n * Gestion des requêtes/réponses : Traitement des requêtes et réponses HTTP\n\n\nNormes des fichiers de configuration#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/fr/guide/essentials/std","lang":"fr","toc":[{"text":"Normes de structure de projet","id":"normes-de-structure-de-projet","depth":2,"charIndex":243},{"text":"Structure de répertoire standard","id":"structure-de-répertoire-standard","depth":3,"charIndex":276},{"text":"Normes des fichiers d'entrée","id":"normes-des-fichiers-dentrée","depth":2,"charIndex":545},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":577},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":992},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1427},{"text":"Normes des fichiers de configuration","id":"normes-des-fichiers-de-configuration","depth":2,"charIndex":1890},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1930},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1948}],"domain":"","frontmatter":{"titleSuffix":"Guide de structure et de normes du projet Gez","description":"Détaille la structure standard du projet Gez, les normes des fichiers d'entrée et de configuration, aidant les développeurs à construire des applications SSR normalisées et maintenables.","head":[["meta",{"property":"keywords","content":"Gez, structure de projet, fichier d'entrée, normes de configuration, framework SSR, TypeScript, normes de projet, standards de développement"}]]},"version":""},{"id":92,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/fr/guide/frameworks/html","lang":"fr","toc":[{"text":"Structure du projet","id":"structure-du-projet","depth":2,"charIndex":-1},{"text":"Configuration du projet","id":"configuration-du-projet","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Structure des sources","id":"structure-des-sources","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Exécution du projet","id":"exécution-du-projet","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Exemple d'application HTML SSR avec le framework Gez","description":"Créez une application HTML SSR basée sur Gez à partir de zéro. Ce tutoriel montre les bases du framework à travers un exemple complet, incluant l'initialisation du projet, la configuration HTML et la configuration des fichiers d'entrée.","head":[["meta",{"property":"keywords","content":"Gez, HTML, Application SSR, Configuration TypeScript, Initialisation de projet, Rendu côté serveur, Interaction côté client"}]]},"version":""},{"id":93,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/fr/guide/frameworks/preact-htm","lang":"fr","toc":[{"text":"Structure du projet","id":"structure-du-projet","depth":2,"charIndex":-1},{"text":"Configuration du projet","id":"configuration-du-projet","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Structure du code source","id":"structure-du-code-source","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Exécution du projet","id":"exécution-du-projet","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Exemple d'application SSR Preact+HTM avec le framework Gez","description":"Créez une application SSR Preact+HTM basée sur Gez à partir de zéro. Ce tutoriel vous guide à travers l'initialisation du projet, la configuration de Preact et la mise en place des fichiers d'entrée.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, application SSR, configuration TypeScript, initialisation de projet, rendu côté serveur, interaction côté client"}]]},"version":""},{"id":94,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/fr/guide/frameworks/vue2","lang":"fr","toc":[{"text":"Structure du projet","id":"structure-du-projet","depth":2,"charIndex":-1},{"text":"Configuration du projet","id":"configuration-du-projet","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Structure du code source","id":"structure-du-code-source","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Exécution du projet","id":"exécution-du-projet","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Exemple d'application Vue2 SSR avec le framework Gez","description":"Créez une application Vue2 SSR basée sur Gez à partir de zéro. Ce guide vous montre les bases du framework à travers un exemple complet, incluant l'initialisation du projet, la configuration de Vue2 et la mise en place des fichiers d'entrée.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, Application SSR, Configuration TypeScript, Initialisation de projet, Rendu côté serveur, Interaction côté client"}]]},"version":""},{"id":95,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/fr/guide/frameworks/vue3","lang":"fr","toc":[{"text":"Structure du projet","id":"structure-du-projet","depth":2,"charIndex":-1},{"text":"Configuration du projet","id":"configuration-du-projet","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Structure du code source","id":"structure-du-code-source","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Exécution du projet","id":"exécution-du-projet","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Exemple d'application Vue3 SSR avec le framework Gez","description":"Créez une application Vue3 SSR basée sur Gez à partir de zéro. Ce guide pratique montre les utilisations de base du framework, y compris l'initialisation du projet, la configuration de Vue3 et la configuration des fichiers d'entrée.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, Application SSR, Configuration TypeScript, Initialisation de projet, Rendu côté serveur, Interaction côté client, API de composition"}]]},"version":""},{"id":96,"title":"Exigences environnementales","content":"#\n\nCe document présente les exigences environnementales nécessaires pour utiliser\nce framework, y compris l'environnement Node.js et la compatibilité des\nnavigateurs.\n\n\nEnvironnement Node.js#\n\nLe framework nécessite une version de Node.js >= 22.6, principalement pour\nsupporter l'importation de types TypeScript (via le flag\n--experimental-strip-types), sans étape de compilation supplémentaire.\n\n\nCompatibilité des navigateurs#\n\nLe framework est construit par défaut en mode de compatibilité pour supporter\nune large gamme de navigateurs. Cependant, pour une compatibilité complète des\nnavigateurs, il est nécessaire d'ajouter manuellement la dépendance\nes-module-shims.\n\n\nMode de compatibilité (par défaut)#\n\n * 🌐 Chrome : >= 87\n * 🔷 Edge : >= 88\n * 🦊 Firefox : >= 78\n * 🧭 Safari : >= 14\n\nSelon les statistiques de Can I Use, le taux de couverture des navigateurs en\nmode de compatibilité est de 96,81 %.\n\n\nMode de support natif#\n\n * 🌐 Chrome : >= 89\n * 🔷 Edge : >= 89\n * 🦊 Firefox : >= 108\n * 🧭 Safari : >= 16.4\n\nLe mode de support natif offre les avantages suivants :\n\n * Aucun surcoût d'exécution, pas besoin de chargeur de modules supplémentaire\n * Analyse native par le navigateur, vitesse d'exécution plus rapide\n * Meilleure capacité de découpage de code et de chargement à la demande\n\nSelon les statistiques de Can I Use, le taux de couverture des navigateurs en\nmode de support natif est de 93,5 %.\n\n\nActivation du support de compatibilité#\n\nAvertissement important\n\nBien que le framework soit construit par défaut en mode de compatibilité, pour\nun support complet des anciens navigateurs, vous devez ajouter la dépendance\nes-module-shims à votre projet.\n\nAjoutez le script suivant dans votre fichier HTML :\n\n\n\nBonnes pratiques\n 1. Recommandations pour l'environnement de production :\n    * Déployez es-module-shims sur votre propre serveur\n    * Assurez la stabilité et la vitesse de chargement des ressources\n    * Évitez les risques de sécurité potentiels\n 2. Considérations de performance :\n    * Le mode de compatibilité entraîne un léger surcoût de performance\n    * Vous pouvez décider de l'activer en fonction de la distribution des\n      navigateurs de votre public cible","routePath":"/fr/guide/start/environment","lang":"fr","toc":[{"text":"Environnement Node.js","id":"environnement-nodejs","depth":2,"charIndex":168},{"text":"Compatibilité des navigateurs","id":"compatibilité-des-navigateurs","depth":2,"charIndex":397},{"text":"Mode de compatibilité (par défaut)","id":"mode-de-compatibilité-par-défaut","depth":3,"charIndex":673},{"text":"Mode de support natif","id":"mode-de-support-natif","depth":3,"charIndex":912},{"text":"Activation du support de compatibilité","id":"activation-du-support-de-compatibilité","depth":3,"charIndex":1419}],"domain":"","frontmatter":{"titleSuffix":"Guide de compatibilité du framework Gez","description":"Détails sur les exigences environnementales du framework Gez, y compris les versions requises de Node.js et les informations de compatibilité des navigateurs, pour aider les développeurs à configurer correctement leur environnement de développement.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, Compatibilité des navigateurs, TypeScript, es-module-shims, Configuration de l'environnement"}]]},"version":""},{"id":97,"title":"Démarrage rapide","content":"#\n\n\nInitialisation du projet#\n\nPour créer et initialiser un nouveau projet Gez, suivez les étapes suivantes :\n\n\n\n\nChoix de la version du framework#\n\nLe framework Gez propose plusieurs versions de piles technologiques, chacune\noptimisée pour différents cas d'utilisation. Choisissez la version appropriée en\nfonction des besoins de votre projet :\n\n\nHTML#\n\nConvient aux projets recherchant une architecture minimaliste :\n\n * Aucune dépendance externe, prêt à l'emploi\n * Expérience de développement JavaScript native\n * Idéal pour la construction de sites web statiques et d'applications légères\n * Supporte l'extension progressive des fonctionnalités\n\nConsulter la documentation détaillée de la version HTML\n\n\nVue2#\n\nConvient au développement d'applications d'entreprise :\n\n * Support complet de TypeScript\n * Écosystème riche de composants tiers\n * Chaîne d'outils de développement mature\n * Stabilité éprouvée en environnement de production\n\nConsulter la documentation détaillée de la version Vue2\n\n\nVue3#\n\nConvient au développement d'applications web modernes :\n\n * Système réactif basé sur Proxy\n * Support de l'API de composition\n * Meilleures performances d'exécution\n * Volume de bundle plus petit\n\nConsulter la documentation détaillée de la version Vue3\n\n\nPreact+HTM#\n\nConvient aux projets recherchant une solution légère et performante :\n\n * Volume d'exécution extrêmement réduit (3KB)\n * Syntaxe de template JavaScript native\n * API compatible avec React\n * Excellentes performances\n\nConsulter la documentation détaillée de la version Preact+HTM\n\n\nDéveloppement assisté par IA#\n\nLe framework Gez offre des capacités de développement assisté par IA, permettant\nd'améliorer significativement l'efficacité du développement :\n\n 1. Choisissez la documentation de la version du framework appropriée\n 2. Fournissez le contenu de la documentation à l'assistant IA\n 3. L'IA générera automatiquement le squelette du projet et les fichiers de\n    configuration\n\nAstuce\n\nLe développement assisté par IA permet non seulement d'accélérer\nl'initialisation du projet, mais aussi de garantir que la structure du projet\nrespecte les meilleures pratiques.","routePath":"/fr/guide/start/getting-started","lang":"fr","toc":[{"text":"Initialisation du projet","id":"initialisation-du-projet","depth":2,"charIndex":3},{"text":"Choix de la version du framework","id":"choix-de-la-version-du-framework","depth":2,"charIndex":113},{"text":"HTML","id":"html","depth":3,"charIndex":347},{"text":"Vue2","id":"vue2","depth":3,"charIndex":708},{"text":"Vue3","id":"vue3","depth":3,"charIndex":1000},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1262},{"text":"Développement assisté par IA","id":"développement-assisté-par-ia","depth":2,"charIndex":1556}],"domain":"","frontmatter":{"titleSuffix":"Guide de démarrage rapide du framework Gez","description":"Guide de démarrage rapide du framework Gez pour vous aider à démarrer un projet à partir de zéro, y compris l'initialisation du projet, le choix de la version du framework et le développement assisté par IA.","head":[["meta",{"name":"keywords","content":"Framework Gez, Démarrage rapide, Initialisation de projet, Développement Vue, Développement HTML, Assistance IA"}]]},"version":""},{"id":98,"title":"Introduction","content":"#\n\n\nContexte du projet#\n\nGez est un framework moderne de micro-frontend basé sur ECMAScript Modules\n(ESM), axé sur la construction d'applications de rendu côté serveur (SSR) hautes\nperformances et extensibles. En tant que troisième génération du projet Genesis,\nGez a continuellement innové au cours de son évolution technologique :\n\n * v1.0 : Chargement à la demande de composants distants basé sur des requêtes\n   HTTP\n * v2.0 : Intégration d'applications basée sur Webpack Module Federation\n * v3.0 : Redesign du système de liaison de modules basé sur ESM natif du\n   navigateur\n\n\nContexte technologique#\n\nDans le développement de l'architecture de micro-frontend, les solutions\ntraditionnelles présentent principalement les limites suivantes :\n\n\nDéfis des solutions existantes#\n\n * Goulot d'étranglement de performance : L'injection de dépendances à\n   l'exécution et le proxy de sandbox JavaScript entraînent des surcoûts de\n   performance significatifs\n * Mécanisme d'isolation : Les environnements de sandbox maison ont du mal à\n   égaler les capacités d'isolation de modules natifs du navigateur\n * Complexité de construction : Les modifications des outils de construction\n   pour partager les dépendances augmentent les coûts de maintenance du projet\n * Déviation des standards : Les stratégies de déploiement spéciales et les\n   mécanismes de traitement à l'exécution s'écartent des standards modernes de\n   développement Web\n * Limites de l'écosystème : Le couplage des frameworks et les API\n   personnalisées limitent le choix de la pile technologique\n\n\nInnovations technologiques#\n\nGez propose une nouvelle solution basée sur les standards Web modernes :\n\n * Système de modules natif : Utilisation d'ESM natif du navigateur et d'Import\n   Maps pour la gestion des dépendances, offrant une vitesse d'analyse et\n   d'exécution plus rapide\n * Mécanisme d'isolation standard : Isolation fiable des applications basée sur\n   la portée des modules ECMAScript\n * Pile technologique ouverte : Support de l'intégration transparente de\n   n'importe quel framework frontend moderne\n * Optimisation de l'expérience de développement : Fournit un mode de\n   développement intuitif et des capacités de débogage complètes\n * Optimisation des performances extrêmes : Réalisation de zéro surcoût à\n   l'exécution grâce aux capacités natives, avec une stratégie de cache\n   intelligente\n\nTIP\n\nGez se concentre sur la création d'une infrastructure de micro-frontend haute\nperformance et facilement extensible, particulièrement adaptée aux scénarios\nd'applications de rendu côté serveur à grande échelle.\n\n\nSpécifications techniques#\n\n\nDépendances environnementales#\n\nVeuillez consulter le document Exigences environnementales pour connaître les\nexigences détaillées du navigateur et de l'environnement Node.js.\n\n\nPile technologique principale#\n\n * Gestion des dépendances : Utilisation d'Import Maps pour le mappage des\n   modules, avec es-module-shims pour la compatibilité\n * Système de construction : Traitement des dépendances externes basé sur\n   module-import de Rspack\n * Chaîne d'outils de développement : Support de la mise à jour à chaud ESM et\n   de l'exécution native de TypeScript\n\n\nPositionnement du framework#\n\nGez diffère de Next.js ou Nuxt.js, en se concentrant sur la fourniture d'une\ninfrastructure de micro-frontend :\n\n * Système de liaison de modules : Réalisation d'une importation/exportation de\n   modules efficace et fiable\n * Rendu côté serveur : Fournit un mécanisme de mise en œuvre flexible du SSR\n * Support du système de types : Intégration de définitions de types TypeScript\n   complètes\n * Neutralité du framework : Support de l'intégration des principaux frameworks\n   frontend\n\n\nConception de l'architecture#\n\n\nGestion centralisée des dépendances#\n\n * Source de dépendances unifiée : Gestion centralisée des dépendances tierces\n * Distribution automatique : Synchronisation globale automatique des mises à\n   jour des dépendances\n * Cohérence des versions : Contrôle précis des versions des dépendances\n\n\nConception modulaire#\n\n * Séparation des responsabilités : Découplage de la logique métier et de\n   l'infrastructure\n * Mécanisme de plugins : Support de la combinaison et du remplacement flexibles\n   des modules\n * Interface standardisée : Protocole de communication normalisé entre les\n   modules\n\n\nOptimisation des performances#\n\n * Principe de zéro surcoût : Maximisation de l'utilisation des capacités\n   natives du navigateur\n * Cache intelligent : Stratégie de cache précise basée sur le hachage du\n   contenu\n * Chargement à la demande : Gestion fine de la segmentation du code et des\n   dépendances\n\n\nMaturité du projet#\n\nGez, à travers près de 5 ans d'itérations et d'évolutions (de v1.0 à v3.0), a\nété largement validé dans des environnements d'entreprise. Il supporte\nactuellement des dizaines de projets métiers en fonctionnement stable et\ncontinue de promouvoir la modernisation de la pile technologique. La stabilité,\nla fiabilité et les avantages en termes de performance du framework ont été\npleinement vérifiés dans la pratique, fournissant une base technologique fiable\npour le développement d'applications à grande échelle.","routePath":"/fr/guide/start/introduction","lang":"fr","toc":[{"text":"Contexte du projet","id":"contexte-du-projet","depth":2,"charIndex":3},{"text":"Contexte technologique","id":"contexte-technologique","depth":2,"charIndex":583},{"text":"Défis des solutions existantes","id":"défis-des-solutions-existantes","depth":3,"charIndex":749},{"text":"Innovations technologiques","id":"innovations-technologiques","depth":3,"charIndex":1565},{"text":"Spécifications techniques","id":"spécifications-techniques","depth":2,"charIndex":2598},{"text":"Dépendances environnementales","id":"dépendances-environnementales","depth":3,"charIndex":2627},{"text":"Pile technologique principale","id":"pile-technologique-principale","depth":3,"charIndex":2805},{"text":"Positionnement du framework","id":"positionnement-du-framework","depth":2,"charIndex":3188},{"text":"Conception de l'architecture","id":"conception-de-larchitecture","depth":2,"charIndex":3706},{"text":"Gestion centralisée des dépendances","id":"gestion-centralisée-des-dépendances","depth":3,"charIndex":3738},{"text":"Conception modulaire","id":"conception-modulaire","depth":3,"charIndex":4032},{"text":"Optimisation des performances","id":"optimisation-des-performances","depth":3,"charIndex":4333},{"text":"Maturité du projet","id":"maturité-du-projet","depth":2,"charIndex":4642}],"domain":"","frontmatter":{"titleSuffix":"Vue d'ensemble du framework Gez et innovations technologiques","description":"Découvrez en profondeur le contexte du projet, l'évolution technologique et les avantages clés du framework de micro-frontend Gez, et explorez une solution moderne de rendu côté serveur basée sur ESM.","head":[["meta",{"property":"keywords","content":"Gez, micro-frontend, ESM, rendu côté serveur, SSR, innovation technologique, module federation"}]]},"version":""}]