[{"id":325,"title":"@gez/rspack-vue","content":"#\n\nRspack Vue 包提供了一套用于创建和配置基于 Vue 框架的 Rspack 应用的 API，支持 Vue 组件的开发、构建与服务端渲染。\n\n\n安装#\n\n使用包管理器安装 @gez/rspack-vue 开发依赖：\n\n\n类型导出#\n\n\nBuildTarget#\n\n\n\n构建目标环境类型，定义了应用程序的构建目标环境，用于配置构建过程中的特定优化和功能：\n\n * node: 构建为 Node.js 环境运行的代码\n * client: 构建为浏览器环境运行的代码\n * server: 构建为服务端环境运行的代码\n\n\nRspackAppConfigContext#\n\n\n\nRspack 应用配置上下文接口，提供了在配置钩子函数中可以访问的上下文信息：\n\n * gez: Gez 框架实例\n * buildTarget: 当前的构建目标（client/server/node）\n * config: Rspack 配置对象\n * options: 应用配置选项\n\n\nRspackAppOptions#\n\n\n\nRspack 应用配置选项接口：\n\n * css: CSS 输出方式，可选 'css'（独立文件）或 'style'（内联样式）\n * loaders: 自定义 loader 配置\n * styleLoader: style-loader 配置选项\n * cssLoader: css-loader 配置选项\n * target: 构建目标兼容性配置\n * definePlugin: 全局常量定义\n * config: 配置钩子函数\n\n\nRspackHtmlAppOptions#\n\n继承自 RspackAppOptions，用于配置 HTML 应用的特定选项。\n\n\n函数导出#\n\n\ncreateRspackApp#\n\n\n\n创建一个标准的 Rspack 应用实例。\n\n参数：\n\n * gez: Gez 框架实例\n * options: Rspack 应用配置选项\n\n返回值：\n\n * 返回一个 Promise，解析为创建的应用实例\n\n\ncreateRspackHtmlApp#\n\n\n\n创建一个 HTML 类型的 Rspack 应用实例。\n\n参数：\n\n * gez: Gez 框架实例\n * options: HTML 应用配置选项\n\n返回值：\n\n * 返回一个 Promise，解析为创建的 HTML 应用实例\n\n\n常量导出#\n\n\nRSPACK_LOADER#\n\n\n\nRspack 内置的 loader 标识符映射对象，提供了常用的 loader 名称常量：\n\n * builtinSwcLoader: Rspack 内置的 SWC loader，用于处理 TypeScript/JavaScript 文件\n * lightningcssLoader: Rspack 内置的 lightningcss loader，用于处理 CSS 文件的高性能编译器\n * styleLoader: 用于将 CSS 注入到 DOM 中的 loader\n * cssLoader: 用于解析 CSS 文件和处理 CSS 模块化的 loader\n * lessLoader: 用于将 Less 文件编译为 CSS 的 loader\n * styleResourcesLoader: 用于自动导入全局样式资源（如变量、mixins）的 loader\n * workerRspackLoader: 用于处理 Web Worker 文件的 loader\n\n使用这些常量可以在配置中引用内置的 loader，避免手动输入字符串：\n\n\n\n注意事项：\n\n * 这些 loader 已经内置在 Rspack 中，无需额外安装\n * 在自定义 loader 配置时，可以使用这些常量来替换默认的 loader 实现\n * 某些 loader（如 builtinSwcLoader）有特定的配置选项，请参考相应的配置文档\n\n\n模块导出#\n\n\nrspack#\n\n重导出 @rspack/core 包的所有内容，提供完整的 Rspack 核心功能。","routePath":"/api/app/rspack-vue","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":77},{"text":"类型导出","id":"类型导出","depth":2,"charIndex":115},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":123},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":264},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":437},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":678},{"text":"函数导出","id":"函数导出","depth":2,"charIndex":743},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":751},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":877},{"text":"常量导出","id":"常量导出","depth":2,"charIndex":1017},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":1025},{"text":"模块导出","id":"模块导出","depth":2,"charIndex":1654},{"text":"rspack","id":"rspack","depth":3,"charIndex":1662}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架 Vue 构建工具","description":"Gez 框架的 Vue 专用构建工具，提供完整的 Vue 2/3 应用构建支持，包括组件开发、SSR 渲染和性能优化等功能。","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, 构建工具, 组件开发, 服务端渲染, 性能优化"}]]},"version":""},{"id":326,"title":"@gez/rspack","content":"#\n\nRspack 包提供了一套用于创建和配置 Rspack 应用的 API，支持标准应用和 HTML 应用的构建与开发。\n\n\n安装#\n\n使用包管理器安装 @gez/rspack 开发依赖：\n\n\n类型导出#\n\n\nBuildTarget#\n\n\n\n构建目标环境类型，定义了应用程序的构建目标环境，用于配置构建过程中的特定优化和功能：\n\n * node: 构建为 Node.js 环境运行的代码\n * client: 构建为浏览器环境运行的代码\n * server: 构建为服务端环境运行的代码\n\n\nRspackAppConfigContext#\n\n\n\nRspack 应用配置上下文接口，提供了在配置钩子函数中可以访问的上下文信息：\n\n * gez: Gez 框架实例\n * buildTarget: 当前的构建目标（client/server/node）\n * config: Rspack 配置对象\n * options: 应用配置选项\n\n\nRspackAppOptions#\n\n\n\nRspack 应用配置选项接口：\n\n * css: CSS 输出方式，可选 'css'（独立文件）或 'style'（内联样式）\n * loaders: 自定义 loader 配置\n * styleLoader: style-loader 配置选项\n * cssLoader: css-loader 配置选项\n * target: 构建目标兼容性配置\n * definePlugin: 全局常量定义\n * config: 配置钩子函数\n\n\nRspackHtmlAppOptions#\n\n继承自 RspackAppOptions，用于配置 HTML 应用的特定选项。\n\n\n函数导出#\n\n\ncreateRspackApp#\n\n\n\n创建一个标准的 Rspack 应用实例。\n\n参数：\n\n * gez: Gez 框架实例\n * options: Rspack 应用配置选项\n\n返回值：\n\n * 返回一个 Promise，解析为创建的应用实例\n\n\ncreateRspackHtmlApp#\n\n\n\n创建一个 HTML 类型的 Rspack 应用实例。\n\n参数：\n\n * gez: Gez 框架实例\n * options: HTML 应用配置选项\n\n返回值：\n\n * 返回一个 Promise，解析为创建的 HTML 应用实例\n\n\n常量导出#\n\n\nRSPACK_LOADER#\n\n\n\nRspack 内置的 loader 标识符映射对象，提供了常用的 loader 名称常量：\n\n * builtinSwcLoader: Rspack 内置的 SWC loader，用于处理 TypeScript/JavaScript 文件\n * lightningcssLoader: Rspack 内置的 lightningcss loader，用于处理 CSS 文件的高性能编译器\n * styleLoader: 用于将 CSS 注入到 DOM 中的 loader\n * cssLoader: 用于解析 CSS 文件和处理 CSS 模块化的 loader\n * lessLoader: 用于将 Less 文件编译为 CSS 的 loader\n * styleResourcesLoader: 用于自动导入全局样式资源（如变量、mixins）的 loader\n * workerRspackLoader: 用于处理 Web Worker 文件的 loader\n\n使用这些常量可以在配置中引用内置的 loader，避免手动输入字符串：\n\n\n\n注意事项：\n\n * 这些 loader 已经内置在 Rspack 中，无需额外安装\n * 在自定义 loader 配置时，可以使用这些常量来替换默认的 loader 实现\n * 某些 loader（如 builtinSwcLoader）有特定的配置选项，请参考相应的配置文档\n\n\n模块导出#\n\n\nrspack#\n\n重导出 @rspack/core 包的所有内容，提供完整的 Rspack 核心功能。","routePath":"/api/app/rspack","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":63},{"text":"类型导出","id":"类型导出","depth":2,"charIndex":97},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":105},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":246},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":419},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":660},{"text":"函数导出","id":"函数导出","depth":2,"charIndex":725},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":733},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":859},{"text":"常量导出","id":"常量导出","depth":2,"charIndex":999},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":1007},{"text":"模块导出","id":"模块导出","depth":2,"charIndex":1636},{"text":"rspack","id":"rspack","depth":3,"charIndex":1644}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架 Rspack 构建工具","description":"Gez 框架的 Rspack 构建工具，提供高性能的应用构建能力，支持标准应用和 HTML 应用的开发与构建，内置多种资源处理器和优化配置。","head":[["meta",{"property":"keywords","content":"Gez, Rspack, 构建工具, 应用构建, HTML 应用, TypeScript, CSS, 资源处理, 性能优化"}]]},"version":""},{"id":327,"title":"App","content":"#\n\nApp 是 Gez 框架的应用抽象，提供了统一的接口来管理应用的生命周期、静态资源和服务端渲染。\n\n\n\n\n类型定义#\n\n\nApp#\n\n\n\nmiddleware#\n\n * 类型: Middleware\n\n静态资源处理中间件。\n\n开发环境：\n\n * 处理源码的静态资源请求\n * 支持实时编译和热更新\n * 使用 no-cache 缓存策略\n\n生产环境：\n\n * 处理构建后的静态资源\n * 支持不可变文件的长期缓存（.final.xxx）\n * 优化的资源加载策略\n\n\n\nrender#\n\n * 类型: (options?: RenderContextOptions) => Promise\n\n服务端渲染函数。根据运行环境提供不同实现：\n\n * 生产环境（start）：加载构建后的服务端入口文件（entry.server）执行渲染\n * 开发环境（dev）：加载源码中的服务端入口文件执行渲染\n\n\n\nbuild#\n\n * 类型: () => Promise\n\n生产环境构建函数。用于资源打包和优化。构建成功返回 true，失败返回 false。\n\ndestroy#\n\n * 类型: () => Promise\n\n资源清理函数。用于关闭服务器、断开连接等。清理成功返回 true，失败返回 false。","routePath":"/api/core/app","lang":"zh","toc":[{"text":"类型定义","id":"类型定义","depth":2,"charIndex":55},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":71},{"text":"render","id":"render","depth":4,"charIndex":237},{"text":"build","id":"build","depth":4,"charIndex":402},{"text":"destroy","id":"destroy","depth":4,"charIndex":476}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架应用抽象接口","description":"详细介绍 Gez 框架的 App 接口，包括应用生命周期管理、静态资源处理和服务端渲染功能，帮助开发者理解和使用应用核心功能。","head":[["meta",{"property":"keywords","content":"Gez, App, 应用抽象, 生命周期, 静态资源, 服务端渲染, API"}]]},"version":""},{"id":328,"title":"Gez","content":"","routePath":"/api/core/gez","lang":"zh","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":-1},{"text":"类型定义","id":"类型定义","depth":2,"charIndex":-1},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":-1},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":-1},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":-1},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":-1},{"text":"COMMAND","id":"command","depth":3,"charIndex":-1},{"text":"实例选项","id":"实例选项","depth":2,"charIndex":-1},{"text":"root","id":"root","depth":4,"charIndex":-1},{"text":"isProd","id":"isprod","depth":4,"charIndex":-1},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":-1},{"text":"modules","id":"modules","depth":4,"charIndex":-1},{"text":"packs","id":"packs","depth":4,"charIndex":-1},{"text":"devApp","id":"devapp","depth":4,"charIndex":-1},{"text":"server","id":"server","depth":4,"charIndex":-1},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":-1},{"text":"实例属性","id":"实例属性","depth":2,"charIndex":-1},{"text":"name","id":"name","depth":3,"charIndex":-1},{"text":"varName","id":"varname","depth":3,"charIndex":-1},{"text":"root","id":"root-1","depth":3,"charIndex":-1},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":-1},{"text":"basePath","id":"basepath","depth":3,"charIndex":-1},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":3,"charIndex":-1},{"text":"render","id":"render","depth":3,"charIndex":-1},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":-1},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":-1},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":-1},{"text":"实例方法","id":"实例方法","depth":2,"charIndex":-1},{"text":"constructor()","id":"constructor","depth":3,"charIndex":-1},{"text":"init()","id":"init","depth":3,"charIndex":-1},{"text":"destroy()","id":"destroy","depth":3,"charIndex":-1},{"text":"build()","id":"build","depth":3,"charIndex":-1},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":-1},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":-1},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":-1},{"text":"readJson()","id":"readjson","depth":3,"charIndex":-1},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":-1},{"text":"getImportMap()","id":"getimportmap","depth":3,"charIndex":-1},{"text":"getImportMapClientInfo()","id":"getimportmapclientinfo","depth":3,"charIndex":-1},{"text":"getStaticImportPaths()","id":"getstaticimportpaths","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"框架核心类 API 参考","description":"详细介绍 Gez 框架的核心类 API，包括应用生命周期管理、静态资源处理和服务端渲染能力，帮助开发者深入理解框架的核心功能。","head":[["meta",{"property":"keywords","content":"Gez, API, 生命周期管理, 静态资源, 服务端渲染, Rspack, Web 应用框架"}]]},"version":""},{"id":329,"title":"ManifestJson","content":"#\n\nmanifest.json 是 Gez 框架在构建过程中生成的清单文件，用于记录服务构建的产物信息。它提供了统一的接口来管理构建产物、导出文件和资源大小统计。\n\n\n\n\n类型定义#\n\n\nManifestJson#\n\n\n\nname#\n\n * 类型: string\n\n服务名称，来自于 GezOptions.name 配置。\n\nexports#\n\n * 类型: Record\n\n对外导出的文件映射关系，key 为源文件路径，value 为构建后的文件路径。\n\nbuildFiles#\n\n * 类型: string[]\n\n构建产物的完整文件清单，包含所有生成的文件路径。\n\nchunks#\n\n * 类型: Record\n\n源文件与编译产物的对应关系，key 为源文件路径，value 为编译信息。\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * 类型: string\n\n当前源文件编译后的 JS 文件路径。\n\ncss#\n\n * 类型: string[]\n\n当前源文件关联的 CSS 文件路径列表。\n\nresources#\n\n * 类型: string[]\n\n当前源文件关联的其它资源文件路径列表。\n\nsizes#\n\n * 类型: ManifestJsonChunkSizes\n\n构建产物的大小统计信息。\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * 类型: number\n\nJS 文件大小（字节）。\n\ncss#\n\n * 类型: number\n\nCSS 文件大小（字节）。\n\nresource#\n\n * 类型: number\n\n资源文件大小（字节）。","routePath":"/api/core/manifest-json","lang":"zh","toc":[{"text":"类型定义","id":"类型定义","depth":2,"charIndex":86},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":111},{"text":"exports","id":"exports","depth":4,"charIndex":163},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":229},{"text":"chunks","id":"chunks","depth":4,"charIndex":285},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":349},{"text":"js","id":"js","depth":4,"charIndex":372},{"text":"css","id":"css","depth":4,"charIndex":412},{"text":"resources","id":"resources","depth":4,"charIndex":457},{"text":"sizes","id":"sizes","depth":4,"charIndex":507},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":561},{"text":"js","id":"js-1","depth":4,"charIndex":588},{"text":"css","id":"css-1","depth":4,"charIndex":622},{"text":"resource","id":"resource","depth":4,"charIndex":658}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架构建清单文件参考","description":"详细介绍 Gez 框架的构建清单文件（manifest.json）结构，包括构建产物管理、导出文件映射和资源统计功能，帮助开发者理解和使用构建系统。","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, 构建清单, 资源管理, 构建产物, 文件映射, API"}]]},"version":""},{"id":330,"title":"ModuleConfig","content":"#\n\nModuleConfig 提供了 Gez 框架的模块配置功能，用于定义模块的导入导出规则、别名配置和外部依赖等。\n\n\n类型定义#\n\n\nPathType#\n\n * 类型定义:\n\n\n\n模块路径类型枚举：\n\n * npm: 表示 node_modules 中的依赖\n * root: 表示项目根目录下的文件\n\n\nModuleConfig#\n\n * 类型定义:\n\n\n\n模块配置接口，用于定义服务的导出、导入和外部依赖配置。\n\nexports#\n\n导出配置列表，将服务中的特定代码单元（如组件、工具函数等）以 ESM 格式对外暴露。\n\n支持两种类型：\n\n * root:*: 导出源码文件，如：'root:src/components/button.vue'\n * npm:*: 导出第三方依赖，如：'npm:vue'\n\nimports#\n\n导入配置映射，配置需要导入的远程模块及其本地路径。\n\n安装方式不同，配置也不同：\n\n * 源码安装（Workspace、Git）：需要指向 dist 目录\n * 软件包安装（Link、静态服务器、私有镜像源、File）：直接指向包目录\n\nexternals#\n\n外部依赖映射，配置要使用的外部依赖，通常是使用远程模块中的依赖。\n\n示例：\n\n\n\n\nParsedModuleConfig#\n\n * 类型定义:\n\n\n\n解析后的模块配置，将原始的模块配置转换为标准化的内部格式：\n\nname#\n\n当前服务的名称\n\n * 用于标识模块和生成导入路径\n\nroot#\n\n当前服务的根目录路径\n\n * 用于解析相对路径和构建产物的存放\n\nexports#\n\n导出配置列表\n\n * name: 原始导出路径，如：'npm:vue' 或 'root:src/components'\n * type: 路径类型（npm 或 root）\n * importName: 导入名称，格式：'${serviceName}/${type}/${path}'\n * exportName: 导出路径，相对于服务根目录\n * exportPath: 实际的文件路径\n * externalName: 外部依赖名称，用于其他服务导入此模块时的标识\n\nimports#\n\n导入配置列表\n\n * name: 外部服务的名称\n * localPath: 本地存储路径，用于存放外部模块的构建产物\n\nexternals#\n\n外部依赖映射\n\n * 将模块的导入路径映射到实际的模块位置\n * match: 用于匹配导入语句的正则表达式\n * import: 实际的模块路径","routePath":"/api/core/module-config","lang":"zh","toc":[{"text":"类型定义","id":"类型定义","depth":2,"charIndex":61},{"text":"PathType","id":"pathtype","depth":3,"charIndex":69},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":211},{"text":"imports","id":"imports","depth":4,"charIndex":358},{"text":"externals","id":"externals","depth":4,"charIndex":487},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":541},{"text":"name","id":"name","depth":4,"charIndex":605},{"text":"root","id":"root","depth":4,"charIndex":639},{"text":"exports","id":"exports-1","depth":4,"charIndex":679},{"text":"imports","id":"imports-1","depth":4,"charIndex":924},{"text":"externals","id":"externals-1","depth":4,"charIndex":995}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架模块配置 API 参考","description":"详细介绍 Gez 框架的 ModuleConfig 配置接口，包括模块导入导出规则、别名配置和外部依赖管理，帮助开发者深入理解框架的模块化系统。","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, 模块配置, 模块导入导出, 外部依赖, 别名配置, 依赖管理, Web 应用框架"}]]},"version":""},{"id":331,"title":"PackConfig","content":"#\n\nPackConfig 是软件包打包配置接口，用于将服务的构建产物打包成标准的 npm .tgz 格式软件包。\n\n * 标准化：使用 npm 标准的 .tgz 打包格式\n * 完整性：包含模块的源代码、类型声明和配置文件等所有必要文件\n * 兼容性：与 npm 生态系统完全兼容，支持标准的包管理工作流\n\n\n类型定义#\n\n\n\n\nPackConfig#\n\nenable#\n\n是否启用打包功能。启用后会将构建产物打包成标准的 npm .tgz 格式软件包。\n\n * 类型：boolean\n * 默认值：false\n\noutputs#\n\n指定输出的软件包文件路径。支持以下配置方式：\n\n * string: 单个输出路径，如 'dist/versions/my-app.tgz'\n * string[]: 多个输出路径，用于同时生成多个版本\n * boolean: true 时使用默认路径 'dist/client/versions/latest.tgz'\n\npackageJson#\n\n自定义 package.json 内容的回调函数。在打包前调用，用于自定义 package.json 的内容。\n\n * 参数：\n   * gez: Gez - Gez 实例\n   * pkg: any - 原始的 package.json 内容\n * 返回值：Promise - 修改后的 package.json 内容\n\n常见用途：\n\n * 修改包名和版本号\n * 添加或更新依赖项\n * 添加自定义字段\n * 配置发布相关信息\n\n示例：\n\n\n\nonBefore#\n\n打包前的准备工作回调函数。\n\n * 参数：\n   * gez: Gez - Gez 实例\n   * pkg: Record - package.json 内容\n * 返回值：Promise\n\n常见用途：\n\n * 添加额外的文件（README、LICENSE 等）\n * 执行测试或构建验证\n * 生成文档或元数据\n * 清理临时文件\n\n示例：\n\n\n\nonAfter#\n\n打包完成后的处理回调函数。在 .tgz 文件生成后调用，用于处理打包产物。\n\n * 参数：\n   * gez: Gez - Gez 实例\n   * pkg: Record - package.json 内容\n   * file: Buffer - 打包后的文件内容\n * 返回值：Promise\n\n常见用途：\n\n * 发布到 npm 仓库（公共或私有）\n * 上传到静态资源服务器\n * 执行版本管理\n * 触发 CI/CD 流程\n\n示例：\n\n\n\n\n使用示例#\n\n","routePath":"/api/core/pack-config","lang":"zh","toc":[{"text":"类型定义","id":"类型定义","depth":2,"charIndex":155},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":178},{"text":"outputs","id":"outputs","depth":4,"charIndex":257},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":429},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":667},{"text":"onAfter","id":"onafter","depth":4,"charIndex":853},{"text":"使用示例","id":"使用示例","depth":2,"charIndex":1088}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架打包配置 API 参考","description":"详细介绍 Gez 框架的 PackConfig 配置接口，包括软件包打包规则、输出配置和生命周期钩子，帮助开发者实现标准化的构建流程。","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, 软件包打包, 构建配置, 生命周期钩子, 打包配置, Web 应用框架"}]]},"version":""},{"id":332,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${html} ${rc.importmap()}\n${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/api/core/render-context","lang":"zh","toc":[{"text":"类型定义","id":"类型定义","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"实例选项","id":"实例选项","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"实例属性","id":"实例属性","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"实例方法","id":"实例方法","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1},{"text":"importmap()","id":"importmap","depth":3,"charIndex":-1},{"text":"moduleEntry()","id":"moduleentry","depth":3,"charIndex":-1},{"text":"modulePreload()","id":"modulepreload","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架渲染上下文 API 参考","description":"详细介绍 Gez 框架的 RenderContext 核心类，包括渲染控制、资源管理、状态同步和路由控制等功能，帮助开发者实现高效的服务端渲染。","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, 服务端渲染, 渲染上下文, 状态同步, 资源管理, Web 应用框架"}]]},"version":""},{"id":333,"title":"从组件共享到原生模块化：Gez 微前端框架的演进之路","content":"#\n\n\n项目背景#\n\n在过去的几年里，微前端架构一直在寻找一条正确的道路。然而，我们看到的是各种复杂的技术方案，它们用层层包装和人工隔离来模拟一个理想的微前端世界。这些方案带来了沉重\n的性能负担，让简单的开发变得复杂，让标准的流程变得晦涩。\n\n\n传统方案的局限性#\n\n在实践微前端架构的过程中，我们深刻体会到传统方案的诸多限制：\n\n * 性能损耗：运行时注入依赖、JS 沙箱代理，每一次操作都在消耗宝贵的性能\n * 脆弱的隔离：人工打造的沙箱环境，始终无法企及浏览器原生的隔离能力\n * 构建复杂性：为了处理依赖关系，不得不魔改构建工具，让简单的项目变得难以维护\n * 定制化规则：特殊的部署策略、运行时处理，让每一步都偏离了现代开发的标准流程\n * 生态限制：框架耦合、定制API，让技术选型被迫绑定在特定的生态中\n\n这些问题在我们 2019\n年的一个企业级项目中表现得尤为突出。当时，一个大型产品被拆分为十余个独立的业务子系统，这些子系统需要共享一套基础组件和业务组件。最初采用的基于 npm\n包的组件共享方案，在实践中暴露出了严重的维护效率问题：当共享组件发生更新时，所有依赖该组件的子系统都需要经历完整的构建和部署流程。\n\n\n技术演进#\n\n\nv1.0：探索远程组件#\n\n为解决组件共享的效率问题，Gez v1.0 引入了基于 HTTP 协议的 RemoteView\n组件机制。这一方案通过运行时动态请求的方式实现了服务间的代码按需组装，成功解决了构建依赖链过长的问题。然而，由于缺乏标准化的运行时通信机制，服务间的状态同步和事\n件传递仍然存在效率瓶颈。\n\n\nv2.0：模块联邦尝试#\n\n在 v2.0 版本中，我们采用了 Webpack 5.0 的模块联邦（Module\nFederation）技术。这一技术通过统一的模块加载机制和运行时容器，显著提升了服务间的协同效率。但在大规模实践中，模块联邦的封闭式实现机制带来了新的挑战：难\n以实现精确的依赖版本管理，特别是在统一多个服务的共享依赖时，经常遇到版本冲突和运行时异常。\n\n\n拥抱 ESM 新时代#\n\n在规划 v3.0 版本时，我们深入观察了前端生态的发展趋势，发现浏览器原生能力的进步为微前端架构带来了新的可能：\n\n\n标准化的模块系统#\n\n随着主流浏览器对 ES Modules 的全面支持，以及 Import Maps 规范的成熟，前端开发迎来了真正的模块化时代。根据 Can I Use\n的统计数据，目前主流浏览器（Chrome >= 89、Edge >= 89、Firefox >= 108、Safari >= 16.4）对 ESM\n的原生支持率已达到 93.5%，这为我们提供了以下优势：\n\n * 依赖管理标准化：Import Maps 提供了在浏览器层面解析模块依赖的能力，无需复杂的运行时注入\n * 资源加载优化：浏览器原生的模块缓存机制，显著提升了资源加载效率\n * 构建流程简化：基于 ESM 的开发模式，使得开发环境和生产环境的构建流程更加一致\n\n同时，通过兼容模式的支持（Chrome >= 87、Edge >= 88、Firefox >= 78、Safari >=\n14），我们可以将浏览器覆盖率进一步提升至 96.81%，这让我们能够在保持高性能的同时，不牺牲对旧版浏览器的支持。\n\n\n性能与隔离的突破#\n\n原生模块系统带来的不仅是标准化，更重要的是性能和隔离性的质的提升：\n\n * 零运行时开销：告别了传统微前端方案中的 JavaScript 沙箱代理和运行时注入\n * 可靠的隔离机制：ESM 严格的模块作用域天然提供了最可靠的隔离能力\n * 精确的依赖管理：静态导入分析让依赖关系更加清晰，版本控制更加精确\n\n\n构建工具的选择#\n\n在技术方案的落地过程中，构建工具的选择是一个关键决策点。经过近一年的技术调研和实践，我们的选择经历了以下演进：\n\n 1. Vite 探索\n    \n    * 优势：基于 ESM 的开发服务器，提供极致的开发体验\n    * 挑战：开发环境和生产环境的构建差异，带来了一定的不确定性\n\n 2. Rspack 确立\n    \n    * 性能优势：基于 Rust 的高性能编译，显著提升了构建速度\n    * 生态支持：与 Webpack 生态的高度兼容性，降低了迁移成本\n    * ESM 支持：通过 Rslib 项目的实践，验证了其在 ESM 构建方面的可靠性\n\n这一决策让我们在保持开发体验的同时，获得了更稳定的生产环境支持。基于 ESM 和 Rspack 的组合，我们最终构建了一个高性能、低侵入性的微前端解决方案。\n\n\n未来展望#\n\n在未来的发展规划中，Gez 框架将重点关注以下三个方向：\n\n\nImport Maps 深度优化#\n\n * 动态依赖管理：实现运行时依赖版本的智能调度，解决多应用间的依赖冲突\n * 预加载策略：基于路由分析的智能预加载，提升资源加载效率\n * 构建优化：自动生成最优的 Import Maps 配置，减少开发者的手动配置成本\n\n\n框架无关的路由方案#\n\n * 统一路由抽象：设计框架无关的路由接口，支持 Vue、React 等主流框架\n * 微应用路由：实现应用间的路由联动，保持 URL 与应用状态的一致性\n * 路由中间件：提供可扩展的中间件机制，支持权限控制、页面转场等功能\n\n\n跨框架通信最佳实践#\n\n * 示例应用：提供完整的跨框架通信示例，涵盖 Vue、React、Preact 等主流框架\n * 状态同步：基于 ESM 实现的轻量级状态共享方案\n * 事件总线：标准化的事件通信机制，支持应用间的解耦通信\n\n通过这些优化和扩展，我们期望让 Gez 成为一个更加完善、易用的微前端解决方案，为开发者提供更好的开发体验和更高的开发效率。","routePath":"/blog/birth-of-gez","lang":"zh","toc":[{"text":"项目背景","id":"项目背景","depth":2,"charIndex":3},{"text":"传统方案的局限性","id":"传统方案的局限性","depth":3,"charIndex":122},{"text":"技术演进","id":"技术演进","depth":2,"charIndex":516},{"text":"v1.0：探索远程组件","id":"v10探索远程组件","depth":3,"charIndex":524},{"text":"v2.0：模块联邦尝试","id":"v20模块联邦尝试","depth":3,"charIndex":682},{"text":"拥抱 ESM 新时代","id":"拥抱-esm-新时代","depth":2,"charIndex":867},{"text":"标准化的模块系统","id":"标准化的模块系统","depth":3,"charIndex":939},{"text":"性能与隔离的突破","id":"性能与隔离的突破","depth":3,"charIndex":1385},{"text":"构建工具的选择","id":"构建工具的选择","depth":3,"charIndex":1551},{"text":"未来展望","id":"未来展望","depth":2,"charIndex":1926},{"text":"Import Maps 深度优化","id":"import-maps-深度优化","depth":3,"charIndex":1964},{"text":"框架无关的路由方案","id":"框架无关的路由方案","depth":3,"charIndex":2097},{"text":"跨框架通信最佳实践","id":"跨框架通信最佳实践","depth":3,"charIndex":2225}],"domain":"","frontmatter":{"titleSuffix":"从微前端困境到 ESM 创新：Gez 框架的演进之路","description":"深入探讨 Gez 框架从传统微前端架构的困境到基于 ESM 的创新突破，分享框架在性能优化、依赖管理和构建工具选型等方面的技术实践经验。","head":[["meta",{"property":"keywords","content":"Gez, 微前端框架, ESM, Import Maps, Rspack, 模块联邦, 依赖管理, 性能优化, 技术演进, 服务端渲染"}]],"sidebar":false},"version":""},{"id":334,"title":"团队博客","content":"#\n\n欢迎来到 Gez 团队的技术博客！在这里，我们将分享框架开发过程中的经验、技术创新和最佳实践。\n\n\n最新文章#\n\n * 2025-02-25 从组件共享到原生模块化：Gez 微前端框架的演进之路\n   \n   > 探索 Gez 框架从传统组件共享到基于 ESM 的原生模块化演进历程，分享在性能优化、依赖管理和构建工具选型等方面的技术实践经验。","routePath":"/blog/","lang":"zh","toc":[{"text":"最新文章","id":"最新文章","depth":2,"charIndex":52}],"domain":"","frontmatter":{"titleSuffix":"Gez 团队博客","description":"Gez 团队的技术博客，分享框架开发经验、最佳实践和技术创新。","head":[["meta",{"property":"keywords","content":"Gez, 团队博客, 技术分享, 最佳实践, 开发经验"}]],"sidebar":false},"version":""},{"id":335,"title":"路径别名","content":"#\n\n路径别名（Path Alias）是一种模块导入路径映射机制，它允许开发者使用简短、语义化的标识符来替代完整的模块路径。在 Gez 中，路径别名机制具有以下优势：\n\n * 简化导入路径：使用语义化的别名替代冗长的相对路径，提高代码可读性\n * 避免深层嵌套：消除多层级目录引用（如 ../../../../）带来的维护困难\n * 类型安全：与 TypeScript 的类型系统完全集成，提供代码补全和类型检查\n * 模块解析优化：通过预定义的路径映射，提升模块解析性能\n\n\n默认别名机制#\n\nGez 采用基于服务名（Service Name）的自动别名机制，这种约定优于配置的设计具有以下特点：\n\n * 自动配置：基于 package.json 中的 name 字段自动生成别名，无需手动配置\n * 统一规范：确保所有服务模块遵循一致的命名和引用规范\n * 类型支持：配合 npm run build:dts 命令，自动生成类型声明文件，实现跨服务的类型推导\n * 可预测性：通过服务名即可推断出模块的引用路径，降低维护成本\n\n\n配置说明#\n\n\npackage.json 配置#\n\n在 package.json 中，通过 name 字段定义服务的名称，该名称将作为服务的默认别名前缀：\n\n\n\n\ntsconfig.json 配置#\n\n为了使 TypeScript 能够正确解析别名路径，需要在 tsconfig.json 中配置 paths 映射：\n\n\n\n\n使用示例#\n\n\n导入服务内部模块#\n\n\n\n\n导入其他服务模块#\n\n\n\n最佳实践\n * 优先使用别名路径而不是相对路径\n * 保持别名路径的语义化和一致性\n * 避免在别名路径中使用过多的目录层级\n\n\n\n\n跨服务导入#\n\n当配置了模块链接（Module Link）后，可以使用相同的方式导入其他服务的模块：\n\n\n\n\n自定义别名#\n\n对于第三方包或特殊场景，可以通过 Gez 配置文件自定义别名：\n\n\n\n注意事项\n 1. 对于业务模块，建议始终使用默认的别名机制，以保持项目的一致性\n 2. 自定义别名主要用于处理第三方包的特殊需求或优化开发体验\n 3. 过度使用自定义别名可能会影响代码的可维护性和构建优化","routePath":"/guide/essentials/alias","lang":"zh","toc":[{"text":"默认别名机制","id":"默认别名机制","depth":2,"charIndex":238},{"text":"配置说明","id":"配置说明","depth":2,"charIndex":466},{"text":"package.json 配置","id":"packagejson-配置","depth":3,"charIndex":474},{"text":"tsconfig.json 配置","id":"tsconfigjson-配置","depth":3,"charIndex":548},{"text":"使用示例","id":"使用示例","depth":2,"charIndex":629},{"text":"导入服务内部模块","id":"导入服务内部模块","depth":3,"charIndex":637},{"text":"导入其他服务模块","id":"导入其他服务模块","depth":3,"charIndex":651},{"text":"跨服务导入","id":"跨服务导入","depth":3,"charIndex":731},{"text":"自定义别名","id":"自定义别名","depth":3,"charIndex":786}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架模块导入路径映射指南","description":"详细介绍 Gez 框架的路径别名机制，包括简化导入路径、避免深层嵌套、类型安全和模块解析优化等特性，帮助开发者提升代码可维护性。","head":[["meta",{"property":"keywords","content":"Gez, 路径别名, Path Alias, TypeScript, 模块导入, 路径映射, 代码可维护性"}]]},"version":""},{"id":336,"title":"基础路径","content":"#\n\n基础路径（Base Path）是指应用程序中静态资源（如 JavaScript、CSS、图片等）的访问路径前缀。在 Gez\n中，合理配置基础路径对于以下场景至关重要：\n\n * 多环境部署：支持开发环境、测试环境、生产环境等不同环境的资源访问\n * 多区域部署：适配不同地区或国家的集群部署需求\n * CDN 分发：实现静态资源的全球分发和加速\n\n\n默认路径机制#\n\nGez 采用基于服务名的自动路径生成机制。默认情况下，框架会读取项目 package.json 中的 name\n字段来生成静态资源的基础路径：/your-app-name/。\n\n\n\n这种约定优于配置的设计具有以下优势：\n\n * 一致性：确保所有静态资源使用统一的访问路径\n * 可预测性：通过 package.json 的 name 字段即可推断出资源的访问路径\n * 可维护性：无需额外配置，降低维护成本\n\n\n动态路径配置#\n\n在实际项目中，我们经常需要将同一套代码部署到不同的环境或区域。Gez 提供了动态基础路径的支持，使得应用程序能够适应不同的部署场景。\n\n\n使用场景#\n\n二级目录部署#\n\n\n\n独立域名部署#\n\n\n\n\n配置方法#\n\n通过 gez.render() 方法的 base 参数，你可以根据请求上下文动态设置基础路径：\n\n","routePath":"/guide/essentials/base-path","lang":"zh","toc":[{"text":"默认路径机制","id":"默认路径机制","depth":2,"charIndex":176},{"text":"动态路径配置","id":"动态路径配置","depth":2,"charIndex":391},{"text":"使用场景","id":"使用场景","depth":3,"charIndex":469},{"text":"二级目录部署","id":"二级目录部署","depth":4,"charIndex":476},{"text":"独立域名部署","id":"独立域名部署","depth":4,"charIndex":487},{"text":"配置方法","id":"配置方法","depth":3,"charIndex":499}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架静态资源路径配置指南","description":"详细介绍 Gez 框架的基础路径配置，包括多环境部署、CDN 分发和资源访问路径设置，帮助开发者实现灵活的静态资源管理。","head":[["meta",{"property":"keywords","content":"Gez, 基础路径, Base Path, CDN, 静态资源, 多环境部署, 资源管理"}]]},"version":""},{"id":337,"title":"客户端渲染","content":"\n${rc.importmap()} // 导入映射 ${rc.moduleEntry()} // 入口模块 ${rc.modulePreload()} //\n模块预加载","routePath":"/guide/essentials/csr","lang":"zh","toc":[{"text":"使用场景","id":"使用场景","depth":2,"charIndex":-1},{"text":"配置说明","id":"配置说明","depth":2,"charIndex":-1},{"text":"HTML 模板配置","id":"html-模板配置","depth":3,"charIndex":-1},{"text":"静态 HTML 生成","id":"静态-html-生成","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架客户端渲染实现指南","description":"详细介绍 Gez 框架的客户端渲染机制，包括静态构建、部署策略和最佳实践，帮助开发者在无服务器环境下实现高效的前端渲染。","head":[["meta",{"property":"keywords","content":"Gez, 客户端渲染, CSR, 静态构建, 前端渲染, 无服务器部署, 性能优化"}]]},"version":""},{"id":338,"title":"模块链接","content":"#\n\nGez 框架提供了一套完整的模块链接机制，用于管理服务间的代码共享和依赖关系。该机制基于 ESM（ECMAScript\nModule）规范实现，支持源码级别的模块导出和导入，以及完整的依赖管理功能。\n\n\n核心概念#\n\n模块导出#\n\n模块导出是将服务中的特定代码单元（如组件、工具函数等）以 ESM 格式对外暴露的过程。支持两种导出类型：\n\n * 源码导出：直接导出项目中的源代码文件\n * 依赖导出：导出项目使用的第三方依赖包\n\n模块导入#\n\n模块导入是在服务中引用其他服务导出的代码单元的过程。支持多种安装方式：\n\n * 源码安装：适用于开发环境，支持实时修改和热更新\n * 软件包安装：适用于生产环境，直接使用构建产物\n\n\n预加载机制#\n\n为了优化服务性能，Gez 实现了智能的模块预加载机制：\n\n 1. 依赖分析\n    \n    * 构建时分析组件间的依赖关系\n    * 识别关键路径上的核心模块\n    * 确定模块的加载优先级\n\n 2. 加载策略\n    \n    * 立即加载：关键路径上的核心模块\n    * 延迟加载：非关键功能模块\n    * 按需加载：条件渲染的模块\n\n 3. 资源优化\n    \n    * 智能的代码分割策略\n    * 模块级别的缓存管理\n    * 按需编译和打包\n\n\n模块导出#\n\n\n配置说明#\n\n在 entry.node.ts 中配置需要导出的模块：\n\n\n\n导出配置支持两种类型：\n\n * root:*：导出源码文件，路径相对于项目根目录\n * npm:*：导出第三方依赖，直接指定包名\n\n\n模块导入#\n\n\n配置说明#\n\n在 entry.node.ts 中配置需要导入的模块：\n\n\n\n配置项说明：\n\n 1. imports：配置远程模块的本地路径\n    \n    * 源码安装：指向构建产物目录（dist）\n    * 软件包安装：直接指向包目录\n\n 2. externals：配置外部依赖\n    \n    * 用于共享远程模块中的依赖\n    * 避免重复打包相同依赖\n    * 支持多个模块共享依赖\n\n\n安装方式#\n\n源码安装#\n\n适用于开发环境，支持实时修改和热更新。\n\n 1. Workspace 方式 推荐在 Monorepo 项目中使用：\n\n\n\n 2. Link 方式 用于本地开发调试：\n\n\n\n软件包安装#\n\n适用于生产环境，直接使用构建产物。\n\n 1. NPM Registry 通过 npm registry 安装：\n\n\n\n 2. 静态服务器 通过 HTTP/HTTPS 协议安装：\n\n\n\n\n软件包构建#\n\n\n配置说明#\n\n在 entry.node.ts 中配置构建选项：\n\n\n\n\n构建产物#\n\n\n\n\n发布流程#\n\n\n\n\n最佳实践#\n\n\n开发环境配置#\n\n * 依赖管理\n   \n   * 使用 Workspace 或 Link 方式安装依赖\n   * 统一管理依赖版本\n   * 避免重复安装相同依赖\n\n * 开发体验\n   \n   * 启用热更新功能\n   * 配置合适的预加载策略\n   * 优化构建速度\n\n\n生产环境配置#\n\n * 部署策略\n   \n   * 使用 NPM Registry 或静态服务器\n   * 确保构建产物完整性\n   * 实施灰度发布机制\n\n * 性能优化\n   \n   * 合理配置资源预加载\n   * 优化模块加载顺序\n   * 实施有效的缓存策略\n\n\n版本管理#\n\n * 版本规范\n   \n   * 遵循语义化版本规范\n   * 维护详细的更新日志\n   * 做好版本兼容性测试\n\n * 依赖更新\n   \n   * 及时更新依赖包\n   * 定期进行安全审计\n   * 保持依赖版本一致性","routePath":"/guide/essentials/module-link","lang":"zh","toc":[{"text":"核心概念","id":"核心概念","depth":3,"charIndex":104},{"text":"模块导出","id":"模块导出","depth":4,"charIndex":111},{"text":"模块导入","id":"模块导入","depth":4,"charIndex":217},{"text":"预加载机制","id":"预加载机制","depth":3,"charIndex":316},{"text":"模块导出","id":"模块导出-1","depth":2,"charIndex":561},{"text":"配置说明","id":"配置说明","depth":3,"charIndex":569},{"text":"模块导入","id":"模块导入-1","depth":2,"charIndex":674},{"text":"配置说明","id":"配置说明-1","depth":3,"charIndex":682},{"text":"安装方式","id":"安装方式","depth":3,"charIndex":885},{"text":"源码安装","id":"源码安装","depth":4,"charIndex":892},{"text":"软件包安装","id":"软件包安装","depth":4,"charIndex":985},{"text":"软件包构建","id":"软件包构建","depth":2,"charIndex":1086},{"text":"配置说明","id":"配置说明-2","depth":3,"charIndex":1095},{"text":"构建产物","id":"构建产物","depth":3,"charIndex":1131},{"text":"发布流程","id":"发布流程","depth":3,"charIndex":1141},{"text":"最佳实践","id":"最佳实践","depth":2,"charIndex":1151},{"text":"开发环境配置","id":"开发环境配置","depth":3,"charIndex":1159},{"text":"生产环境配置","id":"生产环境配置","depth":3,"charIndex":1298},{"text":"版本管理","id":"版本管理","depth":3,"charIndex":1435}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架服务间代码共享机制","description":"详细介绍 Gez 框架的模块链接机制，包括服务间代码共享、依赖管理和 ESM 规范实现，帮助开发者构建高效的微前端应用。","head":[["meta",{"property":"keywords","content":"Gez, 模块链接, Module Link, ESM, 代码共享, 依赖管理, 微前端"}]]},"version":""},{"id":339,"title":"渲染上下文","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/guide/essentials/render-context","lang":"zh","toc":[{"text":"使用方式","id":"使用方式","depth":2,"charIndex":-1},{"text":"主要功能","id":"主要功能","depth":2,"charIndex":-1},{"text":"依赖收集","id":"依赖收集","depth":3,"charIndex":-1},{"text":"按需收集","id":"按需收集","depth":4,"charIndex":-1},{"text":"自动化处理","id":"自动化处理","depth":4,"charIndex":-1},{"text":"性能优化","id":"性能优化","depth":4,"charIndex":-1},{"text":"资源注入","id":"资源注入","depth":3,"charIndex":-1},{"text":"资源注入顺序","id":"资源注入顺序","depth":3,"charIndex":-1},{"text":"完整渲染流程","id":"完整渲染流程","depth":2,"charIndex":-1},{"text":"高级特性","id":"高级特性","depth":2,"charIndex":-1},{"text":"基础路径配置","id":"基础路径配置","depth":3,"charIndex":-1},{"text":"导入映射模式","id":"导入映射模式","depth":3,"charIndex":-1},{"text":"入口函数配置","id":"入口函数配置","depth":3,"charIndex":-1},{"text":"最佳实践","id":"最佳实践","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架服务端渲染核心机制","description":"详细介绍 Gez 框架的渲染上下文（RenderContext）机制，包括资源管理、HTML 生成和 ESM 模块系统，帮助开发者理解和使用服务端渲染功能。","head":[["meta",{"property":"keywords","content":"Gez, 渲染上下文, RenderContext, SSR, 服务端渲染, ESM, 资源管理"}]]},"version":""},{"id":340,"title":"Rspack","content":"#\n\nGez 基于 Rspack 构建系统实现，充分利用了 Rspack 的高性能构建能力。本文档将介绍 Rspack 在 Gez 框架中的定位和核心功能。\n\n\n特性#\n\nRspack 是 Gez 框架的核心构建系统，它提供了以下关键特性：\n\n * 高性能构建：基于 Rust 实现的构建引擎，提供极速的编译性能，显著提升大型项目的构建速度\n * 开发体验优化：支持热更新（HMR）、增量编译等现代开发特性，提供流畅的开发体验\n * 多环境构建：统一的构建配置支持客户端（client）、服务端（server）和 Node.js（node）环境，简化多端开发流程\n * 资源优化：内置的资源处理和优化能力，支持代码分割、Tree Shaking、资源压缩等特性\n\n\n构建应用#\n\nGez 的 Rspack 构建系统采用模块化设计，主要包含以下核心模块：\n\n\n@gez/rspack#\n\n基础构建模块，提供以下核心能力：\n\n * 统一构建配置：提供标准化的构建配置管理，支持多环境配置\n * 资源处理：内置对 TypeScript、CSS、图片等资源的处理能力\n * 构建优化：提供代码分割、Tree Shaking 等性能优化特性\n * 开发服务器：集成高性能的开发服务器，支持 HMR\n\n\n@gez/rspack-vue#\n\nVue 框架专用构建模块，提供：\n\n * Vue 组件编译：支持 Vue 2/3 组件的高效编译\n * SSR 优化：针对服务端渲染场景的特定优化\n * 开发增强：Vue 开发环境的特定功能增强\n\n\n构建流程#\n\nGez 的构建流程主要分为以下几个阶段：\n\n 1. 配置初始化\n    \n    * 加载项目配置\n    * 合并默认配置和用户配置\n    * 根据环境变量调整配置\n\n 2. 资源编译\n    \n    * 解析源代码依赖\n    * 转换各类资源（TypeScript、CSS 等）\n    * 处理模块导入导出\n\n 3. 优化处理\n    \n    * 执行代码分割\n    * 应用 Tree Shaking\n    * 压缩代码和资源\n\n 4. 输出生成\n    \n    * 生成目标文件\n    * 输出资源映射\n    * 生成构建报告\n\n\n最佳实践#\n\n\n开发环境优化#\n\n * 增量编译配置：合理配置 cache 选项，利用缓存加快构建速度\n * HMR 优化：针对性配置热更新范围，避免不必要的模块更新\n * 资源处理优化：使用适当的 loader 配置，避免重复处理\n\n\n生产环境优化#\n\n * 代码分割策略：合理配置 splitChunks，优化资源加载\n * 资源压缩：启用适当的压缩配置，平衡构建时间和产物大小\n * 缓存优化：利用内容哈希和长期缓存策略，提升加载性能\n\n\n配置示例#\n\n\n\nTIP\n\n更多详细的 API 说明和配置选项，请参考 Rspack API 文档。","routePath":"/guide/essentials/rspack","lang":"zh","toc":[{"text":"特性","id":"特性","depth":2,"charIndex":80},{"text":"构建应用","id":"构建应用","depth":2,"charIndex":332},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":378},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":545},{"text":"构建流程","id":"构建流程","depth":2,"charIndex":663},{"text":"最佳实践","id":"最佳实践","depth":2,"charIndex":950},{"text":"开发环境优化","id":"开发环境优化","depth":3,"charIndex":958},{"text":"生产环境优化","id":"生产环境优化","depth":3,"charIndex":1069},{"text":"配置示例","id":"配置示例","depth":2,"charIndex":1173}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架高性能构建引擎","description":"深入解析 Gez 框架的 Rspack 构建系统，包括高性能编译、多环境构建、资源优化等核心特性，助力开发者构建高效、可靠的现代 Web 应用。","head":[["meta",{"property":"keywords","content":"Gez, Rspack, 构建系统, 高性能编译, 热更新, 多环境构建, Tree Shaking, 代码分割, SSR, 资源优化, 开发效率, 构建工具"}]]},"version":""},{"id":341,"title":"标准规范","content":"#\n\nGez 是一个现代化的 SSR 框架，采用标准化的项目结构和路径解析机制，以确保项目在开发和生产环境中的一致性和可维护性。\n\n\n项目结构规范#\n\n\n标准目录结构#\n\n\n\n拓展知识\n * gez.name 来源于 package.json 的 name 字段\n * dist/package.json 来源于根目录的 package.json\n * 设置 packs.enable 为 true 时，才会对 dist 目录进行归档\n\n\n入口文件规范#\n\n\nentry.client.ts#\n\n客户端入口文件负责：\n\n * 初始化应用：配置客户端应用的基础设置\n * 路由管理：处理客户端路由和导航\n * 状态管理：实现客户端状态的存储和更新\n * 交互处理：管理用户事件和界面交互\n\n\nentry.server.ts#\n\n服务端入口文件负责：\n\n * 服务端渲染：执行 SSR 渲染流程\n * HTML 生成：构建初始页面结构\n * 数据预取：处理服务端数据获取\n * 状态注入：将服务端状态传递给客户端\n * SEO 优化：确保页面的搜索引擎优化\n\n\nentry.node.ts#\n\nNode.js 服务器入口文件负责：\n\n * 服务器配置：设置 HTTP 服务器参数\n * 路由处理：管理服务端路由规则\n * 中间件集成：配置服务器中间件\n * 环境管理：处理环境变量和配置\n * 请求响应：处理 HTTP 请求和响应\n\n\n配置文件规范#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/guide/essentials/std","lang":"zh","toc":[{"text":"项目结构规范","id":"项目结构规范","depth":2,"charIndex":66},{"text":"标准目录结构","id":"标准目录结构","depth":3,"charIndex":76},{"text":"入口文件规范","id":"入口文件规范","depth":2,"charIndex":219},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":229},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":344},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":478},{"text":"配置文件规范","id":"配置文件规范","depth":2,"charIndex":615},{"text":"package.json","id":"packagejson","depth":3,"charIndex":625},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":643}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架项目结构与规范指南","description":"详细介绍 Gez 框架的标准项目结构、入口文件规范和配置文件规范，帮助开发者构建规范化、可维护的 SSR 应用。","head":[["meta",{"property":"keywords","content":"Gez, 项目结构, 入口文件, 配置规范, SSR框架, TypeScript, 项目规范, 开发标准"}]]},"version":""},{"id":342,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/guide/frameworks/html","lang":"zh","toc":[{"text":"项目结构","id":"项目结构","depth":2,"charIndex":-1},{"text":"项目配置","id":"项目配置","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"源码结构","id":"源码结构","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"运行项目","id":"运行项目","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架 HTML SSR 应用示例","description":"从零开始搭建基于 Gez 的 HTML SSR 应用，通过实例展示框架的基本用法，包括项目初始化、HTML 配置和入口文件设置。","head":[["meta",{"property":"keywords","content":"Gez, HTML, SSR应用, TypeScript配置, 项目初始化, 服务端渲染, 客户端交互"}]]},"version":""},{"id":343,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/guide/frameworks/preact-htm","lang":"zh","toc":[{"text":"项目结构","id":"项目结构","depth":2,"charIndex":-1},{"text":"项目配置","id":"项目配置","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"源码结构","id":"源码结构","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"运行项目","id":"运行项目","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架 Preact+HTM SSR 应用示例","description":"从零开始搭建基于 Gez 的 Preact+HTM SSR 应用，通过实例展示框架的基本用法，包括项目初始化、Preact 配置和入口文件设置。","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, SSR应用, TypeScript配置, 项目初始化, 服务端渲染, 客户端交互"}]]},"version":""},{"id":344,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/guide/frameworks/vue2","lang":"zh","toc":[{"text":"项目结构","id":"项目结构","depth":2,"charIndex":-1},{"text":"项目配置","id":"项目配置","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"源码结构","id":"源码结构","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"运行项目","id":"运行项目","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架 Vue2 SSR 应用示例","description":"从零开始搭建基于 Gez 的 Vue2 SSR 应用，通过实例展示框架的基本用法，包括项目初始化、Vue2 配置和入口文件设置。","head":[["meta",{"property":"keywords","content":"Gez, Vue2, SSR应用, TypeScript配置, 项目初始化, 服务端渲染, 客户端交互"}]]},"version":""},{"id":345,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/guide/frameworks/vue3","lang":"zh","toc":[{"text":"项目结构","id":"项目结构","depth":2,"charIndex":-1},{"text":"项目配置","id":"项目配置","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"源码结构","id":"源码结构","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"运行项目","id":"运行项目","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架 Vue3 SSR 应用示例","description":"从零开始搭建基于 Gez 的 Vue3 SSR 应用，通过实例展示框架的基本用法，包括项目初始化、Vue3 配置和入口文件设置。","head":[["meta",{"property":"keywords","content":"Gez, Vue3, SSR应用, TypeScript配置, 项目初始化, 服务端渲染, 客户端交互, 组合式API"}]]},"version":""},{"id":346,"title":"环境要求","content":"#\n\n本文档介绍了使用本框架所需的环境要求，包括 Node.js 环境和浏览器兼容性。\n\n\nNode.js 环境#\n\n框架要求 Node.js 版本 >= 22.6，主要用于支持 TypeScript 类型导入（通过 --experimental-strip-types\n标志），无需额外编译步骤。\n\n\n浏览器兼容性#\n\n框架默认采用兼容模式构建，以支持更广泛的浏览器。但需要注意，要实现完整的浏览器兼容支持，需要手动添加 es-module-shims 依赖。\n\n\n兼容模式（默认）#\n\n * 🌐 Chrome：>= 87\n * 🔷 Edge：>= 88\n * 🦊 Firefox：>= 78\n * 🧭 Safari：>= 14\n\n根据 Can I Use 的统计数据，兼容模式下的浏览器覆盖率达到 96.81%。\n\n\n原生支持模式#\n\n * 🌐 Chrome：>= 89\n * 🔷 Edge：>= 89\n * 🦊 Firefox：>= 108\n * 🧭 Safari：>= 16.4\n\n原生支持模式具有以下优势：\n\n * 零运行时开销，无需额外的模块加载器\n * 浏览器原生解析，更快的执行速度\n * 更好的代码分割和按需加载能力\n\n根据 Can I Use 的统计数据，兼容模式下的浏览器覆盖率达到 93.5%。\n\n\n启用兼容支持#\n\n重要提示\n\n虽然框架默认使用兼容模式构建，但要实现对旧版浏览器的完整支持，您需要在项目中添加 es-module-shims 依赖。\n\n在 HTML 文件中添加以下脚本：\n\n\n\n最佳实践\n 1. 生产环境建议：\n    * 将 es-module-shims 部署到自有服务器\n    * 确保资源加载的稳定性和访问速度\n    * 避免潜在的安全风险\n 2. 性能考虑：\n    * 兼容模式会带来少量性能开销\n    * 可以根据目标用户群的浏览器分布决定是否启用","routePath":"/guide/start/environment","lang":"zh","toc":[{"text":"Node.js 环境","id":"nodejs-环境","depth":2,"charIndex":45},{"text":"浏览器兼容性","id":"浏览器兼容性","depth":2,"charIndex":151},{"text":"兼容模式（默认）","id":"兼容模式默认","depth":3,"charIndex":233},{"text":"原生支持模式","id":"原生支持模式","depth":3,"charIndex":364},{"text":"启用兼容支持","id":"启用兼容支持","depth":3,"charIndex":569}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架兼容性指南","description":"详细介绍 Gez 框架的环境要求，包括 Node.js 版本要求和浏览器兼容性说明，帮助开发者正确配置开发环境。","head":[["meta",{"property":"keywords","content":"Gez, Node.js, 浏览器兼容性, TypeScript, es-module-shims, 环境配置"}]]},"version":""},{"id":347,"title":"快速开始","content":"#\n\n\n项目初始化#\n\n创建并初始化一个新的 Gez 项目，请按照以下步骤操作：\n\n\n\n\n框架版本选择#\n\nGez 框架提供了多个技术栈版本，每个版本都针对不同的应用场景进行了优化。请根据项目需求选择合适的版本：\n\n\nHTML#\n\n适用于追求极简架构的项目：\n\n * 零外部依赖，启动即用\n * 原生 JavaScript 开发体验\n * 适合构建静态网站和轻量级应用\n * 支持渐进式功能扩展\n\n查看 HTML 版本详细文档\n\n\nVue2#\n\n适用于企业级应用开发：\n\n * 完整的 TypeScript 支持\n * 丰富的第三方组件生态\n * 成熟的开发工具链\n * 经过生产环境验证的稳定性\n\n查看 Vue2 版本详细文档\n\n\nVue3#\n\n适用于现代化 Web 应用开发：\n\n * 基于 Proxy 的响应式系统\n * 组合式 API 支持\n * 更优的运行时性能\n * 更小的打包体积\n\n查看 Vue3 版本详细文档\n\n\nPreact+HTM#\n\n适用于追求轻量级和高性能的项目：\n\n * 极小的运行时体积（3KB）\n * 原生 JavaScript 模板语法\n * 与 React 兼容的 API\n * 优秀的性能表现\n\n查看 Preact+HTM 版本详细文档\n\n\nAI 辅助开发#\n\nGez 框架提供了 AI 辅助开发能力，可以显著提升开发效率：\n\n 1. 选择适合的框架版本文档\n 2. 将文档内容提供给 AI 助手\n 3. AI 将自动生成项目骨架和配置文件\n\n提示\n\nAI 辅助开发不仅能加快项目初始化速度，还能确保项目结构符合最佳实践。","routePath":"/guide/start/getting-started","lang":"zh","toc":[{"text":"项目初始化","id":"项目初始化","depth":2,"charIndex":3},{"text":"框架版本选择","id":"框架版本选择","depth":2,"charIndex":44},{"text":"HTML","id":"html","depth":3,"charIndex":108},{"text":"Vue2","id":"vue2","depth":3,"charIndex":215},{"text":"Vue3","id":"vue3","depth":3,"charIndex":316},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":415},{"text":"AI 辅助开发","id":"ai-辅助开发","depth":2,"charIndex":539}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架快速入门指南","description":"Gez 框架快速入门指南，帮助你从零开始搭建项目，包括项目初始化、框架版本选择以及 AI 辅助开发等内容。","head":[["meta",{"name":"keywords","content":"Gez框架, 快速开始, 项目初始化, Vue开发, HTML开发, AI辅助"}]]},"version":""},{"id":348,"title":"介绍","content":"#\n\n\n项目背景#\n\nGez 是一个基于 ECMAScript Modules (ESM) 的现代微前端框架，专注于构建高性能、可扩展的服务端渲染（SSR）应用。作为 Genesis\n项目的第三代产品，Gez 在技术演进过程中不断创新：\n\n * v1.0：基于 HTTP 请求实现远程组件按需加载\n * v2.0：基于 Webpack Module Federation 实现应用集成\n * v3.0：基于浏览器原生 ESM 重新设计模块链接系统\n\n\n技术背景#\n\n在微前端架构发展过程中，传统解决方案主要存在以下局限：\n\n\n现有方案的挑战#\n\n * 性能瓶颈：运行时依赖注入和 JavaScript 沙箱代理带来显著的性能开销\n * 隔离机制：自研沙箱环境难以企及浏览器原生的模块隔离能力\n * 构建复杂性：为实现依赖共享而进行的构建工具改造，增加了项目维护成本\n * 标准偏离：特殊的部署策略和运行时处理机制，与现代 Web 开发标准相悖\n * 生态限制：框架耦合和定制 API 导致技术栈选择受限\n\n\n技术创新#\n\nGez 基于现代 Web 标准，提供了全新的解决方案：\n\n * 原生模块系统：利用浏览器原生 ESM 和 Import Maps 实现依赖管理，具有更快的解析和执行速度\n * 标准隔离机制：基于 ECMAScript 模块作用域实现可靠的应用隔离\n * 开放技术栈：支持任意现代前端框架的无缝接入\n * 优化开发体验：提供符合直觉的开发模式和完整的调试能力\n * 极致性能优化：通过原生能力实现零运行时开销，配合智能缓存策略\n\nTIP\n\nGez 专注于打造高性能、易扩展的微前端基础设施，尤其适合大规模服务端渲染应用场景。\n\n\n技术规范#\n\n\n环境依赖#\n\n请参考环境要求文档了解详细的浏览器和 Node.js 环境要求。\n\n\n核心技术栈#\n\n * 依赖管理：采用 Import Maps 实现模块映射，使用 es-module-shims 提供兼容支持\n * 构建系统：基于 Rspack 的 module-import 处理外部依赖\n * 开发工具链：支持 ESM 热更新和 TypeScript 原生执行\n\n\n框架定位#\n\nGez 不同于 Next.js 或 Nuxt.js，而是专注于提供微前端基础设施：\n\n * 模块链接系统：实现高效、可靠的模块导入导出\n * 服务端渲染：提供灵活的 SSR 实现机制\n * 类型系统支持：集成完整的 TypeScript 类型定义\n * 框架中立性：支持主流前端框架集成\n\n\n架构设计#\n\n\n中心化依赖管理#\n\n * 统一依赖源：集中化的第三方依赖管理\n * 自动化分发：依赖更新的全局自动同步\n * 版本一致性：精确的依赖版本控制\n\n\n模块化设计#\n\n * 职责分离：业务逻辑与基础设施解耦\n * 插件机制：支持模块的灵活组合与替换\n * 标准接口：规范化的模块间通信协议\n\n\n性能优化#\n\n * 零开销原则：最大化利用浏览器原生能力\n * 智能缓存：基于内容哈希的精确缓存策略\n * 按需加载：精细化的代码分割与依赖管理\n\n\n项目成熟度#\n\nGez 通过近 5 年的迭代演进（v1.0 至\nv3.0），已在企业级环境中得到全面验证。目前支撑数十个业务项目稳定运行，并持续推动技术栈现代化升级。框架的稳定性、可靠性和性能优势已在实践中得到充分检验，为大\n规模应用开发提供了可靠的技术基础。","routePath":"/guide/start/introduction","lang":"zh","toc":[{"text":"项目背景","id":"项目背景","depth":2,"charIndex":3},{"text":"技术背景","id":"技术背景","depth":2,"charIndex":225},{"text":"现有方案的挑战","id":"现有方案的挑战","depth":3,"charIndex":262},{"text":"技术创新","id":"技术创新","depth":3,"charIndex":453},{"text":"技术规范","id":"技术规范","depth":2,"charIndex":724},{"text":"环境依赖","id":"环境依赖","depth":3,"charIndex":732},{"text":"核心技术栈","id":"核心技术栈","depth":3,"charIndex":774},{"text":"框架定位","id":"框架定位","depth":2,"charIndex":918},{"text":"架构设计","id":"架构设计","depth":2,"charIndex":1071},{"text":"中心化依赖管理","id":"中心化依赖管理","depth":3,"charIndex":1079},{"text":"模块化设计","id":"模块化设计","depth":3,"charIndex":1152},{"text":"性能优化","id":"性能优化","depth":3,"charIndex":1223},{"text":"项目成熟度","id":"项目成熟度","depth":2,"charIndex":1298}],"domain":"","frontmatter":{"titleSuffix":"Gez 框架概述与技术创新","description":"深入了解 Gez 微前端框架的项目背景、技术演进和核心优势，探索基于 ESM 的现代化服务端渲染解决方案。","head":[["meta",{"property":"keywords","content":"Gez, 微前端, ESM, 服务端渲染, SSR, 技术创新, 模块联邦"}]]},"version":""}]