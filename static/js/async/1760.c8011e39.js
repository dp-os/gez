"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["1760"],{4911:function(e,i,n){n.r(i),n.d(i,{default:()=>t});var o=n(1549),a=n(6603);function r(e){let i=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,a.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(i.h1,{id:"dalla-condivisione-dei-componenti-alla-modularit\\xe0-nativa-il-percorso-evolutivo-del-framework-micro-frontend-gez",children:["Dalla condivisione dei componenti alla modularit\xe0 nativa: il percorso evolutivo del framework micro-frontend Gez",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#dalla-condivisione-dei-componenti-alla-modularit\\xe0-nativa-il-percorso-evolutivo-del-framework-micro-frontend-gez",children:"#"})]}),"\n",(0,o.jsxs)(i.h2,{id:"contesto-del-progetto",children:["Contesto del progetto",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#contesto-del-progetto",children:"#"})]}),"\n",(0,o.jsx)(i.p,{children:"Negli ultimi anni, l'architettura micro-frontend ha cercato di trovare la strada giusta. Tuttavia, abbiamo assistito a varie soluzioni tecniche complesse che, attraverso stratificazioni e isolamenti artificiali, cercano di simulare un mondo ideale di micro-frontend. Queste soluzioni hanno portato a un pesante carico sulle prestazioni, rendendo lo sviluppo semplice complesso e i processi standard oscuri."}),"\n",(0,o.jsxs)(i.h3,{id:"limitazioni-delle-soluzioni-tradizionali",children:["Limitazioni delle soluzioni tradizionali",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#limitazioni-delle-soluzioni-tradizionali",children:"#"})]}),"\n",(0,o.jsx)(i.p,{children:"Nella pratica dell'architettura micro-frontend, abbiamo riscontrato numerose limitazioni delle soluzioni tradizionali:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Perdita di prestazioni"}),": l'iniezione delle dipendenze a runtime, il proxy della sandbox JS, ogni operazione consuma preziose risorse di prestazioni"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Isolamento fragile"}),": l'ambiente sandbox creato artificialmente non pu\xf2 mai raggiungere le capacit\xe0 di isolamento nativo del browser"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Complessit\xe0 di build"}),": per gestire le dipendenze, \xe8 necessario modificare gli strumenti di build, rendendo i progetti semplici difficili da mantenere"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Regole personalizzate"}),": strategie di distribuzione speciali, elaborazione a runtime, ogni passo si allontana dai processi standard di sviluppo moderno"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Limitazioni dell'ecosistema"}),": accoppiamento con il framework, API personalizzate, costringendo la scelta tecnologica a legarsi a un ecosistema specifico"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Questi problemi sono emersi in modo particolarmente evidente in un progetto aziendale del 2019. All'epoca, un grande prodotto \xe8 stato suddiviso in una dozzina di sottosistemi aziendali indipendenti, che dovevano condividere un set di componenti di base e aziendali. La soluzione iniziale basata su pacchetti npm per la condivisione dei componenti ha rivelato gravi problemi di efficienza di manutenzione: quando un componente condiviso veniva aggiornato, tutti i sottosistemi che dipendevano da quel componente dovevano passare attraverso un processo completo di build e distribuzione."}),"\n",(0,o.jsxs)(i.h2,{id:"evoluzione-tecnologica",children:["Evoluzione tecnologica",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#evoluzione-tecnologica",children:"#"})]}),"\n",(0,o.jsxs)(i.h3,{id:"v10-esplorazione-dei-componenti-remoti",children:["v1.0: Esplorazione dei componenti remoti",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#v10-esplorazione-dei-componenti-remoti",children:"#"})]}),"\n",(0,o.jsx)(i.p,{children:"Per risolvere i problemi di efficienza nella condivisione dei componenti, Gez v1.0 ha introdotto un meccanismo di componenti RemoteView basato sul protocollo HTTP. Questa soluzione ha implementato l'assemblaggio dinamico del codice tra servizi attraverso richieste runtime, risolvendo con successo il problema delle lunghe catene di dipendenze di build. Tuttavia, a causa della mancanza di un meccanismo standardizzato di comunicazione runtime, la sincronizzazione dello stato e il passaggio di eventi tra servizi rimanevano un collo di bottiglia."}),"\n",(0,o.jsxs)(i.h3,{id:"v20-tentativo-di-module-federation",children:["v2.0: Tentativo di Module Federation",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#v20-tentativo-di-module-federation",children:"#"})]}),"\n",(0,o.jsxs)(i.p,{children:["Nella versione v2.0, abbiamo adottato la tecnologia ",(0,o.jsx)(i.a,{href:"https://webpack.js.org/concepts/module-federation/",target:"_blank",rel:"noopener noreferrer",children:"Module Federation"})," di ",(0,o.jsx)(i.a,{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer",children:"Webpack 5.0"}),". Questa tecnologia, attraverso un meccanismo unificato di caricamento dei moduli e un contenitore runtime, ha migliorato significativamente l'efficienza della collaborazione tra servizi. Tuttavia, nella pratica su larga scala, il meccanismo chiuso di implementazione di Module Federation ha portato nuove sfide: difficolt\xe0 nella gestione precisa delle versioni delle dipendenze, specialmente nell'unificazione delle dipendenze condivise tra pi\xf9 servizi, spesso si verificavano conflitti di versione e anomalie runtime."]}),"\n",(0,o.jsxs)(i.h2,{id:"abbracciare-la-nuova-era-di-esm",children:["Abbracciare la nuova era di ESM",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#abbracciare-la-nuova-era-di-esm",children:"#"})]}),"\n",(0,o.jsx)(i.p,{children:"Nella pianificazione della versione v3.0, abbiamo osservato attentamente le tendenze di sviluppo dell'ecosistema frontend, scoprendo che i progressi nelle capacit\xe0 native del browser hanno portato nuove possibilit\xe0 all'architettura micro-frontend:"}),"\n",(0,o.jsxs)(i.h3,{id:"sistema-di-moduli-standardizzato",children:["Sistema di moduli standardizzato",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#sistema-di-moduli-standardizzato",children:"#"})]}),"\n",(0,o.jsxs)(i.p,{children:["Con il supporto completo dei principali browser per ",(0,o.jsx)(i.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer",children:"ES Modules"})," e la maturazione della specifica ",(0,o.jsx)(i.a,{href:"https://github.com/WICG/import-maps",target:"_blank",rel:"noopener noreferrer",children:"Import Maps"}),", lo sviluppo frontend \xe8 entrato in una vera era di modularit\xe0. Secondo le statistiche di ",(0,o.jsx)(i.a,{href:"https://caniuse.com/?search=importmap",target:"_blank",rel:"noopener noreferrer",children:"Can I Use"}),", il supporto nativo per ESM nei principali browser (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) ha raggiunto il 93.5%, offrendoci i seguenti vantaggi:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Gestione delle dipendenze standardizzata"}),": Import Maps fornisce la capacit\xe0 di risolvere le dipendenze dei moduli a livello di browser, senza bisogno di complesse iniezioni runtime"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Ottimizzazione del caricamento delle risorse"}),": il meccanismo di cache nativo dei moduli del browser migliora significativamente l'efficienza del caricamento delle risorse"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Semplificazione del processo di build"}),": il modello di sviluppo basato su ESM rende i processi di build per l'ambiente di sviluppo e produzione pi\xf9 coerenti"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Inoltre, attraverso il supporto della modalit\xe0 di compatibilit\xe0 (Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14), possiamo aumentare ulteriormente la copertura del browser al 96.81%, permettendoci di mantenere alte prestazioni senza sacrificare il supporto per i browser pi\xf9 vecchi."}),"\n",(0,o.jsxs)(i.h3,{id:"progressi-nelle-prestazioni-e-nellisolamento",children:["Progressi nelle prestazioni e nell'isolamento",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#progressi-nelle-prestazioni-e-nellisolamento",children:"#"})]}),"\n",(0,o.jsx)(i.p,{children:"Il sistema di moduli nativo porta non solo standardizzazione, ma anche un miglioramento qualitativo nelle prestazioni e nell'isolamento:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Zero overhead runtime"}),": addio ai proxy sandbox JavaScript e alle iniezioni runtime delle soluzioni micro-frontend tradizionali"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Meccanismo di isolamento affidabile"}),": il rigoroso ambito dei moduli ESM fornisce naturalmente la capacit\xe0 di isolamento pi\xf9 affidabile"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Gestione precisa delle dipendenze"}),": l'analisi statica delle importazioni rende le relazioni di dipendenza pi\xf9 chiare e il controllo delle versioni pi\xf9 preciso"]}),"\n"]}),"\n",(0,o.jsxs)(i.h3,{id:"scelta-degli-strumenti-di-build",children:["Scelta degli strumenti di build",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#scelta-degli-strumenti-di-build",children:"#"})]}),"\n",(0,o.jsx)(i.p,{children:"Nell'implementazione della soluzione tecnologica, la scelta degli strumenti di build \xe8 stata un punto decisionale cruciale. Dopo quasi un anno di ricerca e pratica, la nostra scelta ha attraversato la seguente evoluzione:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Esplorazione di Vite"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Vantaggi: server di sviluppo basato su ESM, offre un'esperienza di sviluppo estrema"}),"\n",(0,o.jsx)(i.li,{children:"Sfide: le differenze di build tra ambiente di sviluppo e produzione portano a una certa incertezza"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:(0,o.jsxs)(i.strong,{children:["Conferma di ",(0,o.jsx)(i.a,{href:"https://www.rspack.dev/",target:"_blank",rel:"noopener noreferrer",children:"Rspack"})]})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Vantaggi prestazionali: compilazione ad alte prestazioni basata su ",(0,o.jsx)(i.a,{href:"https://www.rust-lang.org/",target:"_blank",rel:"noopener noreferrer",children:"Rust"}),", migliora significativamente la velocit\xe0 di build"]}),"\n",(0,o.jsx)(i.li,{children:"Supporto dell'ecosistema: alta compatibilit\xe0 con l'ecosistema Webpack, riduce i costi di migrazione"}),"\n",(0,o.jsx)(i.li,{children:"Supporto ESM: attraverso la pratica del progetto Rslib, ha verificato l'affidabilit\xe0 nella build ESM"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Questa decisione ci ha permesso di mantenere un'esperienza di sviluppo eccellente, ottenendo al contempo un supporto pi\xf9 stabile per l'ambiente di produzione. Basandoci sulla combinazione di ESM e Rspack, abbiamo finalmente costruito una soluzione micro-frontend ad alte prestazioni e a bassa invasivit\xe0."}),"\n",(0,o.jsxs)(i.h2,{id:"prospettive-future",children:["Prospettive future",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#prospettive-future",children:"#"})]}),"\n",(0,o.jsx)(i.p,{children:"Nel piano di sviluppo futuro, il framework Gez si concentrer\xe0 su tre direzioni principali:"}),"\n",(0,o.jsxs)(i.h3,{id:"ottimizzazione-approfondita-di-import-maps",children:["Ottimizzazione approfondita di Import Maps",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#ottimizzazione-approfondita-di-import-maps",children:"#"})]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Gestione dinamica delle dipendenze"}),": implementazione di uno scheduling intelligente delle versioni delle dipendenze a runtime, risolvendo i conflitti di dipendenza tra pi\xf9 applicazioni"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Strategie di pre-caricamento"}),": pre-caricamento intelligente basato sull'analisi delle route, migliorando l'efficienza del caricamento delle risorse"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Ottimizzazione della build"}),": generazione automatica della configurazione Import Maps ottimale, riducendo i costi di configurazione manuale per gli sviluppatori"]}),"\n"]}),"\n",(0,o.jsxs)(i.h3,{id:"soluzione-di-routing-indipendente-dal-framework",children:["Soluzione di routing indipendente dal framework",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#soluzione-di-routing-indipendente-dal-framework",children:"#"})]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Astrazione unificata del routing"}),": progettazione di un'interfaccia di routing indipendente dal framework, supportando framework principali come Vue, React"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Routing delle micro-applicazioni"}),": implementazione del collegamento delle route tra applicazioni, mantenendo la coerenza tra URL e stato dell'applicazione"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Middleware di routing"}),": fornitura di un meccanismo di middleware estensibile, supportando il controllo degli accessi, le transizioni di pagina, ecc."]}),"\n"]}),"\n",(0,o.jsxs)(i.h3,{id:"migliori-pratiche-per-la-comunicazione-tra-framework",children:["Migliori pratiche per la comunicazione tra framework",(0,o.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#migliori-pratiche-per-la-comunicazione-tra-framework",children:"#"})]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Applicazione di esempio"}),": fornitura di un esempio completo di comunicazione tra framework, coprendo framework principali come Vue, React, Preact"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Sincronizzazione dello stato"}),": soluzione di condivisione dello stato leggera basata su ESM"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Event bus"}),": meccanismo standardizzato di comunicazione degli eventi, supportando la comunicazione disaccoppiata tra applicazioni"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"Attraverso queste ottimizzazioni ed estensioni, ci aspettiamo che Gez diventi una soluzione micro-frontend pi\xf9 completa e facile da usare, offrendo agli sviluppatori una migliore esperienza di sviluppo e una maggiore efficienza."})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:i}=Object.assign({},(0,a.ah)(),e.components);return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(r,{...e})}):r(e)}let t=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["it%2Fblog%2Fbirth-of-gez.md"]={toc:[{text:"Contesto del progetto",id:"contesto-del-progetto",depth:2},{text:"Limitazioni delle soluzioni tradizionali",id:"limitazioni-delle-soluzioni-tradizionali",depth:3},{text:"Evoluzione tecnologica",id:"evoluzione-tecnologica",depth:2},{text:"v1.0: Esplorazione dei componenti remoti",id:"v10-esplorazione-dei-componenti-remoti",depth:3},{text:"v2.0: Tentativo di Module Federation",id:"v20-tentativo-di-module-federation",depth:3},{text:"Abbracciare la nuova era di ESM",id:"abbracciare-la-nuova-era-di-esm",depth:2},{text:"Sistema di moduli standardizzato",id:"sistema-di-moduli-standardizzato",depth:3},{text:"Progressi nelle prestazioni e nell'isolamento",id:"progressi-nelle-prestazioni-e-nellisolamento",depth:3},{text:"Scelta degli strumenti di build",id:"scelta-degli-strumenti-di-build",depth:3},{text:"Prospettive future",id:"prospettive-future",depth:2},{text:"Ottimizzazione approfondita di Import Maps",id:"ottimizzazione-approfondita-di-import-maps",depth:3},{text:"Soluzione di routing indipendente dal framework",id:"soluzione-di-routing-indipendente-dal-framework",depth:3},{text:"Migliori pratiche per la comunicazione tra framework",id:"migliori-pratiche-per-la-comunicazione-tra-framework",depth:3}],title:"Dalla condivisione dei componenti alla modularit\xe0 nativa: il percorso evolutivo del framework micro-frontend Gez",headingTitle:"Dalla condivisione dei componenti alla modularit\xe0 nativa: il percorso evolutivo del framework micro-frontend Gez",frontmatter:{titleSuffix:"Dalle difficolt\xe0 del micro-frontend all'innovazione ESM: il percorso evolutivo del framework Gez",description:"Approfondisci il percorso evolutivo del framework Gez, dalle difficolt\xe0 dell'architettura micro-frontend tradizionale alle innovazioni basate su ESM, condividendo esperienze pratiche su ottimizzazione delle prestazioni, gestione delle dipendenze e scelta degli strumenti di build.",head:[["meta",{property:"keywords",content:"Gez, framework micro-frontend, ESM, Import Maps, Rspack, Module Federation, gestione delle dipendenze, ottimizzazione delle prestazioni, evoluzione tecnologica, rendering lato server"}]],sidebar:!1}}}}]);