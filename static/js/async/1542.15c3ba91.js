"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["1542"],{1221:function(e,n,s){s.r(n),s.d(n,{default:()=>a});var r=s(1549),i=s(6603);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",strong:"strong",code:"code",h2:"h2",h3:"h3",pre:"pre",div:"div",ol:"ol"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"경로-별칭",children:["경로 별칭",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#경로-별칭",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"경로 별칭(Path Alias)은 모듈 임포트 경로 매핑 메커니즘으로, 개발자가 완전한 모듈 경로 대신 짧고 의미 있는 식별자를 사용할 수 있게 해줍니다. Gez에서 경로 별칭 메커니즘은 다음과 같은 장점을 제공합니다:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"임포트 경로 단순화"}),": 의미 있는 별칭을 사용하여 긴 상대 경로를 대체함으로써 코드 가독성을 높입니다."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"깊은 중첩 방지"}),": ",(0,r.jsx)(n.code,{children:"../../../../"}),"와 같은 다중 디렉토리 참조로 인한 유지보수 어려움을 해결합니다."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"타입 안전성"}),": TypeScript의 타입 시스템과 완전히 통합되어 코드 완성 및 타입 검사를 제공합니다."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"모듈 해석 최적화"}),": 미리 정의된 경로 매핑을 통해 모듈 해석 성능을 향상시킵니다."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"기본-별칭-메커니즘",children:["기본 별칭 메커니즘",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#기본-별칭-메커니즘",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Gez는 서비스 이름(Service Name) 기반의 자동 별칭 메커니즘을 사용하며, 이는 설정보다 규약을 우선하는 설계로 다음과 같은 특징을 가집니다:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"자동 구성"}),": ",(0,r.jsx)(n.code,{children:"package.json"}),"의 ",(0,r.jsx)(n.code,{children:"name"})," 필드를 기반으로 별칭이 자동 생성되며, 수동 설정이 필요 없습니다."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"통일된 규범"}),": 모든 서비스 모듈이 일관된 명명 및 참조 규칙을 따르도록 보장합니다."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"타입 지원"}),": ",(0,r.jsx)(n.code,{children:"npm run build:dts"})," 명령어와 함께 사용하여 타입 선언 파일을 자동 생성함으로써, 서비스 간 타입 추론을 가능하게 합니다."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"예측 가능성"}),": 서비스 이름을 통해 모듈 참조 경로를 추론할 수 있어 유지보수 비용을 줄입니다."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"설정-설명",children:["설정 설명",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#설정-설명",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"packagejson-설정",children:["package.json 설정",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#packagejson-설정",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"package.json"}),"에서 ",(0,r.jsx)(n.code,{children:"name"})," 필드를 통해 서비스 이름을 정의하며, 이 이름은 서비스의 기본 별칭 접두사로 사용됩니다:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",meta:'title="package.json"',children:'{\n    "name": "your-app-name"\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"tsconfigjson-설정",children:["tsconfig.json 설정",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tsconfigjson-설정",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript가 별칭 경로를 올바르게 해석할 수 있도록 ",(0,r.jsx)(n.code,{children:"tsconfig.json"}),"에서 ",(0,r.jsx)(n.code,{children:"paths"})," 매핑을 설정해야 합니다:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",meta:'title="tsconfig.json"',children:'{\n    "compilerOptions": {\n        "paths": {\n            "your-app-name/src/*": [\n                "./src/*"\n            ],\n            "your-app-name/*": [\n                "./*"\n            ]\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"사용-예제",children:["사용 예제",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#사용-예제",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"서비스-내부-모듈-임포트",children:["서비스 내부 모듈 임포트",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#서비스-내부-모듈-임포트",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 별칭을 사용하여 임포트\nimport { MyComponent } from 'your-app-name/src/components';\n\n// 상대 경로를 사용한 동등한 임포트\nimport { MyComponent } from '../components';\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"다른-서비스-모듈-임포트",children:["다른 서비스 모듈 임포트",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#다른-서비스-모듈-임포트",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 다른 서비스의 컴포넌트 임포트\nimport { SharedComponent } from 'other-service/src/components';\n\n// 다른 서비스의 유틸리티 함수 임포트\nimport { utils } from 'other-service/src/utils';\n"})}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"최적의 실천 방법"}),(0,r.jsxs)(n.div,{className:"rspress-directive-content",children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"상대 경로보다 별칭 경로를 우선적으로 사용합니다."}),"\n",(0,r.jsx)(n.li,{children:"별칭 경로의 의미와 일관성을 유지합니다."}),"\n",(0,r.jsx)(n.li,{children:"별칭 경로에서 너무 많은 디렉토리 계층을 사용하지 않습니다."}),"\n"]}),"\n"]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 컴포넌트 임포트\nimport { Button } from 'your-app-name/src/components';\nimport { Layout } from 'your-app-name/src/components/layout';\n\n// 유틸리티 함수 임포트\nimport { formatDate } from 'your-app-name/src/utils';\nimport { request } from 'your-app-name/src/utils/request';\n\n// 타입 정의 임포트\nimport type { UserInfo } from 'your-app-name/src/types';\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"서비스-간-임포트",children:["서비스 간 임포트",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#서비스-간-임포트",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"모듈 링크(Module Link)가 구성된 경우, 동일한 방식으로 다른 서비스의 모듈을 임포트할 수 있습니다:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 원격 서비스의 컴포넌트 임포트\nimport { Header } from 'remote-service/src/components';\n\n// 원격 서비스의 유틸리티 함수 임포트\nimport { logger } from 'remote-service/src/utils';\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"사용자-정의-별칭",children:["사용자 정의 별칭",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#사용자-정의-별칭",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"서드파티 패키지나 특수한 상황을 위해 Gez 설정 파일을 통해 사용자 정의 별칭을 설정할 수 있습니다:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"export default {\n    async devApp(gez) {\n        return import('@gez/rspack').then((m) =>\n            m.createApp(gez, (buildContext) => {\n                buildContext.config.resolve = {\n                    ...buildContext.config.resolve,\n                    alias: {\n                        ...buildContext.config.resolve?.alias,\n                        // Vue에 특정 빌드 버전을 구성\n                        'vue$': 'vue/dist/vue.esm.js',\n                        // 자주 사용하는 디렉토리에 짧은 별칭 구성\n                        '@': './src',\n                        '@components': './src/components'\n                    }\n                }\n            })\n        );\n    }\n} satisfies GezOptions;\n"})}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive warning",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"주의 사항"}),(0,r.jsxs)(n.div,{className:"rspress-directive-content",children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"비즈니스 모듈의 경우, 프로젝트의 일관성을 유지하기 위해 기본 별칭 메커니즘을 항상 사용하는 것이 좋습니다."}),"\n",(0,r.jsx)(n.li,{children:"사용자 정의 별칭은 주로 서드파티 패키지의 특수 요구 사항이나 개발 경험을 최적화하는 데 사용됩니다."}),"\n",(0,r.jsx)(n.li,{children:"사용자 정의 별칭을 과도하게 사용하면 코드의 유지보수성과 빌드 최적화에 영향을 미칠 수 있습니다."}),"\n"]}),"\n"]})]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["ko%2Fguide%2Fessentials%2Falias.md"]={toc:[{text:"기본 별칭 메커니즘",id:"기본-별칭-메커니즘",depth:2},{text:"설정 설명",id:"설정-설명",depth:2},{text:"package.json 설정",id:"packagejson-설정",depth:3},{text:"tsconfig.json 설정",id:"tsconfigjson-설정",depth:3},{text:"사용 예제",id:"사용-예제",depth:2},{text:"서비스 내부 모듈 임포트",id:"서비스-내부-모듈-임포트",depth:3},{text:"다른 서비스 모듈 임포트",id:"다른-서비스-모듈-임포트",depth:3},{text:"서비스 간 임포트",id:"서비스-간-임포트",depth:3},{text:"사용자 정의 별칭",id:"사용자-정의-별칭",depth:3}],title:"경로 별칭",headingTitle:"경로 별칭",frontmatter:{titleSuffix:"Gez 프레임워크 모듈 임포트 경로 매핑 가이드",description:"Gez 프레임워크의 경로 별칭(Path Alias) 메커니즘에 대해 자세히 설명합니다. 이는 임포트 경로 단순화, 깊은 중첩 방지, 타입 안전성, 모듈 해석 최적화 등의 기능을 포함하며, 개발자가 코드 유지보수성을 향상시키는 데 도움을 줍니다.",head:[["meta",{property:"keywords",content:"Gez, 경로 별칭, Path Alias, TypeScript, 모듈 임포트, 경로 매핑, 코드 유지보수성"}]]}}}}]);