"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["6773"],{2873:function(e,n,i){i.r(n),i.d(n,{default:()=>a});var r=i(1549),s=i(6603);function t(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"von-der-komponentenfreigabe-zur-nativen-modularit\\xe4t-der-entwicklungsweg-des-gez-mikrofrontend-frameworks",children:["Von der Komponentenfreigabe zur nativen Modularit\xe4t: Der Entwicklungsweg des Gez-Mikrofrontend-Frameworks",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#von-der-komponentenfreigabe-zur-nativen-modularit\\xe4t-der-entwicklungsweg-des-gez-mikrofrontend-frameworks",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"projektkontext",children:["Projektkontext",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#projektkontext",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"In den letzten Jahren hat die Mikrofrontend-Architektur st\xe4ndig nach dem richtigen Weg gesucht. Doch was wir sahen, waren verschiedene komplexe technische L\xf6sungen, die mit mehreren Schichten von Verpackungen und k\xfcnstlicher Isolation eine ideale Mikrofrontend-Welt simulierten. Diese L\xf6sungen brachten erhebliche Leistungseinbu\xdfen mit sich, machten einfache Entwicklungen komplex und standardisierte Prozesse undurchsichtig."}),"\n",(0,r.jsxs)(n.h3,{id:"grenzen-traditioneller-l\\xf6sungen",children:["Grenzen traditioneller L\xf6sungen",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#grenzen-traditioneller-l\\xf6sungen",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Bei der praktischen Anwendung der Mikrofrontend-Architektur haben wir die zahlreichen Einschr\xe4nkungen traditioneller L\xf6sungen deutlich gesp\xfcrt:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leistungseinbu\xdfen"}),": Laufzeitabh\xe4ngigkeiten, JS-Sandbox-Proxies – jede Operation verbraucht wertvolle Leistung"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fragile Isolation"}),": K\xfcnstlich geschaffene Sandbox-Umgebungen k\xf6nnen niemals die native Isolationsf\xe4higkeit des Browsers erreichen"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Komplexit\xe4t beim Build"}),": Um Abh\xe4ngigkeiten zu handhaben, mussten Build-Tools angepasst werden, was einfache Projekte schwer wartbar machte"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Angepasste Regeln"}),": Spezielle Bereitstellungsstrategien, Laufzeitverarbeitung – jeder Schritt entfernte sich von den Standardprozessen der modernen Entwicklung"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"\xd6kosystembeschr\xe4nkungen"}),": Framework-Kopplung, angepasste APIs – die Technologieauswahl wurde an ein bestimmtes \xd6kosystem gebunden"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Diese Probleme traten besonders deutlich in einem unserer Unternehmensprojekte im Jahr 2019 hervor. Damals wurde ein gro\xdfes Produkt in mehr als zehn unabh\xe4ngige Gesch\xe4ftssubsysteme aufgeteilt, die eine Reihe von Basis- und Gesch\xe4ftskomponenten teilen mussten. Die urspr\xfcnglich verwendete L\xf6sung zur Komponentenfreigabe basierend auf npm-Paketen zeigte in der Praxis ernsthafte Wartungseffizienzprobleme: Wenn eine freigegebene Komponente aktualisiert wurde, mussten alle davon abh\xe4ngigen Subsysteme einen vollst\xe4ndigen Build- und Bereitstellungsprozess durchlaufen."}),"\n",(0,r.jsxs)(n.h2,{id:"technische-entwicklung",children:["Technische Entwicklung",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#technische-entwicklung",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"v10-erkundung-von-remote-komponenten",children:["v1.0: Erkundung von Remote-Komponenten",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v10-erkundung-von-remote-komponenten",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Um die Effizienzprobleme bei der Komponentenfreigabe zu l\xf6sen, f\xfchrte Gez v1.0 einen RemoteView-Komponentenmechanismus basierend auf dem HTTP-Protokoll ein. Diese L\xf6sung erm\xf6glichte die dynamische Anforderung von Code zur Laufzeit und l\xf6ste das Problem zu langer Build-Abh\xe4ngigkeitsketten. Aufgrund des Mangels an standardisierten Laufzeitkommunikationsmechanismen gab es jedoch weiterhin Effizienzengp\xe4sse bei der Zustandssynchronisation und Ereignis\xfcbertragung zwischen den Diensten."}),"\n",(0,r.jsxs)(n.h3,{id:"v20-versuch-mit-module-federation",children:["v2.0: Versuch mit Module Federation",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v20-versuch-mit-module-federation",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["In Version v2.0 haben wir die ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/concepts/module-federation/",target:"_blank",rel:"noopener noreferrer",children:"Module Federation"}),"-Technologie von ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer",children:"Webpack 5.0"})," verwendet. Diese Technologie verbesserte die Zusammenarbeit zwischen den Diensten durch einen einheitlichen Modullademechanismus und Laufzeitcontainer erheblich. In der gro\xdffl\xe4chigen Praxis brachte die geschlossene Implementierung von Module Federation jedoch neue Herausforderungen mit sich: Es war schwierig, eine pr\xe4zise Abh\xe4ngigkeitsversionsverwaltung zu erreichen, insbesondere bei der Vereinheitlichung gemeinsamer Abh\xe4ngigkeiten mehrerer Dienste, was h\xe4ufig zu Versionskonflikten und Laufzeitfehlern f\xfchrte."]}),"\n",(0,r.jsxs)(n.h2,{id:"die-neue-\\xe4ra-von-esm",children:["Die neue \xc4ra von ESM",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#die-neue-\\xe4ra-von-esm",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Bei der Planung von Version v3.0 haben wir die Entwicklungstrends im Frontend-\xd6kosystem genau beobachtet und festgestellt, dass Fortschritte in den nativen Browserf\xe4higkeiten neue M\xf6glichkeiten f\xfcr die Mikrofrontend-Architektur er\xf6ffnen:"}),"\n",(0,r.jsxs)(n.h3,{id:"standardisiertes-modulsystem",children:["Standardisiertes Modulsystem",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#standardisiertes-modulsystem",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Mit der umfassenden Unterst\xfctzung f\xfcr ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer",children:"ES Modules"})," durch die wichtigsten Browser und der Reifung der ",(0,r.jsx)(n.a,{href:"https://github.com/WICG/import-maps",target:"_blank",rel:"noopener noreferrer",children:"Import Maps"}),"-Spezifikation hat die Frontend-Entwicklung ein echtes modulares Zeitalter erreicht. Laut den Statistiken von ",(0,r.jsx)(n.a,{href:"https://caniuse.com/?search=importmap",target:"_blank",rel:"noopener noreferrer",children:"Can I Use"})," liegt die native Unterst\xfctzung f\xfcr ESM in den wichtigsten Browsern (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) bei 93,5 %, was uns folgende Vorteile bietet:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Standardisiertes Abh\xe4ngigkeitsmanagement"}),": Import Maps bieten die F\xe4higkeit, Modulabh\xe4ngigkeiten auf Browserebene aufzul\xf6sen, ohne komplexe Laufzeiteinschleusungen"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimierung der Ressourcenladung"}),": Der native Modulcache-Mechanismus des Browsers verbessert die Ressourcenladeeffizienz erheblich"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Vereinfachung des Build-Prozesses"}),": Der auf ESM basierende Entwicklungsmodus macht die Build-Prozesse f\xfcr Entwicklungs- und Produktionsumgebungen konsistenter"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Gleichzeitig k\xf6nnen wir durch die Unterst\xfctzung des Kompatibilit\xe4tsmodus (Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14) die Browserabdeckung auf 96,81 % erh\xf6hen, was es uns erm\xf6glicht, hohe Leistung beizubehalten, ohne die Unterst\xfctzung f\xfcr \xe4ltere Browser zu opfern."}),"\n",(0,r.jsxs)(n.h3,{id:"durchbr\\xfcche-bei-leistung-und-isolation",children:["Durchbr\xfcche bei Leistung und Isolation",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#durchbr\\xfcche-bei-leistung-und-isolation",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Das native Modulsystem bringt nicht nur Standardisierung, sondern auch eine qualitative Verbesserung von Leistung und Isolation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keine Laufzeitkosten"}),": Keine JavaScript-Sandbox-Proxies und Laufzeiteinschleusungen mehr wie in traditionellen Mikrofrontend-L\xf6sungen"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zuverl\xe4ssige Isolationsmechanismen"}),": Die strikten Modulbereiche von ESM bieten von Natur aus die zuverl\xe4ssigste Isolationsf\xe4higkeit"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pr\xe4zises Abh\xe4ngigkeitsmanagement"}),": Statische Importanalysen machen Abh\xe4ngigkeitsbeziehungen klarer und die Versionskontrolle pr\xe4ziser"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"auswahl-der-build-tools",children:["Auswahl der Build-Tools",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#auswahl-der-build-tools",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Bei der Umsetzung der technischen L\xf6sung war die Auswahl der Build-Tools ein entscheidender Punkt. Nach fast einem Jahr technischer Recherche und Praxis hat sich unsere Wahl wie folgt entwickelt:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Erkundung von Vite"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Vorteile: Auf ESM basierender Entwicklungsserver, bietet ein hervorragendes Entwicklungserlebnis"}),"\n",(0,r.jsx)(n.li,{children:"Herausforderungen: Unterschiede zwischen Entwicklungs- und Produktions-Builds f\xfchrten zu gewissen Unsicherheiten"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.a,{href:"https://www.rspack.dev/",target:"_blank",rel:"noopener noreferrer",children:"Rspack"})," etabliert"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Leistungsvorteile: Hochleistungs-Kompilierung basierend auf ",(0,r.jsx)(n.a,{href:"https://www.rust-lang.org/",target:"_blank",rel:"noopener noreferrer",children:"Rust"}),", verbesserte die Build-Geschwindigkeit erheblich"]}),"\n",(0,r.jsx)(n.li,{children:"\xd6kosystemunterst\xfctzung: Hohe Kompatibilit\xe4t mit dem Webpack-\xd6kosystem, reduzierte Migrationskosten"}),"\n",(0,r.jsx)(n.li,{children:"ESM-Unterst\xfctzung: Durch die Praxis des Rslib-Projekts wurde die Zuverl\xe4ssigkeit bei ESM-Builds best\xe4tigt"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Diese Entscheidung erm\xf6glichte es uns, bei gleichbleibendem Entwicklungserlebnis eine stabilere Produktionsumgebung zu erhalten. Basierend auf der Kombination von ESM und Rspack haben wir schlie\xdflich eine leistungsstarke, wenig invasive Mikrofrontend-L\xf6sung entwickelt."}),"\n",(0,r.jsxs)(n.h2,{id:"zukunftsaussichten",children:["Zukunftsaussichten",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#zukunftsaussichten",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"In den zuk\xfcnftigen Entwicklungspl\xe4nen wird das Gez-Framework sich auf die folgenden drei Richtungen konzentrieren:"}),"\n",(0,r.jsxs)(n.h3,{id:"tiefgehende-optimierung-von-import-maps",children:["Tiefgehende Optimierung von Import Maps",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tiefgehende-optimierung-von-import-maps",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamisches Abh\xe4ngigkeitsmanagement"}),": Implementierung einer intelligenten Laufzeitabh\xe4ngigkeitsversionsverwaltung zur L\xf6sung von Abh\xe4ngigkeitskonflikten zwischen mehreren Anwendungen"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Vorlade-Strategien"}),": Intelligentes Vorladen basierend auf Routing-Analysen zur Verbesserung der Ressourcenladeeffizienz"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Build-Optimierung"}),": Automatische Generierung optimaler Import Maps-Konfigurationen zur Reduzierung der manuellen Konfigurationskosten f\xfcr Entwickler"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"framework-unabh\\xe4ngiges-routing",children:["Framework-unabh\xe4ngiges Routing",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#framework-unabh\\xe4ngiges-routing",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Einheitliche Routing-Abstraktion"}),": Entwurf einer Framework-unabh\xe4ngigen Routing-Schnittstelle zur Unterst\xfctzung von Vue, React und anderen g\xe4ngigen Frameworks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mikroanwendungs-Routing"}),": Implementierung von Routing-Interaktionen zwischen Anwendungen zur Konsistenz von URL und Anwendungszustand"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Routing-Middleware"}),": Bereitstellung eines erweiterbaren Middleware-Mechanismus zur Unterst\xfctzung von Berechtigungskontrolle, Seiten\xfcberg\xe4ngen und anderen Funktionen"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"best-practices-f\\xfcr-framework-\\xfcbergreifende-kommunikation",children:["Best Practices f\xfcr Framework-\xfcbergreifende Kommunikation",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#best-practices-f\\xfcr-framework-\\xfcbergreifende-kommunikation",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Beispielanwendungen"}),": Bereitstellung vollst\xe4ndiger Beispiele f\xfcr Framework-\xfcbergreifende Kommunikation, die Vue, React, Preact und andere g\xe4ngige Frameworks abdecken"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Status-Synchronisation"}),": Leichtgewichtige Statusfreigabel\xf6sung basierend auf ESM"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event-Bus"}),": Standardisierter Ereigniskommunikationsmechanismus zur Unterst\xfctzung entkoppelter Kommunikation zwischen Anwendungen"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Durch diese Optimierungen und Erweiterungen streben wir an, Gez zu einer noch vollst\xe4ndigeren und benutzerfreundlicheren Mikrofrontend-L\xf6sung zu machen, die Entwicklern ein besseres Entwicklungserlebnis und h\xf6here Entwicklungseffizienz bietet."})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["de%2Fblog%2Fbirth-of-gez.md"]={toc:[{text:"Projektkontext",id:"projektkontext",depth:2},{text:"Grenzen traditioneller L\xf6sungen",id:"grenzen-traditioneller-l\xf6sungen",depth:3},{text:"Technische Entwicklung",id:"technische-entwicklung",depth:2},{text:"v1.0: Erkundung von Remote-Komponenten",id:"v10-erkundung-von-remote-komponenten",depth:3},{text:"v2.0: Versuch mit Module Federation",id:"v20-versuch-mit-module-federation",depth:3},{text:"Die neue \xc4ra von ESM",id:"die-neue-\xe4ra-von-esm",depth:2},{text:"Standardisiertes Modulsystem",id:"standardisiertes-modulsystem",depth:3},{text:"Durchbr\xfcche bei Leistung und Isolation",id:"durchbr\xfcche-bei-leistung-und-isolation",depth:3},{text:"Auswahl der Build-Tools",id:"auswahl-der-build-tools",depth:3},{text:"Zukunftsaussichten",id:"zukunftsaussichten",depth:2},{text:"Tiefgehende Optimierung von Import Maps",id:"tiefgehende-optimierung-von-import-maps",depth:3},{text:"Framework-unabh\xe4ngiges Routing",id:"framework-unabh\xe4ngiges-routing",depth:3},{text:"Best Practices f\xfcr Framework-\xfcbergreifende Kommunikation",id:"best-practices-f\xfcr-framework-\xfcbergreifende-kommunikation",depth:3}],title:"Von der Komponentenfreigabe zur nativen Modularit\xe4t: Der Entwicklungsweg des Gez-Mikrofrontend-Frameworks",headingTitle:"Von der Komponentenfreigabe zur nativen Modularit\xe4t: Der Entwicklungsweg des Gez-Mikrofrontend-Frameworks",frontmatter:{titleSuffix:"Vom Mikrofrontend-Dilemma zur ESM-Innovation: Der Entwicklungsweg des Gez-Frameworks",description:"Eine tiefgehende Betrachtung des Gez-Frameworks, von den Herausforderungen traditioneller Mikrofrontend-Architekturen bis hin zu innovativen Durchbr\xfcchen basierend auf ESM. Es werden technische Praxiserfahrungen in den Bereichen Leistungsoptimierung, Abh\xe4ngigkeitsmanagement und Auswahl von Build-Tools geteilt.",head:[["meta",{property:"keywords",content:"Gez, Mikrofrontend-Framework, ESM, Import Maps, Rspack, Module Federation, Abh\xe4ngigkeitsmanagement, Leistungsoptimierung, technische Entwicklung, Server-Side Rendering"}]],sidebar:!1}}}}]);