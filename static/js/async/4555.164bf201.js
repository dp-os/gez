"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["4555"],{1379:function(n,e,r){r.r(e),r.d(e,{default:()=>c});var s=r(1549),i=r(6603);function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",strong:"strong",ul:"ul",h2:"h2",code:"code",pre:"pre",h3:"h3",h4:"h4"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"контекст-рендеринга",children:["Контекст рендеринга",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#контекст-рендеринга",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext — это основной класс в Gez, который отвечает за управление ресурсами и генерацию HTML в процессе серверного рендеринга (SSR). Он обладает следующими ключевыми особенностями:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Система модулей на основе ESM"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Использует современный стандарт ECMAScript Modules"}),"\n",(0,s.jsx)(e.li,{children:"Поддерживает нативный импорт и экспорт модулей"}),"\n",(0,s.jsx)(e.li,{children:"Обеспечивает лучшее разделение кода и загрузку по требованию"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Интеллектуальный сбор зависимостей"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Динамически собирает зависимости на основе фактического пути рендеринга"}),"\n",(0,s.jsx)(e.li,{children:"Избегает загрузки ненужных ресурсов"}),"\n",(0,s.jsx)(e.li,{children:"Поддерживает асинхронные компоненты и динамический импорт"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Точное внедрение ресурсов"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Строго контролирует порядок загрузки ресурсов"}),"\n",(0,s.jsx)(e.li,{children:"Оптимизирует производительность загрузки первой страницы"}),"\n",(0,s.jsx)(e.li,{children:"Обеспечивает надежность гидратации (Hydration) на стороне клиента"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Гибкий механизм конфигурации"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Поддерживает динамическую настройку базового пути"}),"\n",(0,s.jsx)(e.li,{children:"Предоставляет различные режимы отображения импорта"}),"\n",(0,s.jsx)(e.li,{children:"Адаптируется к различным сценариям развертывания"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"использование",children:["Использование",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#использование",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["В Gez разработчикам обычно не нужно создавать экземпляр RenderContext вручную. Вместо этого они могут получить экземпляр через метод ",(0,s.jsx)(e.code,{children:"gez.render()"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"async server(gez) {\n    const server = http.createServer((req, res) => {\n        // Обработка статических файлов\n        gez.middleware(req, res, async () => {\n            // Получение экземпляра RenderContext через gez.render()\n            const rc = await gez.render({\n                params: {\n                    url: req.url\n                }\n            });\n            // Отправка HTML-контента\n            res.end(rc.html);\n        });\n    });\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"основные-функции",children:["Основные функции",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#основные-функции",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"сбор-зависимостей",children:["Сбор зависимостей",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#сбор-зависимостей",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext реализует интеллектуальный механизм сбора зависимостей, который динамически собирает зависимости на основе фактически рендерящихся компонентов, а не просто предварительно загружает все возможные ресурсы:"}),"\n",(0,s.jsxs)(e.h4,{id:"сбор-по-требованию",children:["Сбор по требованию",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#сбор-по-требованию",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Автоматически отслеживает и записывает зависимости модулей в процессе рендеринга компонентов"}),"\n",(0,s.jsx)(e.li,{children:"Собирает только те ресурсы (CSS, JavaScript и т.д.), которые действительно используются на текущей странице"}),"\n",(0,s.jsxs)(e.li,{children:["Использует ",(0,s.jsx)(e.code,{children:"importMetaSet"})," для точной записи зависимостей каждого компонента"]}),"\n",(0,s.jsx)(e.li,{children:"Поддерживает сбор зависимостей для асинхронных компонентов и динамического импорта"}),"\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"автоматическая-обработка",children:["Автоматическая обработка",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#автоматическая-обработка",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Разработчикам не нужно вручную управлять процессом сбора зависимостей"}),"\n",(0,s.jsx)(e.li,{children:"Фреймворк автоматически собирает информацию о зависимостях во время рендеринга компонентов"}),"\n",(0,s.jsxs)(e.li,{children:["Все собранные ресурсы обрабатываются через метод ",(0,s.jsx)(e.code,{children:"commit()"})]}),"\n",(0,s.jsx)(e.li,{children:"Автоматически решает проблемы циклических и повторяющихся зависимостей"}),"\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"оптимизация-производительности",children:["Оптимизация производительности",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#оптимизация-производительности",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Избегает загрузки неиспользуемых модулей, значительно сокращая время загрузки первой страницы"}),"\n",(0,s.jsx)(e.li,{children:"Точный контроль порядка загрузки ресурсов для оптимизации производительности рендеринга"}),"\n",(0,s.jsx)(e.li,{children:"Автоматически генерирует оптимальные карты импорта (Import Map)"}),"\n",(0,s.jsx)(e.li,{children:"Поддерживает стратегии предварительной загрузки и загрузки по требованию"}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"внедрение-ресурсов",children:["Внедрение ресурсов",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#внедрение-ресурсов",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext предоставляет несколько методов для внедрения различных типов ресурсов, каждый из которых разработан для оптимизации производительности загрузки:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"preload()"}),": Предварительная загрузка ресурсов CSS и JS с поддержкой настройки приоритетов"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"css()"}),": Внедрение стилей для первой страницы с поддержкой извлечения критического CSS"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"importmap()"}),": Внедрение карты импорта модулей с поддержкой динамического разрешения путей"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"moduleEntry()"}),": Внедрение клиентского входного модуля с поддержкой конфигурации нескольких входных точек"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"modulePreload()"}),": Предварительная загрузка зависимостей модулей с поддержкой стратегии загрузки по требованию"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"порядок-внедрения-ресурсов",children:["Порядок внедрения ресурсов",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#порядок-внедрения-ресурсов",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext строго контролирует порядок внедрения ресурсов, что основано на принципах работы браузера и оптимизации производительности:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Часть head:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"preload()"}),": Предварительная загрузка ресурсов CSS и JS, чтобы браузер мог начать их загрузку как можно раньше"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"css()"}),": Внедрение стилей для первой страницы, чтобы стили были готовы к моменту рендеринга контента"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Часть body:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"importmap()"}),": Внедрение карты импорта модулей для определения правил разрешения путей ESM-модулей"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"moduleEntry()"}),": Внедрение клиентского входного модуля, который должен выполняться после importmap"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"modulePreload()"}),": Предварительная загрузка зависимостей модулей, которая должна выполняться после importmap"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"полный-процесс-рендеринга",children:["Полный процесс рендеринга",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#полный-процесс-рендеринга",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Типичный процесс использования RenderContext выглядит следующим образом:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.server.ts"',children:"export default async (rc: RenderContext) => {\n    // 1. Рендеринг содержимого страницы и сбор зависимостей\n    const app = createApp();\n    const html = await renderToString(app, {\n       importMetaSet: rc.importMetaSet\n    });\n\n    // 2. Фиксация собранных зависимостей\n    await rc.commit();\n    \n    // 3. Генерация полного HTML\n    rc.html = `\n        <!DOCTYPE html>\n        <html>\n        <head>\n            ${rc.preload()}\n            ${rc.css()}\n        </head>\n        <body>\n            ${html}\n            ${rc.importmap()}\n            ${rc.moduleEntry()}\n            ${rc.modulePreload()}\n        </body>\n        </html>\n    `;\n};\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"расширенные-возможности",children:["Расширенные возможности",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#расширенные-возможности",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"настройка-базового-пути",children:["Настройка базового пути",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#настройка-базового-пути",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext предоставляет гибкий механизм динамической настройки базового пути, который позволяет задавать базовый путь для статических ресурсов во время выполнения:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    base: '/gez',  // Установка базового пути\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"Этот механизм особенно полезен в следующих сценариях:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Развертывание многоязычных сайтов"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"основной-домен.com      → язык по умолчанию\nосновной-домен.com/cn/  → китайская версия\nосновной-домен.com/en/  → английская версия\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Микрофронтенд-приложения"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Поддержка гибкого развертывания подприложений по разным путям"}),"\n",(0,s.jsx)(e.li,{children:"Упрощает интеграцию в различные основные приложения"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"режимы-отображения-импорта",children:["Режимы отображения импорта",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#режимы-отображения-импорта",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext предоставляет два режима отображения импорта (Import Map):"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Inline-режим"})," (по умолчанию)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Встраивает карту импорта непосредственно в HTML"}),"\n",(0,s.jsx)(e.li,{children:"Подходит для небольших приложений, уменьшая количество дополнительных сетевых запросов"}),"\n",(0,s.jsx)(e.li,{children:"Карта импорта доступна сразу при загрузке страницы"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"JS-режим"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Загружает карту импорта через внешний JavaScript-файл"}),"\n",(0,s.jsx)(e.li,{children:"Подходит для крупных приложений, позволяя использовать кэширование браузера"}),"\n",(0,s.jsx)(e.li,{children:"Поддерживает динамическое обновление содержимого карты"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Выбор режима можно настроить следующим образом:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    importmapMode: 'js',  // 'inline' | 'js'\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"настройка-входной-функции",children:["Настройка входной функции",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#настройка-входной-функции",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["RenderContext поддерживает настройку входной функции для серверного рендеринга через параметр ",(0,s.jsx)(e.code,{children:"entryName"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    entryName: 'mobile',  // Указание входной функции для мобильной версии\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"Этот механизм особенно полезен в следующих сценариях:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Рендеринг нескольких шаблонов"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.server.ts"',children:"// Входная функция для мобильной версии\nexport const mobile = async (rc: RenderContext) => {\n    // Логика рендеринга для мобильной версии\n};\n\n// Входная функция для десктопной версии\nexport const desktop = async (rc: RenderContext) => {\n    // Логика рендеринга для десктопной версии\n};\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"A/B-тестирование"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Поддержка использования разных логик рендеринга для одной страницы"}),"\n",(0,s.jsx)(e.li,{children:"Упрощает проведение экспериментов с пользовательским опытом"}),"\n",(0,s.jsx)(e.li,{children:"Гибкое переключение между различными стратегиями рендеринга"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Специальные требования к рендерингу"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Поддержка использования пользовательских процессов рендеринга для определенных страниц"}),"\n",(0,s.jsx)(e.li,{children:"Адаптация к различным сценариям оптимизации производительности"}),"\n",(0,s.jsx)(e.li,{children:"Обеспечивает более точный контроль над процессом рендеринга"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"рекомендации",children:["Рекомендации",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#рекомендации",children:"#"})]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Получение экземпляра RenderContext"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Всегда используйте метод ",(0,s.jsx)(e.code,{children:"gez.render()"})," для получения экземпляра"]}),"\n",(0,s.jsx)(e.li,{children:"Передавайте необходимые параметры в зависимости от требований"}),"\n",(0,s.jsx)(e.li,{children:"Избегайте ручного создания экземпляров"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Сбор зависимостей"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Убедитесь, что все модули правильно вызывают ",(0,s.jsx)(e.code,{children:"importMetaSet.add(import.meta)"})]}),"\n",(0,s.jsxs)(e.li,{children:["Вызывайте метод ",(0,s.jsx)(e.code,{children:"commit()"})," сразу после завершения рендеринга"]}),"\n",(0,s.jsx)(e.li,{children:"Используйте асинхронные компоненты и динамический импорт для оптимизации загрузки первой страницы"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Внедрение ресурсов"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Строго соблюдайте порядок внедрения ресурсов"}),"\n",(0,s.jsx)(e.li,{children:"Не внедряйте CSS в body"}),"\n",(0,s.jsx)(e.li,{children:"Убедитесь, что importmap выполняется перед moduleEntry"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Оптимизация производительности"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Используйте preload для предварительной загрузки ключевых ресурсов"}),"\n",(0,s.jsx)(e.li,{children:"Рационально используйте modulePreload для оптимизации загрузки модулей"}),"\n",(0,s.jsx)(e.li,{children:"Избегайте загрузки ненужных ресурсов"}),"\n",(0,s.jsx)(e.li,{children:"Используйте механизмы кэширования браузера для оптимизации производительности загрузки"}),"\n"]}),"\n"]}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["ru%2Fguide%2Fessentials%2Frender-context.md"]={toc:[{text:"Использование",id:"использование",depth:2},{text:"Основные функции",id:"основные-функции",depth:2},{text:"Сбор зависимостей",id:"сбор-зависимостей",depth:3},{text:"Сбор по требованию",id:"сбор-по-требованию",depth:4},{text:"Автоматическая обработка",id:"автоматическая-обработка",depth:4},{text:"Оптимизация производительности",id:"оптимизация-производительности",depth:4},{text:"Внедрение ресурсов",id:"внедрение-ресурсов",depth:3},{text:"Порядок внедрения ресурсов",id:"порядок-внедрения-ресурсов",depth:3},{text:"Полный процесс рендеринга",id:"полный-процесс-рендеринга",depth:2},{text:"Расширенные возможности",id:"расширенные-возможности",depth:2},{text:"Настройка базового пути",id:"настройка-базового-пути",depth:3},{text:"Режимы отображения импорта",id:"режимы-отображения-импорта",depth:3},{text:"Настройка входной функции",id:"настройка-входной-функции",depth:3},{text:"Рекомендации",id:"рекомендации",depth:2}],title:"Контекст рендеринга",headingTitle:"Контекст рендеринга",frontmatter:{titleSuffix:"Основные механизмы серверного рендеринга в Gez",description:"Подробное описание механизма контекста рендеринга (RenderContext) в Gez, включая управление ресурсами, генерацию HTML и систему модулей ESM, чтобы помочь разработчикам понять и использовать функции серверного рендеринга.",head:[["meta",{property:"keywords",content:"Gez, контекст рендеринга, RenderContext, SSR, серверный рендеринг, ESM, управление ресурсами"}]]}}}}]);