"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["3762"],{8900:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var t=r(1549),s=r(6603);function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ul:"ul",li:"li",strong:"strong",h3:"h3",pre:"pre"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"클라이언트-사이드-렌더링",children:["클라이언트 사이드 렌더링",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#클라이언트-사이드-렌더링",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["클라이언트 사이드 렌더링(Client-Side Rendering, CSR)은 브라우저에서 페이지 렌더링을 수행하는 기술입니다. Gez에서 Node.js 서버 인스턴스를 배포할 수 없는 경우, 빌드 단계에서 정적 ",(0,t.jsx)(n.code,{children:"index.html"})," 파일을 생성하여 순수 클라이언트 사이드 렌더링을 구현할 수 있습니다."]}),"\n",(0,t.jsxs)(n.h2,{id:"사용-시나리오",children:["사용 시나리오",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#사용-시나리오",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"다음과 같은 시나리오에서 클라이언트 사이드 렌더링을 사용하는 것이 권장됩니다:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"정적 호스팅 환경"}),": GitHub Pages, CDN 등 서버 사이드 렌더링을 지원하지 않는 호스팅 서비스"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"단순 애플리케이션"}),": 초기 로딩 속도와 SEO 요구사항이 높지 않은 소규모 애플리케이션"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"개발 환경"}),": 개발 단계에서 애플리케이션을 빠르게 미리보기 및 디버깅"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"설정-설명",children:["설정 설명",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#설정-설명",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"html-템플릿-설정",children:["HTML 템플릿 설정",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#html-템플릿-설정",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"클라이언트 사이드 렌더링 모드에서는 범용 HTML 템플릿을 설정해야 합니다. 이 템플릿은 애플리케이션의 컨테이너 역할을 하며, 필요한 리소스 참조와 마운트 포인트를 포함합니다."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",meta:'title="src/entry.server.ts"',children:"import type { RenderContext } from '@gez/core';\n\nexport default async (rc: RenderContext) => {\n    // 의존성 수집 제출\n    await rc.commit();\n    \n    // HTML 템플릿 설정\n    rc.html = `\n<!DOCTYPE html>\n<html>\n<head>\n    ${rc.preload()}           // 리소스 프리로드\n    <title>Gez</title>\n    ${rc.css()}               // 스타일 주입\n</head>\n<body>\n    <div id=\"app\"></div>\n    ${rc.importmap()}         // 임포트 맵\n    ${rc.moduleEntry()}       // 엔트리 모듈\n    ${rc.modulePreload()}     // 모듈 프리로드\n</body>\n</html>\n`;\n};\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"정적-html-생성",children:["정적 HTML 생성",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#정적-html-생성",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["프로덕션 환경에서 클라이언트 사이드 렌더링을 사용하려면 빌드 단계에서 정적 HTML 파일을 생성해야 합니다. Gez는 ",(0,t.jsx)(n.code,{children:"postBuild"})," 훅 함수를 제공하여 이 기능을 구현합니다:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"import type { GezOptions } from '@gez/core';\n\nexport default {\n    async postBuild(gez) {\n        // 정적 HTML 파일 생성\n        const rc = await gez.render();\n        // HTML 파일 작성\n        gez.writeSync(\n            gez.resolvePath('dist/client', 'index.html'),\n            rc.html\n        );\n    }\n} satisfies GezOptions;\n"})})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["ko%2Fguide%2Fessentials%2Fcsr.md"]={toc:[{text:"사용 시나리오",id:"사용-시나리오",depth:2},{text:"설정 설명",id:"설정-설명",depth:2},{text:"HTML 템플릿 설정",id:"html-템플릿-설정",depth:3},{text:"정적 HTML 생성",id:"정적-html-생성",depth:3}],title:"클라이언트 사이드 렌더링",headingTitle:"클라이언트 사이드 렌더링",frontmatter:{titleSuffix:"Gez 프레임워크 클라이언트 사이드 렌더링 구현 가이드",description:"Gez 프레임워크의 클라이언트 사이드 렌더링 메커니즘을 상세히 설명하며, 정적 빌드, 배포 전략 및 모범 사례를 포함하여 서버리스 환경에서 효율적인 프론트엔드 렌더링을 구현하는 방법을 안내합니다.",head:[["meta",{property:"keywords",content:"Gez, 클라이언트 사이드 렌더링, CSR, 정적 빌드, 프론트엔드 렌더링, 서버리스 배포, 성능 최적화"}]]}}}}]);