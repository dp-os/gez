"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["4439"],{3738:function(e,n,s){s.r(n),s.d(n,{default:()=>a});var r=s(1549),i=s(6603);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",strong:"strong",code:"code",h2:"h2",h3:"h3",pre:"pre",div:"div",ol:"ol"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"псевдонимы-путей",children:["Псевдонимы путей",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#псевдонимы-путей",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Псевдонимы путей (Path Alias) — это механизм сопоставления путей импорта модулей, который позволяет разработчикам использовать короткие, семантически значимые идентификаторы вместо полных путей модулей. В Gez механизм псевдонимов путей имеет следующие преимущества:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Упрощение путей импорта"}),": Использование семантически значимых псевдонимов вместо длинных относительных путей, что повышает читаемость кода."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Избегание глубокой вложенности"}),": Устранение сложностей, связанных с многоуровневыми ссылками на каталоги (например, ",(0,r.jsx)(n.code,{children:"../../../../"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Безопасность типов"}),": Полная интеграция с системой типов TypeScript, обеспечивающая автодополнение и проверку типов."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Оптимизация разрешения модулей"}),": Ускорение разрешения модулей за счет предопределенного сопоставления путей."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"механизм-псевдонимов-по-умолчанию",children:["Механизм псевдонимов по умолчанию",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#механизм-псевдонимов-по-умолчанию",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Gez использует автоматический механизм псевдонимов на основе имени сервиса (Service Name). Этот подход, основанный на соглашениях, имеет следующие особенности:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Автоматическая настройка"}),": Псевдонимы автоматически генерируются на основе поля ",(0,r.jsx)(n.code,{children:"name"})," в ",(0,r.jsx)(n.code,{children:"package.json"}),", без необходимости ручной настройки."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Единый стандарт"}),": Обеспечивает единообразие в именовании и ссылках на модули всех сервисов."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Поддержка типов"}),": В сочетании с командой ",(0,r.jsx)(n.code,{children:"npm run build:dts"})," автоматически генерируются файлы объявлений типов, что позволяет осуществлять вывод типов между сервисами."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Предсказуемость"}),": Путь модуля можно определить по имени сервиса, что снижает затраты на поддержку."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"настройка",children:["Настройка",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#настройка",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"настройка-в-packagejson",children:["Настройка в package.json",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#настройка-в-packagejson",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["В ",(0,r.jsx)(n.code,{children:"package.json"})," имя сервиса определяется через поле ",(0,r.jsx)(n.code,{children:"name"}),", которое будет использоваться как префикс псевдонима по умолчанию:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",meta:'title="package.json"',children:'{\n    "name": "your-app-name"\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"настройка-в-tsconfigjson",children:["Настройка в tsconfig.json",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#настройка-в-tsconfigjson",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Чтобы TypeScript мог правильно разрешать пути с псевдонимами, необходимо настроить сопоставление ",(0,r.jsx)(n.code,{children:"paths"})," в ",(0,r.jsx)(n.code,{children:"tsconfig.json"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",meta:'title="tsconfig.json"',children:'{\n    "compilerOptions": {\n        "paths": {\n            "your-app-name/src/*": [\n                "./src/*"\n            ],\n            "your-app-name/*": [\n                "./*"\n            ]\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"примеры-использования",children:["Примеры использования",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#примеры-использования",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"импорт-внутренних-модулей-сервиса",children:["Импорт внутренних модулей сервиса",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#импорт-внутренних-модулей-сервиса",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Использование псевдонима\nimport { MyComponent } from 'your-app-name/src/components';\n\n// Эквивалентный импорт с относительным путем\nimport { MyComponent } from '../components';\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"импорт-модулей-других-сервисов",children:["Импорт модулей других сервисов",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#импорт-модулей-других-сервисов",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Импорт компонентов другого сервиса\nimport { SharedComponent } from 'other-service/src/components';\n\n// Импорт утилит другого сервиса\nimport { utils } from 'other-service/src/utils';\n"})}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive tip",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"Лучшие практики"}),(0,r.jsxs)(n.div,{className:"rspress-directive-content",children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Предпочитайте использование псевдонимов путей вместо относительных путей."}),"\n",(0,r.jsx)(n.li,{children:"Поддерживайте семантическую значимость и единообразие псевдонимов путей."}),"\n",(0,r.jsx)(n.li,{children:"Избегайте использования слишком большого количества уровней вложенности в псевдонимах путей."}),"\n"]}),"\n"]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Импорт компонентов\nimport { Button } from 'your-app-name/src/components';\nimport { Layout } from 'your-app-name/src/components/layout';\n\n// Импорт утилит\nimport { formatDate } from 'your-app-name/src/utils';\nimport { request } from 'your-app-name/src/utils/request';\n\n// Импорт определений типов\nimport type { UserInfo } from 'your-app-name/src/types';\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"импорт-между-сервисами",children:["Импорт между сервисами",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#импорт-между-сервисами",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"После настройки связей модулей (Module Link) можно использовать аналогичный способ для импорта модулей других сервисов:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Импорт компонентов удаленного сервиса\nimport { Header } from 'remote-service/src/components';\n\n// Импорт утилит удаленного сервиса\nimport { logger } from 'remote-service/src/utils';\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"пользовательские-псевдонимы",children:["Пользовательские псевдонимы",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#пользовательские-псевдонимы",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Для сторонних пакетов или особых случаев можно настроить пользовательские псевдонимы через конфигурационный файл Gez:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"export default {\n    async devApp(gez) {\n        return import('@gez/rspack').then((m) =>\n            m.createApp(gez, (buildContext) => {\n                buildContext.config.resolve = {\n                    ...buildContext.config.resolve,\n                    alias: {\n                        ...buildContext.config.resolve?.alias,\n                        // Настройка специфической версии сборки для Vue\n                        'vue$': 'vue/dist/vue.esm.js',\n                        // Настройка коротких псевдонимов для часто используемых каталогов\n                        '@': './src',\n                        '@components': './src/components'\n                    }\n                }\n            })\n        );\n    }\n} satisfies GezOptions;\n"})}),"\n",(0,r.jsxs)(n.div,{className:"rspress-directive warning",children:[(0,r.jsx)(n.div,{className:"rspress-directive-title",children:"Важные замечания"}),(0,r.jsxs)(n.div,{className:"rspress-directive-content",children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Для бизнес-модулей рекомендуется всегда использовать механизм псевдонимов по умолчанию, чтобы поддерживать единообразие проекта."}),"\n",(0,r.jsx)(n.li,{children:"Пользовательские псевдонимы в основном используются для обработки особых требований сторонних пакетов или оптимизации процесса разработки."}),"\n",(0,r.jsx)(n.li,{children:"Чрезмерное использование пользовательских псевдонимов может негативно сказаться на поддерживаемости кода и оптимизации сборки."}),"\n"]}),"\n"]})]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["ru%2Fguide%2Fessentials%2Falias.md"]={toc:[{text:"Механизм псевдонимов по умолчанию",id:"механизм-псевдонимов-по-умолчанию",depth:2},{text:"Настройка",id:"настройка",depth:2},{text:"Настройка в package.json",id:"настройка-в-packagejson",depth:3},{text:"Настройка в tsconfig.json",id:"настройка-в-tsconfigjson",depth:3},{text:"Примеры использования",id:"примеры-использования",depth:2},{text:"Импорт внутренних модулей сервиса",id:"импорт-внутренних-модулей-сервиса",depth:3},{text:"Импорт модулей других сервисов",id:"импорт-модулей-других-сервисов",depth:3},{text:"Импорт между сервисами",id:"импорт-между-сервисами",depth:3},{text:"Пользовательские псевдонимы",id:"пользовательские-псевдонимы",depth:3}],title:"Псевдонимы путей",headingTitle:"Псевдонимы путей",frontmatter:{titleSuffix:"Руководство по сопоставлению путей импорта модулей в Gez",description:"Подробное описание механизма псевдонимов путей в Gez, включая упрощение путей импорта, избегание глубокой вложенности, безопасность типов и оптимизацию разрешения модулей, чтобы помочь разработчикам повысить поддерживаемость кода.",head:[["meta",{property:"keywords",content:"Gez, псевдонимы путей, Path Alias, TypeScript, импорт модулей, сопоставление путей, поддерживаемость кода"}]]}}}}]);