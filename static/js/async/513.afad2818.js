"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["513"],{8648:function(e,r,n){n.r(r),n.d(r,{default:()=>l});var s=n(1549),i=n(6603);function d(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"от-совместного-использования-компонентов-к-нативной-модульности-путь-эволюции-микрофронтенд-фреймворка-gez",children:["От совместного использования компонентов к нативной модульности: путь эволюции микрофронтенд фреймворка Gez",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#от-совместного-использования-компонентов-к-нативной-модульности-путь-эволюции-микрофронтенд-фреймворка-gez",children:"#"})]}),"\n",(0,s.jsxs)(r.h2,{id:"контекст-проекта",children:["Контекст проекта",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#контекст-проекта",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"В последние годы архитектура микрофронтенда искала правильный путь. Однако мы наблюдали множество сложных технических решений, которые с помощью множества слоев и искусственной изоляции пытались имитировать идеальный мир микрофронтенда. Эти решения приносили значительные потери производительности, усложняли разработку и делали стандартные процессы запутанными."}),"\n",(0,s.jsxs)(r.h3,{id:"ограничения-традиционных-решений",children:["Ограничения традиционных решений",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#ограничения-традиционных-решений",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"В процессе практики микрофронтенд архитектуры мы глубоко осознали множество ограничений традиционных решений:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Потери производительности"}),": инъекция зависимостей в runtime, проксирование JS-песочницы — каждая операция потребляет драгоценную производительность."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Хрупкая изоляция"}),": искусственно созданная среда песочницы никогда не сможет достичь нативной изоляции браузера."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Сложность сборки"}),": для обработки зависимостей приходится модифицировать инструменты сборки, что делает простые проекты сложными в поддержке."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Пользовательские правила"}),": специальные стратегии развертывания, обработка в runtime — каждый шаг отклоняется от стандартных процессов современной разработки."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Ограничения экосистемы"}),": привязка к фреймворкам, пользовательские API — выбор технологий вынужденно ограничивается конкретной экосистемой."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Эти проблемы особенно ярко проявились в нашем корпоративном проекте 2019 года. Тогда крупный продукт был разделен на более чем десять независимых бизнес-подсистем, которые должны были использовать общий набор базовых и бизнес-компонентов. Изначально использованное решение на основе npm-пакетов для совместного использования компонентов выявило серьезные проблемы с эффективностью поддержки: при обновлении общих компонентов все подсистемы, зависящие от них, должны были проходить полный процесс сборки и развертывания."}),"\n",(0,s.jsxs)(r.h2,{id:"техническая-эволюция",children:["Техническая эволюция",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#техническая-эволюция",children:"#"})]}),"\n",(0,s.jsxs)(r.h3,{id:"v10-исследование-удаленных-компонентов",children:["v1.0: Исследование удаленных компонентов",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#v10-исследование-удаленных-компонентов",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"Для решения проблемы эффективности совместного использования компонентов Gez v1.0 представил механизм RemoteView на основе HTTP-протокола. Это решение реализовало динамическую сборку кода между сервисами по запросу в runtime, успешно решив проблему длинных цепочек зависимостей при сборке. Однако из-за отсутствия стандартизированного механизма коммуникации в runtime, синхронизация состояния и передача событий между сервисами все еще оставались неэффективными."}),"\n",(0,s.jsxs)(r.h3,{id:"v20-попытка-с-module-federation",children:["v2.0: Попытка с Module Federation",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#v20-попытка-с-module-federation",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["В версии v2.0 мы использовали технологию ",(0,s.jsx)(r.a,{href:"https://webpack.js.org/concepts/module-federation/",target:"_blank",rel:"noopener noreferrer",children:"Module Federation"})," из ",(0,s.jsx)(r.a,{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer",children:"Webpack 5.0"}),". Эта технология значительно повысила эффективность взаимодействия между сервисами благодаря унифицированному механизму загрузки модулей и контейнеру в runtime. Однако в крупномасштабной практике закрытая реализация Module Federation принесла новые вызовы: стало сложно управлять точными версиями зависимостей, особенно при унификации общих зависимостей между несколькими сервисами, часто возникали конфликты версий и ошибки в runtime."]}),"\n",(0,s.jsxs)(r.h2,{id:"вступление-в-новую-эру-esm",children:["Вступление в новую эру ESM",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#вступление-в-новую-эру-esm",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"При планировании версии v3.0 мы глубоко изучили тенденции развития фронтенд экосистемы и обнаружили, что прогресс нативных возможностей браузера открывает новые возможности для архитектуры микрофронтенда:"}),"\n",(0,s.jsxs)(r.h3,{id:"стандартизированная-модульная-система",children:["Стандартизированная модульная система",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#стандартизированная-модульная-система",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["С полной поддержкой ",(0,s.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer",children:"ES Modules"})," в основных браузерах и зрелостью спецификации ",(0,s.jsx)(r.a,{href:"https://github.com/WICG/import-maps",target:"_blank",rel:"noopener noreferrer",children:"Import Maps"}),", фронтенд разработка вступила в настоящую эру модульности. Согласно данным ",(0,s.jsx)(r.a,{href:"https://caniuse.com/?search=importmap",target:"_blank",rel:"noopener noreferrer",children:"Can I Use"}),", поддержка ESM в основных браузерах (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) достигла 93.5%, что предоставило нам следующие преимущества:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Стандартизация управления зависимостями"}),": Import Maps предоставляет возможность разрешения зависимостей модулей на уровне браузера, без сложной инъекции в runtime."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Оптимизация загрузки ресурсов"}),": Нативный механизм кэширования модулей в браузере значительно повышает эффективность загрузки ресурсов."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Упрощение процесса сборки"}),": Разработка на основе ESM делает процессы сборки в разработке и производстве более согласованными."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Кроме того, благодаря поддержке режима совместимости (Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14), мы можем увеличить покрытие браузеров до 96.81%, что позволяет нам сохранять высокую производительность, не жертвуя поддержкой старых браузеров."}),"\n",(0,s.jsxs)(r.h3,{id:"прорыв-в-производительности-и-изоляции",children:["Прорыв в производительности и изоляции",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#прорыв-в-производительности-и-изоляции",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"Нативная модульная система приносит не только стандартизацию, но и значительное улучшение производительности и изоляции:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Нулевые накладные расходы в runtime"}),": Прощание с проксированием JS-песочницы и инъекцией в runtime в традиционных решениях микрофронтенда."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Надежная изоляция"}),": Строгая область видимости модулей ESM естественным образом обеспечивает наиболее надежную изоляцию."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Точное управление зависимостями"}),": Статический анализ импорта делает зависимости более прозрачными, а управление версиями — более точным."]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"выбор-инструментов-сборки",children:["Выбор инструментов сборки",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#выбор-инструментов-сборки",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"В процессе реализации технических решений выбор инструментов сборки был ключевым решением. После почти года исследований и практики наш выбор прошел следующие этапы:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Исследование Vite"})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Преимущества: Сервер разработки на основе ESM, обеспечивающий превосходный опыт разработки."}),"\n",(0,s.jsx)(r.li,{children:"Проблемы: Различия в сборке между средой разработки и производственной средой создавали некоторую неопределенность."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.strong,{children:["Утверждение ",(0,s.jsx)(r.a,{href:"https://www.rspack.dev/",target:"_blank",rel:"noopener noreferrer",children:"Rspack"})]})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Преимущества производительности: Высокая скорость компиляции благодаря ",(0,s.jsx)(r.a,{href:"https://www.rust-lang.org/",target:"_blank",rel:"noopener noreferrer",children:"Rust"}),"."]}),"\n",(0,s.jsx)(r.li,{children:"Поддержка экосистемы: Высокая совместимость с экосистемой Webpack, что снижает затраты на миграцию."}),"\n",(0,s.jsx)(r.li,{children:"Поддержка ESM: Практика проекта Rslib подтвердила надежность Rspack в сборке ESM."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Это решение позволило нам сохранить опыт разработки, одновременно получив более стабильную поддержку производственной среды. На основе комбинации ESM и Rspack мы в итоге создали высокопроизводительное и малоинвазивное решение для микрофронтенда."}),"\n",(0,s.jsxs)(r.h2,{id:"перспективы-на-будущее",children:["Перспективы на будущее",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#перспективы-на-будущее",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"В планах развития фреймворка Gez основное внимание будет уделено следующим трем направлениям:"}),"\n",(0,s.jsxs)(r.h3,{id:"глубокая-оптимизация-import-maps",children:["Глубокая оптимизация Import Maps",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#глубокая-оптимизация-import-maps",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Динамическое управление зависимостями"}),": Реализация интеллектуального планирования версий зависимостей в runtime для решения конфликтов между несколькими приложениями."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Стратегия предзагрузки"}),": Интеллектуальная предзагрузка на основе анализа маршрутов для повышения эффективности загрузки ресурсов."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Оптимизация сборки"}),": Автоматическая генерация оптимальной конфигурации Import Maps для снижения затрат на ручную настройку разработчиками."]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"независимая-от-фреймворка-маршрутизация",children:["Независимая от фреймворка маршрутизация",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#независимая-от-фреймворка-маршрутизация",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Унифицированная абстракция маршрутизации"}),": Разработка независимого от фреймворка интерфейса маршрутизации, поддерживающего Vue, React и другие популярные фреймворки."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Маршрутизация микро-приложений"}),": Реализация взаимодействия маршрутов между приложениями для поддержания согласованности URL и состояния приложения."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Промежуточное ПО маршрутизации"}),": Предоставление расширяемого механизма промежуточного ПО для поддержки контроля доступа, переходов между страницами и других функций."]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"лучшие-практики-межфреймворковой-коммуникации",children:["Лучшие практики межфреймворковой коммуникации",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#лучшие-практики-межфреймворковой-коммуникации",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Примеры приложений"}),": Предоставление полных примеров межфреймворковой коммуникации, охватывающих Vue, React, Preact и другие популярные фреймворки."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Синхронизация состояния"}),": Легковесное решение для совместного использования состояния на основе ESM."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Шина событий"}),": Стандартизированный механизм коммуникации событий для поддержки развязанной коммуникации между приложениями."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"С помощью этих оптимизаций и расширений мы надеемся сделать Gez более совершенным и удобным решением для микрофронтенда, предоставляя разработчикам лучший опыт разработки и более высокую эффективность."})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let l=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["ru%2Fblog%2Fbirth-of-gez.md"]={toc:[{text:"Контекст проекта",id:"контекст-проекта",depth:2},{text:"Ограничения традиционных решений",id:"ограничения-традиционных-решений",depth:3},{text:"Техническая эволюция",id:"техническая-эволюция",depth:2},{text:"v1.0: Исследование удаленных компонентов",id:"v10-исследование-удаленных-компонентов",depth:3},{text:"v2.0: Попытка с Module Federation",id:"v20-попытка-с-module-federation",depth:3},{text:"Вступление в новую эру ESM",id:"вступление-в-новую-эру-esm",depth:2},{text:"Стандартизированная модульная система",id:"стандартизированная-модульная-система",depth:3},{text:"Прорыв в производительности и изоляции",id:"прорыв-в-производительности-и-изоляции",depth:3},{text:"Выбор инструментов сборки",id:"выбор-инструментов-сборки",depth:3},{text:"Перспективы на будущее",id:"перспективы-на-будущее",depth:2},{text:"Глубокая оптимизация Import Maps",id:"глубокая-оптимизация-import-maps",depth:3},{text:"Независимая от фреймворка маршрутизация",id:"независимая-от-фреймворка-маршрутизация",depth:3},{text:"Лучшие практики межфреймворковой коммуникации",id:"лучшие-практики-межфреймворковой-коммуникации",depth:3}],title:"От совместного использования компонентов к нативной модульности: путь эволюции микрофронтенд фреймворка Gez",headingTitle:"От совместного использования компонентов к нативной модульности: путь эволюции микрофронтенд фреймворка Gez",frontmatter:{titleSuffix:"От проблем микрофронтенда к инновациям ESM: путь эволюции фреймворка Gez",description:"Глубокое погружение в эволюцию фреймворка Gez от традиционных проблем микрофронтенда к инновационным решениям на основе ESM, с опытом в оптимизации производительности, управлении зависимостями и выборе инструментов сборки.",head:[["meta",{property:"keywords",content:"Gez, микрофронтенд, ESM, Import Maps, Rspack, Module Federation, управление зависимостями, оптимизация производительности, техническая эволюция, серверный рендеринг"}]],sidebar:!1}}}}]);