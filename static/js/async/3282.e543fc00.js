"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["3282"],{8990:function(e,n,i){i.r(n),i.d(n,{default:()=>a});var o=i(1549),r=i(6603);function t(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,r.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.h1,{id:"from-component-sharing-to-native-modularity-the-evolution-of-the-gez-micro-frontend-framework",children:["From Component Sharing to Native Modularity: The Evolution of the Gez Micro-Frontend Framework",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#from-component-sharing-to-native-modularity-the-evolution-of-the-gez-micro-frontend-framework",children:"#"})]}),"\n",(0,o.jsxs)(n.h2,{id:"project-background",children:["Project Background",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#project-background",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"Over the past few years, micro-frontend architecture has been searching for the right path. However, what we have seen are various complex technical solutions that simulate an ideal micro-frontend world with layers of packaging and artificial isolation. These solutions bring heavy performance burdens, complicate simple development, and obscure standard processes."}),"\n",(0,o.jsxs)(n.h3,{id:"limitations-of-traditional-solutions",children:["Limitations of Traditional Solutions",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#limitations-of-traditional-solutions",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"In practicing micro-frontend architecture, we have deeply experienced the many limitations of traditional solutions:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Performance Overhead"}),": Runtime dependency injection, JS sandbox proxiesâ€”every operation consumes valuable performance."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Fragile Isolation"}),": Artificially created sandbox environments can never match the native isolation capabilities of browsers."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Build Complexity"}),": To handle dependency relationships, build tools must be heavily modified, making simple projects difficult to maintain."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Custom Rules"}),": Special deployment strategies and runtime processing deviate from standard modern development processes."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ecosystem Constraints"}),": Framework coupling and custom APIs force technology choices to be tied to specific ecosystems."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"These issues were particularly evident in a large enterprise project we worked on in 2019. At that time, a large product was divided into more than ten independent business subsystems, which needed to share a set of basic and business components. The initial npm-based component sharing solution exposed serious maintenance efficiency problems: when shared components were updated, all subsystems dependent on those components had to go through a complete build and deployment process."}),"\n",(0,o.jsxs)(n.h2,{id:"technical-evolution",children:["Technical Evolution",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#technical-evolution",children:"#"})]}),"\n",(0,o.jsxs)(n.h3,{id:"v10-exploring-remote-components",children:["v1.0: Exploring Remote Components",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v10-exploring-remote-components",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"To address the efficiency issues of component sharing, Gez v1.0 introduced the RemoteView component mechanism based on the HTTP protocol. This solution achieved on-demand code assembly between services through runtime dynamic requests, successfully solving the problem of long build dependency chains. However, due to the lack of a standardized runtime communication mechanism, state synchronization and event passing between services still had efficiency bottlenecks."}),"\n",(0,o.jsxs)(n.h3,{id:"v20-module-federation-experiment",children:["v2.0: Module Federation Experiment",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v20-module-federation-experiment",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["In version v2.0, we adopted ",(0,o.jsx)(n.a,{href:"https://webpack.js.org/",target:"_blank",rel:"noopener noreferrer",children:"Webpack 5.0"}),"'s ",(0,o.jsx)(n.a,{href:"https://webpack.js.org/concepts/module-federation/",target:"_blank",rel:"noopener noreferrer",children:"Module Federation"})," technology. This technology significantly improved the collaboration efficiency between services through a unified module loading mechanism and runtime containers. However, in large-scale practice, the closed implementation mechanism of Module Federation brought new challenges: it was difficult to achieve precise dependency version management, especially when unifying shared dependencies across multiple services, often leading to version conflicts and runtime exceptions."]}),"\n",(0,o.jsxs)(n.h2,{id:"embracing-the-esm-era",children:["Embracing the ESM Era",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#embracing-the-esm-era",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"When planning version v3.0, we closely observed the development trends of the front-end ecosystem and found that advancements in native browser capabilities brought new possibilities for micro-frontend architecture:"}),"\n",(0,o.jsxs)(n.h3,{id:"standardized-module-system",children:["Standardized Module System",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#standardized-module-system",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["With mainstream browsers fully supporting ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer",children:"ES Modules"})," and the maturity of the ",(0,o.jsx)(n.a,{href:"https://github.com/WICG/import-maps",target:"_blank",rel:"noopener noreferrer",children:"Import Maps"})," specification, front-end development has entered a true modular era. According to ",(0,o.jsx)(n.a,{href:"https://caniuse.com/?search=importmap",target:"_blank",rel:"noopener noreferrer",children:"Can I Use"})," statistics, the native support rate for ESM in mainstream browsers (Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4) has reached 93.5%, providing us with the following advantages:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Standardized Dependency Management"}),": Import Maps provide the ability to resolve module dependencies at the browser level, eliminating the need for complex runtime injection."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Resource Loading Optimization"}),": The browser's native module caching mechanism significantly improves resource loading efficiency."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Simplified Build Process"}),": The ESM-based development model makes the build process more consistent between development and production environments."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"At the same time, with compatibility mode support (Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14), we can further increase browser coverage to 96.81%, allowing us to maintain high performance without sacrificing support for older browsers."}),"\n",(0,o.jsxs)(n.h3,{id:"breakthroughs-in-performance-and-isolation",children:["Breakthroughs in Performance and Isolation",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#breakthroughs-in-performance-and-isolation",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"The native module system brings not only standardization but also qualitative improvements in performance and isolation:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Zero Runtime Overhead"}),": Eliminates the need for JavaScript sandbox proxies and runtime injection in traditional micro-frontend solutions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reliable Isolation Mechanism"}),": The strict module scope of ESM naturally provides the most reliable isolation capabilities."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Precise Dependency Management"}),": Static import analysis makes dependency relationships clearer and version control more precise."]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"build-tool-selection",children:["Build Tool Selection",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#build-tool-selection",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"In the implementation of the technical solution, the choice of build tools was a critical decision point. After nearly a year of technical research and practice, our selection evolved as follows:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Vite Exploration"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Advantages"}),": ESM-based development server, providing an excellent development experience."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Challenges"}),": Differences between development and production builds introduced some uncertainty."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.a,{href:"https://www.rspack.dev/",target:"_blank",rel:"noopener noreferrer",children:"Rspack"})," Adoption"]})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Performance Advantage"}),": High-performance compilation based on ",(0,o.jsx)(n.a,{href:"https://www.rust-lang.org/",target:"_blank",rel:"noopener noreferrer",children:"Rust"}),", significantly improving build speed."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Ecosystem Support"}),": High compatibility with the Webpack ecosystem, reducing migration costs."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ESM Support"}),": Verified reliability in ESM builds through the Rslib project."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This decision allowed us to maintain a good development experience while gaining more stable production environment support. Based on the combination of ESM and Rspack, we ultimately built a high-performance, low-intrusive micro-frontend solution."}),"\n",(0,o.jsxs)(n.h2,{id:"future-outlook",children:["Future Outlook",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#future-outlook",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"In future development plans, the Gez framework will focus on the following three directions:"}),"\n",(0,o.jsxs)(n.h3,{id:"deep-optimization-of-import-maps",children:["Deep Optimization of Import Maps",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#deep-optimization-of-import-maps",children:"#"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dynamic Dependency Management"}),": Implement intelligent runtime dependency version scheduling to resolve dependency conflicts between multiple applications."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Preloading Strategy"}),": Intelligent preloading based on route analysis to improve resource loading efficiency."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Build Optimization"}),": Automatically generate optimal Import Maps configurations, reducing manual configuration costs for developers."]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"framework-agnostic-routing-solution",children:["Framework-Agnostic Routing Solution",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#framework-agnostic-routing-solution",children:"#"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Unified Routing Abstraction"}),": Design a framework-agnostic routing interface to support mainstream frameworks like Vue and React."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Micro-Application Routing"}),": Implement routing linkage between applications to maintain URL and application state consistency."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Routing Middleware"}),": Provide an extensible middleware mechanism to support features like permission control and page transitions."]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"best-practices-for-cross-framework-communication",children:["Best Practices for Cross-Framework Communication",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#best-practices-for-cross-framework-communication",children:"#"})]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Example Applications"}),": Provide complete cross-framework communication examples, covering mainstream frameworks like Vue, React, and Preact."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"State Synchronization"}),": Lightweight state sharing solution based on ESM."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Event Bus"}),": Standardized event communication mechanism to support decoupled communication between applications."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Through these optimizations and expansions, we aim to make Gez a more comprehensive and user-friendly micro-frontend solution, providing developers with a better development experience and higher efficiency."})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}let a=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["en%2Fblog%2Fbirth-of-gez.md"]={toc:[{text:"Project Background",id:"project-background",depth:2},{text:"Limitations of Traditional Solutions",id:"limitations-of-traditional-solutions",depth:3},{text:"Technical Evolution",id:"technical-evolution",depth:2},{text:"v1.0: Exploring Remote Components",id:"v10-exploring-remote-components",depth:3},{text:"v2.0: Module Federation Experiment",id:"v20-module-federation-experiment",depth:3},{text:"Embracing the ESM Era",id:"embracing-the-esm-era",depth:2},{text:"Standardized Module System",id:"standardized-module-system",depth:3},{text:"Breakthroughs in Performance and Isolation",id:"breakthroughs-in-performance-and-isolation",depth:3},{text:"Build Tool Selection",id:"build-tool-selection",depth:3},{text:"Future Outlook",id:"future-outlook",depth:2},{text:"Deep Optimization of Import Maps",id:"deep-optimization-of-import-maps",depth:3},{text:"Framework-Agnostic Routing Solution",id:"framework-agnostic-routing-solution",depth:3},{text:"Best Practices for Cross-Framework Communication",id:"best-practices-for-cross-framework-communication",depth:3}],title:"From Component Sharing to Native Modularity: The Evolution of the Gez Micro-Frontend Framework",headingTitle:"From Component Sharing to Native Modularity: The Evolution of the Gez Micro-Frontend Framework",frontmatter:{titleSuffix:"From Micro-Frontend Challenges to ESM Innovation: The Evolution of the Gez Framework",description:"Explore the journey of the Gez framework from the challenges of traditional micro-frontend architectures to breakthroughs in ESM-based innovation. Share technical practices in performance optimization, dependency management, and build tool selection.",head:[["meta",{property:"keywords",content:"Gez, Micro-Frontend Framework, ESM, Import Maps, Rspack, Module Federation, Dependency Management, Performance Optimization, Technical Evolution, Server-Side Rendering"}]],sidebar:!1}}}}]);