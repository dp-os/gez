"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["5161"],{7647:function(n,e,r){r.r(e),r.d(e,{default:()=>c});var s=r(1549),i=r(6603);function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",strong:"strong",ul:"ul",h2:"h2",code:"code",pre:"pre",h3:"h3",h4:"h4"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"렌더링-컨텍스트",children:["렌더링 컨텍스트",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#렌더링-컨텍스트",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext는 Gez 프레임워크의 핵심 클래스로, 서버 사이드 렌더링(SSR) 과정에서 리소스 관리와 HTML 생성을 주로 담당합니다. 이 클래스는 다음과 같은 핵심 특징을 가지고 있습니다:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"ESM 기반 모듈 시스템"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"현대적인 ECMAScript Modules 표준을 채택"}),"\n",(0,s.jsx)(e.li,{children:"네이티브 모듈 임포트/익스포트 지원"}),"\n",(0,s.jsx)(e.li,{children:"더 나은 코드 분할과 필요 시 로딩 구현"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"스마트 의존성 수집"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"실제 렌더링 경로를 기반으로 동적으로 의존성 수집"}),"\n",(0,s.jsx)(e.li,{children:"불필요한 리소스 로딩 방지"}),"\n",(0,s.jsx)(e.li,{children:"비동기 컴포넌트와 동적 임포트 지원"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"정확한 리소스 주입"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"리소스 로딩 순서를 엄격히 제어"}),"\n",(0,s.jsx)(e.li,{children:"초기 로딩 성능 최적화"}),"\n",(0,s.jsx)(e.li,{children:"클라이언트 측 활성화(Hydration)의 신뢰성 보장"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"유연한 설정 메커니즘"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"동적 베이스 경로 설정 지원"}),"\n",(0,s.jsx)(e.li,{children:"다양한 임포트 매핑 모드 제공"}),"\n",(0,s.jsx)(e.li,{children:"다양한 배포 시나리오에 적응 가능"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"사용-방법",children:["사용 방법",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#사용-방법",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["Gez 프레임워크에서 개발자는 일반적으로 RenderContext 인스턴스를 직접 생성하지 않고, ",(0,s.jsx)(e.code,{children:"gez.render()"})," 메서드를 통해 인스턴스를 얻습니다:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"async server(gez) {\n    const server = http.createServer((req, res) => {\n        // 정적 파일 처리\n        gez.middleware(req, res, async () => {\n            // gez.render()를 통해 RenderContext 인스턴스 획득\n            const rc = await gez.render({\n                params: {\n                    url: req.url\n                }\n            });\n            // HTML 내용 응답\n            res.end(rc.html);\n        });\n    });\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"주요-기능",children:["주요 기능",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#주요-기능",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"의존성-수집",children:["의존성 수집",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#의존성-수집",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext는 스마트 의존성 수집 메커니즘을 구현하여, 실제 렌더링되는 컴포넌트를 기반으로 동적으로 의존성을 수집합니다:"}),"\n",(0,s.jsxs)(e.h4,{id:"필요-시-수집",children:["필요 시 수집",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#필요-시-수집",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"컴포넌트가 실제로 렌더링되는 과정에서 모듈 의존성을 자동으로 추적 및 기록"}),"\n",(0,s.jsx)(e.li,{children:"현재 페이지 렌더링 시 실제로 사용되는 CSS, JavaScript 등의 리소스만 수집"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"importMetaSet"}),"을 통해 각 컴포넌트의 모듈 의존 관계를 정확히 기록"]}),"\n",(0,s.jsx)(e.li,{children:"비동기 컴포넌트와 동적 임포트의 의존성 수집 지원"}),"\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"자동화-처리",children:["자동화 처리",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#자동화-처리",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"개발자가 수동으로 의존성 수집 과정을 관리할 필요 없음"}),"\n",(0,s.jsx)(e.li,{children:"프레임워크가 컴포넌트 렌더링 시 자동으로 의존성 정보 수집"}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"commit()"})," 메서드를 통해 수집된 모든 리소스를 통합 처리"]}),"\n",(0,s.jsx)(e.li,{children:"순환 의존성과 중복 의존성 문제 자동 처리"}),"\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"성능-최적화",children:["성능 최적화",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#성능-최적화",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"사용되지 않는 모듈 로딩 방지로 초기 로딩 시간 단축"}),"\n",(0,s.jsx)(e.li,{children:"리소스 로딩 순서를 정확히 제어하여 페이지 렌더링 성능 최적화"}),"\n",(0,s.jsx)(e.li,{children:"최적의 임포트 매핑(Import Map) 자동 생성"}),"\n",(0,s.jsx)(e.li,{children:"리소스 프리로드 및 필요 시 로딩 전략 지원"}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"리소스-주입",children:["리소스 주입",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#리소스-주입",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext는 다양한 유형의 리소스를 주입하기 위한 여러 메서드를 제공하며, 각 메서드는 리소스 로딩 성능을 최적화하기 위해 설계되었습니다:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"preload()"}),": CSS 및 JS 리소스 프리로드, 우선순위 설정 지원"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"css()"}),": 초기 스타일시트 주입, 핵심 CSS 추출 지원"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"importmap()"}),": 모듈 임포트 매핑 주입, 동적 경로 해석 지원"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"moduleEntry()"}),": 클라이언트 측 진입 모듈 주입, 다중 진입점 설정 지원"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"modulePreload()"}),": 모듈 의존성 프리로드, 필요 시 로딩 전략 지원"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"리소스-주입-순서",children:["리소스 주입 순서",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#리소스-주입-순서",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext는 리소스 주입 순서를 엄격히 제어하며, 이 순서는 브라우저의 작동 원리와 성능 최적화를 고려하여 설계되었습니다:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"head 부분:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"preload()"}),": CSS 및 JS 리소스 프리로드, 브라우저가 가능한 한 빨리 이러한 리소스를 발견하고 로딩 시작"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"css()"}),": 초기 스타일시트 주입, 콘텐츠 렌더링 시 스타일이 준비되도록 보장"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"body 부분:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"importmap()"}),": 모듈 임포트 매핑 주입, ESM 모듈의 경로 해석 규칙 정의"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"moduleEntry()"}),": 클라이언트 측 진입 모듈 주입, importmap 이후에 실행되어야 함"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"modulePreload()"}),": 모듈 의존성 프리로드, importmap 이후에 실행되어야 함"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"전체-렌더링-프로세스",children:["전체 렌더링 프로세스",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#전체-렌더링-프로세스",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"일반적인 RenderContext 사용 프로세스는 다음과 같습니다:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.server.ts"',children:"export default async (rc: RenderContext) => {\n    // 1. 페이지 콘텐츠 렌더링 및 의존성 수집\n    const app = createApp();\n    const html = await renderToString(app, {\n       importMetaSet: rc.importMetaSet\n    });\n\n    // 2. 의존성 수집 완료\n    await rc.commit();\n    \n    // 3. 완전한 HTML 생성\n    rc.html = `\n        <!DOCTYPE html>\n        <html>\n        <head>\n            ${rc.preload()}\n            ${rc.css()}\n        </head>\n        <body>\n            ${html}\n            ${rc.importmap()}\n            ${rc.moduleEntry()}\n            ${rc.modulePreload()}\n        </body>\n        </html>\n    `;\n};\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"고급-기능",children:["고급 기능",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#고급-기능",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"베이스-경로-설정",children:["베이스 경로 설정",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#베이스-경로-설정",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext는 유연한 동적 베이스 경로 설정 메커니즘을 제공하며, 런타임에 정적 리소스의 베이스 경로를 동적으로 설정할 수 있습니다:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    base: '/gez',  // 베이스 경로 설정\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"이 메커니즘은 다음과 같은 시나리오에 특히 유용합니다:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"다국어 사이트 배포"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"메인도메인.com      → 기본 언어\n메인도메인.com/cn/  → 중국어 사이트\n메인도메인.com/en/  → 영어 사이트\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"마이크로 프론트엔드 애플리케이션"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"서브 애플리케이션을 다양한 경로에 유연하게 배포 지원"}),"\n",(0,s.jsx)(e.li,{children:"다른 메인 애플리케이션에 통합하기 용이"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"임포트-매핑-모드",children:["임포트 매핑 모드",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#임포트-매핑-모드",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext는 두 가지 임포트 매핑(Import Map) 모드를 제공합니다:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Inline 모드"})," (기본값)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"임포트 매핑을 HTML에 직접 인라인으로 포함"}),"\n",(0,s.jsx)(e.li,{children:"소형 애플리케이션에 적합, 추가 네트워크 요청 감소"}),"\n",(0,s.jsx)(e.li,{children:"페이지 로딩 시 즉시 사용 가능"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"JS 모드"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"외부 JavaScript 파일을 통해 임포트 매핑 로딩"}),"\n",(0,s.jsx)(e.li,{children:"대형 애플리케이션에 적합, 브라우저 캐시 메커니즘 활용 가능"}),"\n",(0,s.jsx)(e.li,{children:"매핑 내용 동적 업데이트 지원"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"설정을 통해 적절한 모드를 선택할 수 있습니다:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    importmapMode: 'js',  // 'inline' | 'js'\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"진입-함수-설정",children:["진입 함수 설정",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#진입-함수-설정",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["RenderContext는 ",(0,s.jsx)(e.code,{children:"entryName"})," 설정을 통해 서버 사이드 렌더링의 진입 함수를 지정할 수 있습니다:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    entryName: 'mobile',  // 모바일 진입 함수 사용 지정\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"이 메커니즘은 다음과 같은 시나리오에 특히 유용합니다:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"다중 템플릿 렌더링"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.server.ts"',children:"// 모바일 진입 함수\nexport const mobile = async (rc: RenderContext) => {\n    // 모바일 전용 렌더링 로직\n};\n\n// 데스크톱 진입 함수\nexport const desktop = async (rc: RenderContext) => {\n    // 데스크톱 전용 렌더링 로직\n};\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"A/B 테스트"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"동일 페이지에 다른 렌더링 로직 사용 지원"}),"\n",(0,s.jsx)(e.li,{children:"사용자 경험 실험에 용이"}),"\n",(0,s.jsx)(e.li,{children:"다양한 렌더링 전략 유연하게 전환"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"특수 렌더링 요구사항"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"특정 페이지에 맞춤형 렌더링 프로세스 사용 지원"}),"\n",(0,s.jsx)(e.li,{children:"다양한 시나리오의 성능 최적화 요구사항에 적응"}),"\n",(0,s.jsx)(e.li,{children:"더 세밀한 렌더링 제어 구현"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"모범-사례",children:["모범 사례",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#모범-사례",children:"#"})]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"RenderContext 인스턴스 획득"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["항상 ",(0,s.jsx)(e.code,{children:"gez.render()"})," 메서드를 통해 인스턴스 획득"]}),"\n",(0,s.jsx)(e.li,{children:"필요에 따라 적절한 매개변수 전달"}),"\n",(0,s.jsx)(e.li,{children:"수동으로 인스턴스 생성하지 않기"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"의존성 수집"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["모든 모듈이 ",(0,s.jsx)(e.code,{children:"importMetaSet.add(import.meta)"}),"를 올바르게 호출하도록 보장"]}),"\n",(0,s.jsxs)(e.li,{children:["렌더링 완료 후 즉시 ",(0,s.jsx)(e.code,{children:"commit()"})," 메서드 호출"]}),"\n",(0,s.jsx)(e.li,{children:"비동기 컴포넌트와 동적 임포트를 적절히 사용하여 초기 로딩 최적화"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"리소스 주입"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"리소스 주입 순서를 엄격히 준수"}),"\n",(0,s.jsx)(e.li,{children:"body 부분에 CSS를 주입하지 않기"}),"\n",(0,s.jsx)(e.li,{children:"importmap이 moduleEntry보다 먼저 실행되도록 보장"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"성능 최적화"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"preload를 사용하여 핵심 리소스 프리로드"}),"\n",(0,s.jsx)(e.li,{children:"modulePreload를 적절히 사용하여 모듈 로딩 최적화"}),"\n",(0,s.jsx)(e.li,{children:"불필요한 리소스 로딩 방지"}),"\n",(0,s.jsx)(e.li,{children:"브라우저 캐시 메커니즘 활용하여 로딩 성능 최적화"}),"\n"]}),"\n"]}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["ko%2Fguide%2Fessentials%2Frender-context.md"]={toc:[{text:"사용 방법",id:"사용-방법",depth:2},{text:"주요 기능",id:"주요-기능",depth:2},{text:"의존성 수집",id:"의존성-수집",depth:3},{text:"필요 시 수집",id:"필요-시-수집",depth:4},{text:"자동화 처리",id:"자동화-처리",depth:4},{text:"성능 최적화",id:"성능-최적화",depth:4},{text:"리소스 주입",id:"리소스-주입",depth:3},{text:"리소스 주입 순서",id:"리소스-주입-순서",depth:3},{text:"전체 렌더링 프로세스",id:"전체-렌더링-프로세스",depth:2},{text:"고급 기능",id:"고급-기능",depth:2},{text:"베이스 경로 설정",id:"베이스-경로-설정",depth:3},{text:"임포트 매핑 모드",id:"임포트-매핑-모드",depth:3},{text:"진입 함수 설정",id:"진입-함수-설정",depth:3},{text:"모범 사례",id:"모범-사례",depth:2}],title:"렌더링 컨텍스트",headingTitle:"렌더링 컨텍스트",frontmatter:{titleSuffix:"Gez 프레임워크 서버 사이드 렌더링 핵심 메커니즘",description:"Gez 프레임워크의 렌더링 컨텍스트(RenderContext) 메커니즘에 대해 자세히 설명합니다. 리소스 관리, HTML 생성 및 ESM 모듈 시스템을 포함하여 개발자가 서버 사이드 렌더링(SSR) 기능을 이해하고 사용할 수 있도록 돕습니다.",head:[["meta",{property:"keywords",content:"Gez, 렌더링 컨텍스트, RenderContext, SSR, 서버 사이드 렌더링, ESM, 리소스 관리"}]]}}}}]);