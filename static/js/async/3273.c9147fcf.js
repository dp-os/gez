"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["3273"],{1948:function(n,e,r){r.r(e),r.d(e,{default:()=>c});var s=r(1549),i=r(6603);function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",strong:"strong",ul:"ul",h2:"h2",code:"code",pre:"pre",h3:"h3",h4:"h4"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"渲染上下文",children:["渲染上下文",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染上下文",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext 是 Gez 框架中的一个核心类，主要负责服务端渲染（SSR）过程中的资源管理和 HTML 生成。它具有以下核心特点："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基于 ESM 的模块系统"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"采用现代的 ECMAScript Modules 标准"}),"\n",(0,s.jsx)(e.li,{children:"支持原生的模块导入导出"}),"\n",(0,s.jsx)(e.li,{children:"实现了更好的代码分割和按需加载"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"智能依赖收集"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"基于实际渲染路径动态收集依赖"}),"\n",(0,s.jsx)(e.li,{children:"避免不必要的资源加载"}),"\n",(0,s.jsx)(e.li,{children:"支持异步组件和动态导入"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"精确的资源注入"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"严格控制资源加载顺序"}),"\n",(0,s.jsx)(e.li,{children:"优化首屏加载性能"}),"\n",(0,s.jsx)(e.li,{children:"确保客户端激活（Hydration）的可靠性"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"灵活的配置机制"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"支持动态基础路径配置"}),"\n",(0,s.jsx)(e.li,{children:"提供多种导入映射模式"}),"\n",(0,s.jsx)(e.li,{children:"适应不同的部署场景"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"使用方式",children:["使用方式",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用方式",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在 Gez 框架中，开发者通常不需要直接创建 RenderContext 实例，而是通过 ",(0,s.jsx)(e.code,{children:"gez.render()"})," 方法来获取实例："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"async server(gez) {\n    const server = http.createServer((req, res) => {\n        // 静态文件处理\n        gez.middleware(req, res, async () => {\n            // 通过 gez.render() 获取 RenderContext 实例\n            const rc = await gez.render({\n                params: {\n                    url: req.url\n                }\n            });\n            // 响应 HTML 内容\n            res.end(rc.html);\n        });\n    });\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"主要功能",children:["主要功能",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#主要功能",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"依赖收集",children:["依赖收集",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖收集",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext 实现了一套智能的依赖收集机制，它基于实际渲染的组件来动态收集依赖，而不是简单地预加载所有可能用到的资源："}),"\n",(0,s.jsxs)(e.h4,{id:"按需收集",children:["按需收集",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#按需收集",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"在组件实际渲染过程中自动追踪和记录模块依赖"}),"\n",(0,s.jsx)(e.li,{children:"只收集当前页面渲染时真正使用到的 CSS、JavaScript 等资源"}),"\n",(0,s.jsxs)(e.li,{children:["通过 ",(0,s.jsx)(e.code,{children:"importMetaSet"})," 精确记录每个组件的模块依赖关系"]}),"\n",(0,s.jsx)(e.li,{children:"支持异步组件和动态导入的依赖收集"}),"\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"自动化处理",children:["自动化处理",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自动化处理",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"开发者无需手动管理依赖收集过程"}),"\n",(0,s.jsx)(e.li,{children:"框架自动在组件渲染时收集依赖信息"}),"\n",(0,s.jsxs)(e.li,{children:["通过 ",(0,s.jsx)(e.code,{children:"commit()"})," 方法统一处理所有收集到的资源"]}),"\n",(0,s.jsx)(e.li,{children:"自动处理循环依赖和重复依赖的问题"}),"\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"性能优化",children:["性能优化",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#性能优化",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"避免加载未使用的模块，显著减少首屏加载时间"}),"\n",(0,s.jsx)(e.li,{children:"精确控制资源加载顺序，优化页面渲染性能"}),"\n",(0,s.jsx)(e.li,{children:"自动生成最优的导入映射（Import Map）"}),"\n",(0,s.jsx)(e.li,{children:"支持资源预加载和按需加载策略"}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"资源注入",children:["资源注入",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#资源注入",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext 提供了多个方法来注入不同类型的资源，每个方法都经过精心设计以优化资源加载性能："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"preload()"}),"：预加载 CSS 和 JS 资源，支持优先级配置"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"css()"}),"：注入首屏样式表，支持关键 CSS 提取"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"importmap()"}),"：注入模块导入映射，支持动态路径解析"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"moduleEntry()"}),"：注入客户端入口模块，支持多入口配置"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"modulePreload()"}),"：预加载模块依赖，支持按需加载策略"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"资源注入顺序",children:["资源注入顺序",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#资源注入顺序",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext 严格控制资源注入顺序，这种顺序设计是基于浏览器的工作原理和性能优化考虑："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"head 部分："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"preload()"}),"：预加载 CSS 和 JS 资源，让浏览器尽早发现并开始加载这些资源"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"css()"}),"：注入首屏样式表，确保页面样式在内容渲染时就位"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"body 部分："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"importmap()"}),"：注入模块导入映射，定义 ESM 模块的路径解析规则"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"moduleEntry()"}),"：注入客户端入口模块，必须在 importmap 之后执行"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"modulePreload()"}),"：预加载模块依赖，必须在 importmap 之后执行"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"完整渲染流程",children:["完整渲染流程",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#完整渲染流程",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"一个典型的 RenderContext 使用流程如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.server.ts"',children:"export default async (rc: RenderContext) => {\n    // 1. 渲染页面内容并收集依赖\n    const app = createApp();\n    const html = await renderToString(app, {\n       importMetaSet: rc.importMetaSet\n    });\n\n    // 2. 提交依赖收集\n    await rc.commit();\n    \n    // 3. 生成完整 HTML\n    rc.html = `\n        <!DOCTYPE html>\n        <html>\n        <head>\n            ${rc.preload()}\n            ${rc.css()}\n        </head>\n        <body>\n            ${html}\n            ${rc.importmap()}\n            ${rc.moduleEntry()}\n            ${rc.modulePreload()}\n        </body>\n        </html>\n    `;\n};\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"高级特性",children:["高级特性",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#高级特性",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"基础路径配置",children:["基础路径配置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#基础路径配置",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext 提供了一个灵活的动态基础路径配置机制，支持在运行时动态设置静态资源的基础路径："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    base: '/gez',  // 设置基础路径\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"这种机制特别适用于以下场景："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"多语言站点部署"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"主域名.com      → 默认语言\n主域名.com/cn/  → 中文站点\n主域名.com/en/  → 英文站点\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"微前端应用"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"支持子应用在不同路径下灵活部署"}),"\n",(0,s.jsx)(e.li,{children:"便于集成到不同的主应用中"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"导入映射模式",children:["导入映射模式",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#导入映射模式",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RenderContext 提供了两种导入映射（Import Map）模式："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Inline 模式"}),"（默认）"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"将导入映射直接内联到 HTML 中"}),"\n",(0,s.jsx)(e.li,{children:"适合小型应用，减少额外的网络请求"}),"\n",(0,s.jsx)(e.li,{children:"页面加载时立即可用"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"JS 模式"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"通过外部 JavaScript 文件加载导入映射"}),"\n",(0,s.jsx)(e.li,{children:"适合大型应用，可以利用浏览器缓存机制"}),"\n",(0,s.jsx)(e.li,{children:"支持动态更新映射内容"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"可以通过配置选择合适的模式："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    importmapMode: 'js',  // 'inline' | 'js'\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"入口函数配置",children:["入口函数配置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#入口函数配置",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["RenderContext 支持通过 ",(0,s.jsx)(e.code,{children:"entryName"})," 配置来指定服务端渲染的入口函数："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.node.ts"',children:"const rc = await gez.render({\n    entryName: 'mobile',  // 指定使用移动端入口函数\n    params: {\n        url: req.url\n    }\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"这种机制特别适用于以下场景："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"多模板渲染"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",meta:'title="src/entry.server.ts"',children:"// 移动端入口函数\nexport const mobile = async (rc: RenderContext) => {\n    // 移动端特定的渲染逻辑\n};\n\n// 桌面端入口函数\nexport const desktop = async (rc: RenderContext) => {\n    // 桌面端特定的渲染逻辑\n};\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"A/B 测试"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"支持同一页面使用不同的渲染逻辑"}),"\n",(0,s.jsx)(e.li,{children:"便于进行用户体验实验"}),"\n",(0,s.jsx)(e.li,{children:"灵活切换不同的渲染策略"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"特殊渲染需求"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"支持某些页面使用自定义的渲染流程"}),"\n",(0,s.jsx)(e.li,{children:"适应不同场景的性能优化需求"}),"\n",(0,s.jsx)(e.li,{children:"实现更精细的渲染控制"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"最佳实践",children:["最佳实践",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#最佳实践",children:"#"})]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"获取 RenderContext 实例"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["始终通过 ",(0,s.jsx)(e.code,{children:"gez.render()"})," 方法获取实例"]}),"\n",(0,s.jsx)(e.li,{children:"根据需要传入适当的参数"}),"\n",(0,s.jsx)(e.li,{children:"避免手动创建实例"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"依赖收集"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["确保所有模块都正确调用 ",(0,s.jsx)(e.code,{children:"importMetaSet.add(import.meta)"})]}),"\n",(0,s.jsxs)(e.li,{children:["在渲染完成后立即调用 ",(0,s.jsx)(e.code,{children:"commit()"})," 方法"]}),"\n",(0,s.jsx)(e.li,{children:"合理使用异步组件和动态导入优化首屏加载"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"资源注入"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"严格遵循资源注入顺序"}),"\n",(0,s.jsx)(e.li,{children:"不要在 body 中注入 CSS"}),"\n",(0,s.jsx)(e.li,{children:"确保 importmap 在 moduleEntry 之前"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"性能优化"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"使用 preload 预加载关键资源"}),"\n",(0,s.jsx)(e.li,{children:"合理使用 modulePreload 优化模块加载"}),"\n",(0,s.jsx)(e.li,{children:"避免不必要的资源加载"}),"\n",(0,s.jsx)(e.li,{children:"利用浏览器缓存机制优化加载性能"}),"\n"]}),"\n"]}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["zh%2Fguide%2Fessentials%2Frender-context.md"]={toc:[{text:"使用方式",id:"使用方式",depth:2},{text:"主要功能",id:"主要功能",depth:2},{text:"依赖收集",id:"依赖收集",depth:3},{text:"按需收集",id:"按需收集",depth:4},{text:"自动化处理",id:"自动化处理",depth:4},{text:"性能优化",id:"性能优化",depth:4},{text:"资源注入",id:"资源注入",depth:3},{text:"资源注入顺序",id:"资源注入顺序",depth:3},{text:"完整渲染流程",id:"完整渲染流程",depth:2},{text:"高级特性",id:"高级特性",depth:2},{text:"基础路径配置",id:"基础路径配置",depth:3},{text:"导入映射模式",id:"导入映射模式",depth:3},{text:"入口函数配置",id:"入口函数配置",depth:3},{text:"最佳实践",id:"最佳实践",depth:2}],title:"渲染上下文",headingTitle:"渲染上下文",frontmatter:{titleSuffix:"Gez 框架服务端渲染核心机制",description:"详细介绍 Gez 框架的渲染上下文（RenderContext）机制，包括资源管理、HTML 生成和 ESM 模块系统，帮助开发者理解和使用服务端渲染功能。",head:[["meta",{property:"keywords",content:"Gez, 渲染上下文, RenderContext, SSR, 服务端渲染, ESM, 资源管理"}]]}}}}]);