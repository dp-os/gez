[{"id":0,"title":"@gez/rspack-vue","content":"#\n\nDas Rspack Vue-Paket bietet eine API zum Erstellen und Konfigurieren von\nRspack-Anwendungen basierend auf dem Vue-Framework und unterstützt die\nEntwicklung, den Build und das Server-Side Rendering von Vue-Komponenten.\n\n\nInstallation#\n\nInstallieren Sie @gez/rspack-vue als Entwicklungsabhängigkeit mit einem\nPaketmanager:\n\n\nTypenexporte#\n\n\nBuildTarget#\n\n\n\nDer BuildTarget-Typ definiert die Zielumgebung für den Build der Anwendung und\nwird verwendet, um spezifische Optimierungen und Funktionen im Build-Prozess zu\nkonfigurieren:\n\n * node: Code, der in einer Node.js-Umgebung ausgeführt wird\n * client: Code, der in einer Browser-Umgebung ausgeführt wird\n * server: Code, der in einer Server-Umgebung ausgeführt wird\n\n\nRspackAppConfigContext#\n\n\n\nDas RspackAppConfigContext-Interface bietet Kontextinformationen, die in\nKonfigurations-Hook-Funktionen zugänglich sind:\n\n * gez: Gez Framework-Instanz\n * buildTarget: Aktuelles Build-Ziel (client/server/node)\n * config: Rspack-Konfigurationsobjekt\n * options: Anwendungskonfigurationsoptionen\n\n\nRspackAppOptions#\n\n\n\nDas RspackAppOptions-Interface:\n\n * css: CSS-Ausgabemethode, entweder 'css' (separate Datei) oder 'style'\n   (Inline-Styles)\n * loaders: Benutzerdefinierte Loader-Konfiguration\n * styleLoader: style-loader-Konfigurationsoptionen\n * cssLoader: css-loader-Konfigurationsoptionen\n * target: Build-Ziel-Kompatibilitätskonfiguration\n * definePlugin: Globale Konstantendefinition\n * config: Konfigurations-Hook-Funktion\n\n\nRspackHtmlAppOptions#\n\nErbt von RspackAppOptions und wird verwendet, um spezifische Optionen für\nHTML-Anwendungen zu konfigurieren.\n\n\nFunktionsexporte#\n\n\ncreateRspackApp#\n\n\n\nErstellt eine Standard-Rspack-Anwendungsinstanz.\n\nParameter:\n\n * gez: Gez Framework-Instanz\n * options: Rspack-Anwendungskonfigurationsoptionen\n\nRückgabewert:\n\n * Gibt ein Promise zurück, das in die erstellte Anwendungsinstanz aufgelöst\n   wird\n\n\ncreateRspackHtmlApp#\n\n\n\nErstellt eine HTML-Rspack-Anwendungsinstanz.\n\nParameter:\n\n * gez: Gez Framework-Instanz\n * options: HTML-Anwendungskonfigurationsoptionen\n\nRückgabewert:\n\n * Gibt ein Promise zurück, das in die erstellte HTML-Anwendungsinstanz\n   aufgelöst wird\n\n\nKonstantenexporte#\n\n\nRSPACK_LOADER#\n\n\n\nEin Mapping-Objekt für die internen Rspack-Loader-Bezeichner, das häufig\nverwendete Loader-Namen als Konstanten bereitstellt:\n\n * builtinSwcLoader: Interner SWC-Loader von Rspack, der\n   TypeScript/JavaScript-Dateien verarbeitet\n * lightningcssLoader: Interner lightningcss-Loader von Rspack, ein\n   Hochleistungs-Compiler für CSS-Dateien\n * styleLoader: Loader, der CSS in das DOM injiziert\n * cssLoader: Loader, der CSS-Dateien parst und CSS-Modularisierung verarbeitet\n * lessLoader: Loader, der Less-Dateien in CSS kompiliert\n * styleResourcesLoader: Loader, der automatisch globale Stilressourcen (wie\n   Variablen, Mixins) importiert\n * workerRspackLoader: Loader, der Web Worker-Dateien verarbeitet\n\nDiese Konstanten können in der Konfiguration verwendet werden, um auf interne\nLoader zu verweisen, anstatt Zeichenketten manuell einzugeben:\n\n\n\nHinweise:\n\n * Diese Loader sind bereits in Rspack integriert und müssen nicht zusätzlich\n   installiert werden\n * Bei benutzerdefinierten Loader-Konfigurationen können diese Konstanten\n   verwendet werden, um die Standard-Loader-Implementierung zu ersetzen\n * Einige Loader (wie builtinSwcLoader) haben spezifische\n   Konfigurationsoptionen. Bitte konsultieren Sie die entsprechende\n   Dokumentation\n\n\nModulexporte#\n\n\nrspack#\n\nRe-Exportiert alle Inhalte des @rspack/core-Pakets und bietet vollständige\nRspack-Kernfunktionalität.","routePath":"/de/api/app/rspack-vue","lang":"de","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":222},{"text":"Typenexporte","id":"typenexporte","depth":2,"charIndex":325},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":341},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":720},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1043},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1480},{"text":"Funktionsexporte","id":"funktionsexporte","depth":2,"charIndex":1614},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1634},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1901},{"text":"Konstantenexporte","id":"konstantenexporte","depth":2,"charIndex":2171},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2192},{"text":"Modulexporte","id":"modulexporte","depth":2,"charIndex":3463},{"text":"rspack","id":"rspack","depth":3,"charIndex":3479}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Vue Build-Tool","description":"Spezielles Build-Tool des Gez Frameworks für Vue, das umfassende Unterstützung für den Aufbau von Vue 2/3-Anwendungen bietet, einschließlich Komponentenentwicklung, SSR-Rendering und Leistungsoptimierung.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, Build-Tool, Komponentenentwicklung, Server-Side Rendering, Leistungsoptimierung"}]]},"version":""},{"id":1,"title":"@gez/rspack","content":"#\n\nDas Rspack-Paket bietet eine API zum Erstellen und Konfigurieren von\nRspack-Anwendungen und unterstützt den Build und die Entwicklung von\nStandardanwendungen und HTML-Anwendungen.\n\n\nInstallation#\n\nInstallieren Sie @gez/rspack als Entwicklungsabhängigkeit mit einem\nPaketmanager:\n\n\nTypenexporte#\n\n\nBuildTarget#\n\n\n\nDer BuildTarget-Typ definiert die Zielumgebung für den Build der Anwendung und\nwird verwendet, um spezifische Optimierungen und Funktionen im Build-Prozess zu\nkonfigurieren:\n\n * node: Code, der in einer Node.js-Umgebung ausgeführt wird\n * client: Code, der in einer Browser-Umgebung ausgeführt wird\n * server: Code, der in einer Server-Umgebung ausgeführt wird\n\n\nRspackAppConfigContext#\n\n\n\nDas RspackAppConfigContext-Interface bietet Kontextinformationen, die in\nKonfigurations-Hook-Funktionen zugänglich sind:\n\n * gez: Gez Framework-Instanz\n * buildTarget: Aktuelles Build-Ziel (client/server/node)\n * config: Rspack-Konfigurationsobjekt\n * options: Anwendungskonfigurationsoptionen\n\n\nRspackAppOptions#\n\n\n\nDas RspackAppOptions-Interface:\n\n * css: CSS-Ausgabemethode, entweder 'css' (separate Datei) oder 'style'\n   (Inline-Styles)\n * loaders: Benutzerdefinierte Loader-Konfiguration\n * styleLoader: style-loader-Konfigurationsoptionen\n * cssLoader: css-loader-Konfigurationsoptionen\n * target: Build-Ziel-Kompatibilitätskonfiguration\n * definePlugin: Globale Konstantendefinition\n * config: Konfigurations-Hook-Funktion\n\n\nRspackHtmlAppOptions#\n\nErbt von RspackAppOptions und wird verwendet, um spezifische Optionen für\nHTML-Anwendungen zu konfigurieren.\n\n\nFunktionsexporte#\n\n\ncreateRspackApp#\n\n\n\nErstellt eine Standard-Rspack-Anwendungsinstanz.\n\nParameter:\n\n * gez: Gez Framework-Instanz\n * options: Rspack-Anwendungskonfigurationsoptionen\n\nRückgabewert:\n\n * Gibt ein Promise zurück, das in die erstellte Anwendungsinstanz aufgelöst\n   wird\n\n\ncreateRspackHtmlApp#\n\n\n\nErstellt eine HTML-Rspack-Anwendungsinstanz.\n\nParameter:\n\n * gez: Gez Framework-Instanz\n * options: HTML-Anwendungskonfigurationsoptionen\n\nRückgabewert:\n\n * Gibt ein Promise zurück, das in die erstellte HTML-Anwendungsinstanz\n   aufgelöst wird\n\n\nKonstantenexporte#\n\n\nRSPACK_LOADER#\n\n\n\nEin Mapping-Objekt für integrierte Rspack-Loader-Identifikatoren, das häufig\nverwendete Loader-Namen als Konstanten bereitstellt:\n\n * builtinSwcLoader: Integrierter SWC-Loader von Rspack, verarbeitet\n   TypeScript/JavaScript-Dateien\n * lightningcssLoader: Integrierter lightningcss-Loader von Rspack, ein\n   leistungsstarker Compiler für CSS-Dateien\n * styleLoader: Loader, der CSS in das DOM injiziert\n * cssLoader: Loader, der CSS-Dateien parst und CSS-Modularisierung verarbeitet\n * lessLoader: Loader, der Less-Dateien in CSS kompiliert\n * styleResourcesLoader: Loader, der automatisch globale Stilressourcen (wie\n   Variablen, Mixins) importiert\n * workerRspackLoader: Loader, der Web Worker-Dateien verarbeitet\n\nDiese Konstanten können in der Konfiguration verwendet werden, um auf\nintegrierte Loader zu verweisen, anstatt Strings manuell einzugeben:\n\n\n\nHinweise:\n\n * Diese Loader sind bereits in Rspack integriert und müssen nicht zusätzlich\n   installiert werden\n * Bei benutzerdefinierten Loader-Konfigurationen können diese Konstanten\n   verwendet werden, um die Standard-Loader-Implementierung zu ersetzen\n * Einige Loader (wie builtinSwcLoader) haben spezifische\n   Konfigurationsoptionen. Bitte konsultieren Sie die entsprechende\n   Dokumentation\n\n\nModulexporte#\n\n\nrspack#\n\nRe-Exportiert alle Inhalte des @rspack/core-Pakets und bietet vollständige\nRspack-Kernfunktionen.","routePath":"/de/api/app/rspack","lang":"de","toc":[{"text":"Installation","id":"installation","depth":2,"charIndex":184},{"text":"Typenexporte","id":"typenexporte","depth":2,"charIndex":283},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":299},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":678},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":1001},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":1438},{"text":"Funktionsexporte","id":"funktionsexporte","depth":2,"charIndex":1572},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":1592},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1859},{"text":"Konstantenexporte","id":"konstantenexporte","depth":2,"charIndex":2129},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":2150},{"text":"Modulexporte","id":"modulexporte","depth":2,"charIndex":3430},{"text":"rspack","id":"rspack","depth":3,"charIndex":3446}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Rspack Build-Tool","description":"Das Rspack Build-Tool des Gez Frameworks bietet leistungsstarke Anwendungsbuild-Fähigkeiten, unterstützt die Entwicklung und den Build von Standardanwendungen und HTML-Anwendungen und verfügt über integrierte Ressourcenprozessoren und Optimierungskonfigurationen.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Build-Tool, Anwendungsbuild, HTML-Anwendung, TypeScript, CSS, Ressourcenverarbeitung, Leistungsoptimierung"}]]},"version":""},{"id":2,"title":"App","content":"#\n\nApp ist die Anwendungsabstraktion des Gez-Frameworks und bietet eine\neinheitliche Schnittstelle zur Verwaltung des Anwendungslebenszyklus, statischer\nRessourcen und des serverseitigen Renderings.\n\n\n\n\nTypdefinitionen#\n\n\nApp#\n\n\n\nmiddleware#\n\n * Typ: Middleware\n\nMiddleware zur Verarbeitung statischer Ressourcen.\n\nEntwicklungsumgebung:\n\n * Verarbeitet Anfragen für statische Ressourcen des Quellcodes\n * Unterstützt Echtzeit-Kompilierung und Hot Reload\n * Verwendet No-Cache-Caching-Strategie\n\nProduktionsumgebung:\n\n * Verarbeitet gebaute statische Ressourcen\n * Unterstützt langfristiges Caching unveränderlicher Dateien (.final.xxx)\n * Optimierte Ressourcenlade-Strategie\n\n\n\nrender#\n\n * Typ: (options?: RenderContextOptions) => Promise\n\nServerseitige Rendering-Funktion. Bietet unterschiedliche Implementierungen\nbasierend auf der Laufzeitumgebung:\n\n * Produktionsumgebung (start): Lädt die gebaute serverseitige Einstiegsdatei\n   (entry.server) und führt das Rendering aus\n * Entwicklungsumgebung (dev): Lädt die serverseitige Einstiegsdatei aus dem\n   Quellcode und führt das Rendering aus\n\n\n\nbuild#\n\n * Typ: () => Promise\n\nProduktions-Build-Funktion. Wird für das Packen und Optimieren von Ressourcen\nverwendet. Gibt bei erfolgreichem Build true zurück, bei Fehlschlag false.\n\ndestroy#\n\n * Typ: () => Promise\n\nRessourcenbereinigungsfunktion. Wird zum Herunterfahren des Servers, Trennen von\nVerbindungen usw. verwendet. Gibt bei erfolgreicher Bereinigung true zurück, bei\nFehlschlag false.","routePath":"/de/api/core/app","lang":"de","toc":[{"text":"Typdefinitionen","id":"typdefinitionen","depth":2,"charIndex":202},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":229},{"text":"render","id":"render","depth":4,"charIndex":677},{"text":"build","id":"build","depth":4,"charIndex":1097},{"text":"destroy","id":"destroy","depth":4,"charIndex":1282}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Anwendungsabstraktionsschnittstelle","description":"Detaillierte Beschreibung der App-Schnittstelle des Gez-Frameworks, einschließlich Anwendungslebenszyklusverwaltung, statischer Ressourcenverarbeitung und serverseitigem Rendering, um Entwicklern zu helfen, die Kernfunktionen der Anwendung zu verstehen und zu nutzen.","head":[["meta",{"property":"keywords","content":"Gez, App, Anwendungsabstraktion, Lebenszyklus, statische Ressourcen, serverseitiges Rendering, API"}]]},"version":""},{"id":3,"title":"Gez","content":"#\n\n\nEinführung#\n\nGez ist ein leistungsstarkes Web-Anwendungsframework, das auf Rspack basiert und\neine vollständige Verwaltung des Anwendungslebenszyklus, die Verarbeitung\nstatischer Ressourcen und serverseitige Rendering-Fähigkeiten bietet.\n\n\nTypdefinitionen#\n\n\nRuntimeTarget#\n\n * Typdefinition:\n\n\n\nTyp der Laufzeitumgebung der Anwendung:\n\n * client: Läuft in der Browserumgebung und unterstützt DOM-Operationen und\n   Browser-APIs\n * server: Läuft in der Node.js-Umgebung und unterstützt Dateisystem- und\n   serverseitige Funktionen\n\n\nImportMap#\n\n * Typdefinition:\n\n\n\nTyp der ES-Modul-Importzuordnung.\n\nSpecifierMap#\n\n * Typdefinition:\n\n\n\nTyp der Modulbezeichnerzuordnung, der verwendet wird, um die Zuordnung von\nModulimportpfaden zu definieren.\n\nScopesMap#\n\n * Typdefinition:\n\n\n\nTyp der Bereichszuordnung, der verwendet wird, um die Modulimportzuordnung in\nbestimmten Bereichen zu definieren.\n\n\nCOMMAND#\n\n * Typdefinition:\n\n\n\nEnumeration der Befehlstypen:\n\n * dev: Befehl für die Entwicklungsumgebung, startet den Entwicklungsserver und\n   unterstützt Hot Reload\n * build: Build-Befehl, erzeugt Build-Artefakte für die Produktionsumgebung\n * preview: Vorschau-Befehl, startet den lokalen Vorschauserver\n * start: Start-Befehl, führt den Produktionsserver aus\n\n\nInstanzoptionen#\n\nDefiniert die Kernkonfigurationsoptionen des Gez-Frameworks.\n\n\n\nroot#\n\n * Typ: string\n * Standardwert: process.cwd()\n\nPfad zum Projektstammverzeichnis. Kann ein absoluter oder relativer Pfad sein,\nrelative Pfade werden basierend auf dem aktuellen Arbeitsverzeichnis aufgelöst.\n\nisProd#\n\n * Typ: boolean\n * Standardwert: process.env.NODE_ENV === 'production'\n\nUmgebungsflag.\n\n * true: Produktionsumgebung\n * false: Entwicklungsumgebung\n\nbasePathPlaceholder#\n\n * Typ: string | false\n * Standardwert: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nKonfiguration des Basis-Pfad-Platzhalters. Wird zur Laufzeit verwendet, um den\nBasis-Pfad von Ressourcen dynamisch zu ersetzen. Durch Setzen auf false kann\ndiese Funktion deaktiviert werden.\n\nmodules#\n\n * Typ: ModuleConfig\n\nModulkonfigurationsoptionen. Wird verwendet, um die Modulauflösungsregeln des\nProjekts zu konfigurieren, einschließlich Modulaliase und externer\nAbhängigkeiten.\n\npacks#\n\n * Typ: PackConfig\n\nBuild-Konfigurationsoptionen. Wird verwendet, um Build-Artefakte in\nstandardmäßige npm .tgz-Pakete zu packen.\n\ndevApp#\n\n * Typ: (gez: Gez) => Promise\n\nFunktion zur Erstellung der Anwendung in der Entwicklungsumgebung. Wird nur in\nder Entwicklungsumgebung verwendet, um eine Anwendungsinstanz für den\nEntwicklungsserver zu erstellen.\n\n\n\nserver#\n\n * Typ: (gez: Gez) => Promise\n\nFunktion zur Konfiguration und zum Starten des HTTP-Servers. Wird verwendet, um\nden HTTP-Server zu konfigurieren und zu starten, sowohl in der\nEntwicklungsumgebung als auch in der Produktionsumgebung.\n\n\n\npostBuild#\n\n * Typ: (gez: Gez) => Promise\n\nFunktion zur Nachbearbeitung nach dem Build. Wird nach Abschluss des\nProjektbuilds ausgeführt und kann verwendet werden für:\n\n * Zusätzliche Ressourcenverarbeitung\n * Bereitstellungsoperationen\n * Generierung statischer Dateien\n * Senden von Build-Benachrichtigungen\n\n\nInstanzeigenschaften#\n\n\nname#\n\n * Typ: string\n * Schreibgeschützt: true\n\nDer Name des aktuellen Moduls, abgeleitet aus der Modulkonfiguration.\n\n\nvarName#\n\n * Typ: string\n * Schreibgeschützt: true\n\nEin gültiger JavaScript-Variablenname, der auf dem Modulnamen basiert.\n\n\nroot#\n\n * Typ: string\n * Schreibgeschützt: true\n\nDer absolute Pfad zum Projektstammverzeichnis. Wenn der konfigurierte root ein\nrelativer Pfad ist, wird er basierend auf dem aktuellen Arbeitsverzeichnis\naufgelöst.\n\n\nisProd#\n\n * Typ: boolean\n * Schreibgeschützt: true\n\nBestimmt, ob die aktuelle Umgebung eine Produktionsumgebung ist. Verwendet\nvorrangig die isProd-Konfigurationsoption, falls nicht konfiguriert, wird\nprocess.env.NODE_ENV verwendet.\n\n\nbasePath#\n\n * Typ: string\n * Schreibgeschützt: true\n * Wirft: NotReadyError - Wenn das Framework nicht initialisiert ist\n\nRuft den Basis-Pfad des Moduls ab, der mit einem Schrägstrich beginnt und endet.\nDas Rückgabeformat ist /${name}/, wobei der Name aus der Modulkonfiguration\nstammt.\n\n\nbasePathPlaceholder#\n\n * Typ: string\n * Schreibgeschützt: true\n\nRuft den Platzhalter für den dynamischen Basis-Pfad ab, der zur Laufzeit ersetzt\nwird. Kann durch Konfiguration deaktiviert werden.\n\n\nmiddleware#\n\n * Typ: Middleware\n * Schreibgeschützt: true\n\nRuft das Middleware für die Verarbeitung statischer Ressourcen ab. Bietet je\nnach Umgebung unterschiedliche Implementierungen:\n\n * Entwicklungsumgebung: Unterstützt Echtzeit-Kompilierung und Hot Reload\n * Produktionsumgebung: Unterstützt langfristiges Caching statischer Ressourcen\n\n\n\n\nrender#\n\n * Typ: (options?: RenderContextOptions) => Promise\n * Schreibgeschützt: true\n\nRuft die serverseitige Rendering-Funktion ab. Bietet je nach Umgebung\nunterschiedliche Implementierungen:\n\n * Entwicklungsumgebung: Unterstützt Hot Reload und Echtzeit-Vorschau\n * Produktionsumgebung: Bietet optimierte Rendering-Leistung\n\n\n\n\nCOMMAND#\n\n * Typ: typeof COMMAND\n * Schreibgeschützt: true\n\nRuft die Enumeration der Befehlstypen ab.\n\n\nmoduleConfig#\n\n * Typ: ParsedModuleConfig\n * Schreibgeschützt: true\n * Wirft: NotReadyError - Wenn das Framework nicht initialisiert ist\n\nRuft die vollständige Konfigurationsinformation des aktuellen Moduls ab,\neinschließlich Modulauflösungsregeln und Alias-Konfigurationen.\n\n\npackConfig#\n\n * Typ: ParsedPackConfig\n * Schreibgeschützt: true\n * Wirft: NotReadyError - Wenn das Framework nicht initialisiert ist\n\nRuft die Build-bezogenen Konfigurationen des aktuellen Moduls ab, einschließlich\nAusgabepfad und package.json-Verarbeitung.\n\n\nInstanzmethoden#\n\n\nconstructor()#\n\n * Parameter:\n   * options?: GezOptions - Framework-Konfigurationsoptionen\n * Rückgabewert: Gez\n\nErstellt eine Gez-Framework-Instanz.\n\n\n\n\ninit()#\n\n * Parameter: command: COMMAND\n * Rückgabewert: Promise\n * Wirft:\n   * Error: Bei wiederholter Initialisierung\n   * NotReadyError: Beim Zugriff auf eine nicht initialisierte Instanz\n\nInitialisiert die Gez-Framework-Instanz. Führt die folgenden\nKerninitialisierungsprozesse aus:\n\n 1. Projektkonfiguration analysieren (package.json, Modulkonfiguration,\n    Build-Konfiguration usw.)\n 2. Anwendungsinstanz erstellen (Entwicklungsumgebung oder Produktionsumgebung)\n 3. Entsprechende Lebenszyklusmethoden basierend auf dem Befehl ausführen\n\nHinweis\n * Bei wiederholter Initialisierung wird ein Fehler geworfen\n * Beim Zugriff auf eine nicht initialisierte Instanz wird NotReadyError\n   geworfen\n\n\n\n\ndestroy()#\n\n * Rückgabewert: Promise\n\nZerstört die Gez-Framework-Instanz und führt Ressourcenbereinigung und\nVerbindungsschließung durch. Wird hauptsächlich verwendet für:\n\n * Schließen des Entwicklungsservers\n * Bereinigung temporärer Dateien und Caches\n * Freigabe von Systemressourcen\n\n\n\n\nbuild()#\n\n * Rückgabewert: Promise\n\nFührt den Build-Prozess der Anwendung aus, einschließlich:\n\n * Kompilierung des Quellcodes\n * Generierung von Build-Artefakten für die Produktionsumgebung\n * Optimierung und Komprimierung des Codes\n * Generierung von Ressourcenlisten\n\nHinweis\n\nBeim Aufruf auf eine nicht initialisierte Framework-Instanz wird NotReadyError\ngeworfen\n\n\n\n\nserver()#\n\n * Rückgabewert: Promise\n * Wirft: NotReadyError - Wenn das Framework nicht initialisiert ist\n\nStartet den HTTP-Server und konfiguriert die Serverinstanz. Wird in den\nfolgenden Lebenszyklen aufgerufen:\n\n * Entwicklungsumgebung (dev): Startet den Entwicklungsserver und bietet Hot\n   Reload\n * Produktionsumgebung (start): Startet den Produktionsserver und bietet\n   Produktionsleistung\n\n\n\n\npostBuild()#\n\n * Rückgabewert: Promise\n\nFührt die Nachbearbeitungslogik nach dem Build aus, verwendet für:\n\n * Generierung statischer HTML-Dateien\n * Verarbeitung von Build-Artefakten\n * Ausführung von Bereitstellungsaufgaben\n * Senden von Build-Benachrichtigungen\n\n\n\n\nresolvePath#\n\nLöst Projektpfade auf und konvertiert relative Pfade in absolute Pfade.\n\n * Parameter:\n   \n   * projectPath: ProjectPath - Projektpfadtyp\n   * ...args: string[] - Pfadsegmente\n\n * Rückgabewert: string - Der aufgelöste absolute Pfad\n\n * Beispiel:\n\n\n\n\nwriteSync()#\n\nSchreibt Dateiinhalte synchron.\n\n * Parameter:\n   \n   * filepath: string - Der absolute Pfad zur Datei\n   * data: any - Die zu schreibenden Daten, können String, Buffer oder Objekt\n     sein\n\n * Rückgabewert: boolean - Gibt an, ob das Schreiben erfolgreich war\n\n * Beispiel:\n\n\n\n\nreadJsonSync()#\n\nLiest und analysiert eine JSON-Datei synchron.\n\n * Parameter:\n   \n   * filename: string - Der absolute Pfad zur JSON-Datei\n\n * Rückgabewert: any - Das analysierte JSON-Objekt\n\n * Ausnahmen: Wirft eine Ausnahme, wenn die Datei nicht existiert oder das\n   JSON-Format ungültig ist\n\n * Beispiel:\n\n\n\n\nreadJson()#\n\nLiest und analysiert eine JSON-Datei asynchron.\n\n * Parameter:\n   \n   * filename: string - Der absolute Pfad zur JSON-Datei\n\n * Rückgabewert: Promise - Das analysierte JSON-Objekt\n\n * Ausnahmen: Wirft eine Ausnahme, wenn die Datei nicht existiert oder das\n   JSON-Format ungültig ist\n\n * Beispiel:\n\n\n\n\ngetManifestList()#\n\nRuft die Liste der Build-Manifeste ab.\n\n * Parameter:\n   \n   * target: RuntimeTarget - Der Zielumgebungstyp\n     * 'client': Client-Umgebung\n     * 'server': Server-Umgebung\n\n * Rückgabewert: Promise - Eine schreibgeschützte Liste der Build-Manifeste\n\n * Ausnahmen: Wirft NotReadyError, wenn die Framework-Instanz nicht\n   initialisiert ist\n\nDiese Methode wird verwendet, um die Liste der Build-Manifeste für die\nangegebene Zielumgebung abzurufen und bietet folgende Funktion","routePath":"/de/api/core/gez","lang":"de","toc":[{"text":"Einführung","id":"einführung","depth":2,"charIndex":3},{"text":"Typdefinitionen","id":"typdefinitionen","depth":2,"charIndex":243},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":262},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":536},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":604},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":749},{"text":"COMMAND","id":"command","depth":3,"charIndex":898},{"text":"Instanzoptionen","id":"instanzoptionen","depth":2,"charIndex":1264},{"text":"root","id":"root","depth":4,"charIndex":1346},{"text":"isProd","id":"isprod","depth":4,"charIndex":1560},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":1718},{"text":"modules","id":"modules","depth":4,"charIndex":2004},{"text":"packs","id":"packs","depth":4,"charIndex":2198},{"text":"devApp","id":"devapp","depth":4,"charIndex":2337},{"text":"server","id":"server","depth":4,"charIndex":2562},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":2806},{"text":"Instanzeigenschaften","id":"instanzeigenschaften","depth":2,"charIndex":3118},{"text":"name","id":"name","depth":3,"charIndex":3142},{"text":"varName","id":"varname","depth":3,"charIndex":3263},{"text":"root","id":"root-1","depth":3,"charIndex":3388},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":3604},{"text":"basePath","id":"basepath","depth":3,"charIndex":3839},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":4128},{"text":"middleware","id":"middleware","depth":3,"charIndex":4326},{"text":"render","id":"render","depth":3,"charIndex":4671},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":5001},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":5105},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":5382},{"text":"Instanzmethoden","id":"instanzmethoden","depth":2,"charIndex":5642},{"text":"constructor()","id":"constructor","depth":3,"charIndex":5661},{"text":"init()","id":"init","depth":3,"charIndex":5815},{"text":"destroy()","id":"destroy","depth":3,"charIndex":6518},{"text":"build()","id":"build","depth":3,"charIndex":6810},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":7852},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":8116},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":8409},{"text":"readJson()","id":"readjson","depth":3,"charIndex":8723},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":9038}],"domain":"","frontmatter":{"titleSuffix":"Framework-Kernklassen-API-Referenz","description":"Detaillierte Dokumentation der Kernklassen-API des Gez-Frameworks, einschließlich Anwendungslebenszyklusverwaltung, statischer Ressourcenverarbeitung und serverseitiger Rendering-Fähigkeiten, um Entwicklern ein tieferes Verständnis der Kernfunktionen des Frameworks zu vermitteln.","head":[["meta",{"property":"keywords","content":"Gez, API, Lebenszyklusverwaltung, statische Ressourcen, serverseitiges Rendering, Rspack, Web-Anwendungsframework"}]]},"version":""},{"id":4,"title":"ManifestJson","content":"#\n\nmanifest.json ist eine vom Gez Framework während des Build-Prozesses generierte\nManifest-Datei, die Informationen über die Build-Artefakte eines Dienstes\nerfasst. Sie bietet eine einheitliche Schnittstelle zur Verwaltung von\nBuild-Artefakten, Exportdateien und Ressourcengrößenstatistiken.\n\n\n\n\nTypdefinitionen#\n\n\nManifestJson#\n\n\n\nname#\n\n * Typ: string\n\nDer Name des Dienstes, stammt aus der GezOptions.name Konfiguration.\n\nexports#\n\n * Typ: Record\n\nDie Zuordnung der exportierten Dateien, wobei der Schlüssel der Pfad der\nQuelldatei und der Wert der Pfad der gebauten Datei ist.\n\nbuildFiles#\n\n * Typ: string[]\n\nDie vollständige Liste der Build-Artefakte, einschließlich aller generierten\nDateipfade.\n\nchunks#\n\n * Typ: Record\n\nDie Zuordnung zwischen Quelldateien und kompilierten Artefakten, wobei der\nSchlüssel der Pfad der Quelldatei und der Wert die Kompilierungsinformationen\nsind.\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * Typ: string\n\nDer Pfad der kompilierten JS-Datei der aktuellen Quelldatei.\n\ncss#\n\n * Typ: string[]\n\nDie Liste der Pfade der mit der aktuellen Quelldatei verknüpften CSS-Dateien.\n\nresources#\n\n * Typ: string[]\n\nDie Liste der Pfade der mit der aktuellen Quelldatei verknüpften\nRessourcendateien.\n\nsizes#\n\n * Typ: ManifestJsonChunkSizes\n\nStatistische Informationen über die Größe der Build-Artefakte.\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * Typ: number\n\nDie Größe der JS-Datei in Bytes.\n\ncss#\n\n * Typ: number\n\nDie Größe der CSS-Datei in Bytes.\n\nresource#\n\n * Typ: number\n\nDie Größe der Ressourcendatei in Bytes.\n\n","routePath":"/de/api/core/manifest-json","lang":"de","toc":[{"text":"Typdefinitionen","id":"typdefinitionen","depth":2,"charIndex":296},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":332},{"text":"exports","id":"exports","depth":4,"charIndex":425},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":582},{"text":"chunks","id":"chunks","depth":4,"charIndex":703},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":889},{"text":"js","id":"js","depth":4,"charIndex":912},{"text":"css","id":"css","depth":4,"charIndex":995},{"text":"resources","id":"resources","depth":4,"charIndex":1098},{"text":"sizes","id":"sizes","depth":4,"charIndex":1213},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":1318},{"text":"js","id":"js-1","depth":4,"charIndex":1345},{"text":"css","id":"css-1","depth":4,"charIndex":1400},{"text":"resource","id":"resource","depth":4,"charIndex":1457}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Build Manifest Dateireferenz","description":"Detaillierte Beschreibung der Struktur der Build-Manifest-Datei (manifest.json) des Gez Frameworks, einschließlich Build-Artefaktverwaltung, Exportdateizuordnung und Ressourcenstatistik, um Entwicklern das Verständnis und die Nutzung des Build-Systems zu erleichtern.","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, Build-Manifest, Ressourcenverwaltung, Build-Artefakte, Dateizuordnung, API"}]]},"version":""},{"id":5,"title":"ModuleConfig","content":"#\n\nModuleConfig bietet die Modulkonfigurationsfunktionalität des Gez-Frameworks, um\nImport- und Exportregeln für Module, Alias-Konfigurationen und externe\nAbhängigkeiten zu definieren.\n\n\nTypdefinitionen#\n\n\nPathType#\n\n * Typdefinition:\n\n\n\nEnumeration der Modulpfadtypen:\n\n * npm: Steht für Abhängigkeiten in node_modules\n * root: Steht für Dateien im Projektstammverzeichnis\n\n\nModuleConfig#\n\n * Typdefinition:\n\n\n\nSchnittstelle für die Modulkonfiguration, verwendet zur Definition von Export-,\nImport- und externen Abhängigkeitskonfigurationen für Dienste.\n\nexports#\n\nListe der Exportkonfigurationen, die spezifische Codeeinheiten (wie Komponenten,\nUtility-Funktionen usw.) im ESM-Format nach außen verfügbar machen.\n\nUnterstützt zwei Typen:\n\n * root:*: Exportiert Quellcodedateien, z.B.: 'root:src/components/button.vue'\n * npm:*: Exportiert Drittanbieterabhängigkeiten, z.B.: 'npm:vue'\n\nimports#\n\nImportkonfigurationszuordnung, konfiguriert die zu importierenden Remote-Module\nund ihre lokalen Pfade.\n\nDie Konfiguration variiert je nach Installationsmethode:\n\n * Quellcodeinstallation (Workspace, Git): Muss auf das dist-Verzeichnis\n   verweisen\n * Paketinstallation (Link, statischer Server, privater Mirror, File): Verweist\n   direkt auf das Paketverzeichnis\n\nexternals#\n\nZuordnung externer Abhängigkeiten, konfiguriert die zu verwendenden externen\nAbhängigkeiten, typischerweise Abhängigkeiten aus Remote-Modulen.\n\nBeispiel:\n\n\n\n\nParsedModuleConfig#\n\n * Typdefinition:\n\n\n\nParsed Module Configuration, die die ursprüngliche Modulkonfiguration in ein\nstandardisiertes internes Format umwandelt:\n\nname#\n\nName des aktuellen Dienstes\n\n * Wird zur Identifizierung des Moduls und zur Generierung von Importpfaden\n   verwendet\n\nroot#\n\nStammverzeichnis des aktuellen Dienstes\n\n * Wird zur Auflösung relativer Pfade und zur Speicherung von Build-Artefakten\n   verwendet\n\nexports#\n\nListe der Exportkonfigurationen\n\n * name: Ursprünglicher Exportpfad, z.B.: 'npm:vue' oder 'root:src/components'\n * type: Pfadtyp (npm oder root)\n * importName: Importname, Format: '${serviceName}/${type}/${path}'\n * exportName: Exportpfad, relativ zum Dienststammverzeichnis\n * exportPath: Tatsächlicher Dateipfad\n * externalName: Name der externen Abhängigkeit, wird als Kennung für den Import\n   dieses Moduls durch andere Dienste verwendet\n\nimports#\n\nListe der Importkonfigurationen\n\n * name: Name des externen Dienstes\n * localPath: Lokaler Speicherpfad, wird zur Speicherung der Build-Artefakte des\n   externen Moduls verwendet\n\nexternals#\n\nZuordnung externer Abhängigkeiten\n\n * Ordnet den Importpfad des Moduls dem tatsächlichen Modulpfad zu\n * match: Regulärer Ausdruck zum Abgleichen von Importanweisungen\n * import: Tatsächlicher Modulpfad\n\n","routePath":"/de/api/core/module-config","lang":"de","toc":[{"text":"Typdefinitionen","id":"typdefinitionen","depth":2,"charIndex":186},{"text":"PathType","id":"pathtype","depth":3,"charIndex":205},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":555},{"text":"imports","id":"imports","depth":4,"charIndex":886},{"text":"externals","id":"externals","depth":4,"charIndex":1261},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":1431},{"text":"name","id":"name","depth":4,"charIndex":1595},{"text":"root","id":"root","depth":4,"charIndex":1721},{"text":"exports","id":"exports-1","depth":4,"charIndex":1862},{"text":"imports","id":"imports-1","depth":4,"charIndex":2316},{"text":"externals","id":"externals-1","depth":4,"charIndex":2506}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Modulkonfiguration API-Referenz","description":"Detaillierte Beschreibung der ModuleConfig-Konfigurationsschnittstelle des Gez-Frameworks, einschließlich Modulimport- und Exportregeln, Alias-Konfiguration und externer Abhängigkeitsverwaltung, um Entwicklern ein tieferes Verständnis des modularen Systems des Frameworks zu vermitteln.","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, Modulkonfiguration, Modulimport und -export, Externe Abhängigkeiten, Alias-Konfiguration, Abhängigkeitsverwaltung, Webanwendungsframework"}]]},"version":""},{"id":6,"title":"PackConfig","content":"#\n\nPackConfig ist eine Schnittstelle zur Konfiguration der Paketverpackung, die\nverwendet wird, um die Build-Artefakte eines Dienstes in ein standardmäßiges npm\n.tgz-Format zu verpacken.\n\n * Standardisierung: Verwendung des standardmäßigen npm .tgz-Verpackungsformats\n * Vollständigkeit: Enthält alle notwendigen Dateien wie Modulquellcode,\n   Typdeklarationen und Konfigurationsdateien\n * Kompatibilität: Vollständige Kompatibilität mit dem npm-Ökosystem und\n   Unterstützung des standardmäßigen Paketmanagement-Workflows\n\n\nTypdefinition#\n\n\n\n\nPackConfig#\n\nenable#\n\nAktiviert die Verpackungsfunktion. Wenn aktiviert, werden die Build-Artefakte in\nein standardmäßiges npm .tgz-Format verpackt.\n\n * Typ: boolean\n * Standardwert: false\n\noutputs#\n\nGibt den Ausgabepfad der Paketdatei an. Unterstützt folgende\nKonfigurationsmöglichkeiten:\n\n * string: Einzelner Ausgabepfad, z.B. 'dist/versions/my-app.tgz'\n * string[]: Mehrere Ausgabepfade, um gleichzeitig mehrere Versionen zu\n   generieren\n * boolean: Bei true wird der Standardpfad 'dist/client/versions/latest.tgz'\n   verwendet\n\npackageJson#\n\nEine Callback-Funktion zur Anpassung des package.json-Inhalts. Wird vor der\nVerpackung aufgerufen, um den Inhalt von package.json anzupassen.\n\n * Parameter:\n   * gez: Gez - Gez-Instanz\n   * pkg: any - Originaler package.json-Inhalt\n * Rückgabewert: Promise - Angepasster package.json-Inhalt\n\nHäufige Anwendungsfälle:\n\n * Ändern des Paketnamens und der Versionsnummer\n * Hinzufügen oder Aktualisieren von Abhängigkeiten\n * Hinzufügen benutzerdefinierter Felder\n * Konfigurieren von Veröffentlichungsinformationen\n\nBeispiel:\n\n\n\nonBefore#\n\nEine Callback-Funktion für Vorbereitungen vor der Verpackung.\n\n * Parameter:\n   * gez: Gez - Gez-Instanz\n   * pkg: Record - package.json-Inhalt\n * Rückgabewert: Promise\n\nHäufige Anwendungsfälle:\n\n * Hinzufügen zusätzlicher Dateien (README, LICENSE usw.)\n * Ausführen von Tests oder Build-Validierungen\n * Generieren von Dokumentation oder Metadaten\n * Bereinigen temporärer Dateien\n\nBeispiel:\n\n\n\nonAfter#\n\nEine Callback-Funktion für die Nachbearbeitung nach der Verpackung. Wird nach\nder Generierung der .tgz-Datei aufgerufen, um die verpackten Artefakte zu\nverarbeiten.\n\n * Parameter:\n   * gez: Gez - Gez-Instanz\n   * pkg: Record - package.json-Inhalt\n   * file: Buffer - Inhalt der verpackten Datei\n * Rückgabewert: Promise\n\nHäufige Anwendungsfälle:\n\n * Veröffentlichen im npm-Repository (öffentlich oder privat)\n * Hochladen auf einen statischen Ressourcenserver\n * Versionsverwaltung durchführen\n * CI/CD-Prozess auslösen\n\nBeispiel:\n\n\n\n\nVerwendungsbeispiel#\n\n","routePath":"/de/api/core/pack-config","lang":"de","toc":[{"text":"Typdefinition","id":"typdefinition","depth":2,"charIndex":524},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":556},{"text":"outputs","id":"outputs","depth":4,"charIndex":733},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":1077},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":1617},{"text":"onAfter","id":"onafter","depth":4,"charIndex":2024},{"text":"Verwendungsbeispiel","id":"verwendungsbeispiel","depth":2,"charIndex":2569}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Pack-Konfigurations-API-Referenz","description":"Detaillierte Beschreibung der PackConfig-Konfigurationsschnittstelle des Gez-Frameworks, einschließlich Paketverpackungsregeln, Ausgabekonfiguration und Lifecycle-Hooks, um Entwicklern bei der Implementierung standardisierter Build-Prozesse zu helfen.","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, Paketverpackung, Build-Konfiguration, Lifecycle-Hooks, Verpackungskonfiguration, Web-Anwendungsframework"}]]},"version":""},{"id":7,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/de/api/core/render-context","lang":"de","toc":[{"text":"Typdefinitionen","id":"typdefinitionen","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"Instanzoptionen","id":"instanzoptionen","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"Instanzeigenschaften","id":"instanzeigenschaften","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"Instanzmethoden","id":"instanzmethoden","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1},{"text":"importmap()","id":"importmap","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Render Context API Referenz","description":"Detaillierte Beschreibung der RenderContext-Kernklasse des Gez-Frameworks, einschließlich Rendering-Steuerung, Ressourcenverwaltung, Zustandssynchronisierung und Routing-Kontrolle, um Entwicklern bei der Implementierung effizienter serverseitiger Rendering-Lösungen zu helfen.","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, Serverseitiges Rendering, Rendering-Kontext, Zustandssynchronisierung, Ressourcenverwaltung, Webanwendungsframework"}]]},"version":""},{"id":8,"title":"Von der Komponentenfreigabe zur nativen Modularität: Der Entwicklungsweg des Gez-Mikrofrontend-Frameworks","content":"Von der Komponentenfreigabe zur nativen Modularität: Der Entwicklungsweg des\nGez-Mikrofrontend-Frameworks#\n\n\nProjektkontext#\n\nIn den letzten Jahren hat die Mikrofrontend-Architektur ständig nach dem\nrichtigen Weg gesucht. Doch was wir sahen, waren verschiedene komplexe\ntechnische Lösungen, die mit mehreren Schichten von Verpackungen und künstlicher\nIsolation eine ideale Mikrofrontend-Welt simulierten. Diese Lösungen brachten\nerhebliche Leistungseinbußen mit sich, machten einfache Entwicklungen komplex\nund standardisierte Prozesse undurchsichtig.\n\n\nGrenzen traditioneller Lösungen#\n\nBei der praktischen Anwendung der Mikrofrontend-Architektur haben wir die\nzahlreichen Einschränkungen traditioneller Lösungen deutlich gespürt:\n\n * Leistungseinbußen: Laufzeitabhängigkeiten, JS-Sandbox-Proxies – jede\n   Operation verbraucht wertvolle Leistung\n * Fragile Isolation: Künstlich geschaffene Sandbox-Umgebungen können niemals\n   die native Isolationsfähigkeit des Browsers erreichen\n * Komplexität beim Build: Um Abhängigkeiten zu handhaben, mussten Build-Tools\n   angepasst werden, was einfache Projekte schwer wartbar machte\n * Angepasste Regeln: Spezielle Bereitstellungsstrategien, Laufzeitverarbeitung\n   – jeder Schritt entfernte sich von den Standardprozessen der modernen\n   Entwicklung\n * Ökosystembeschränkungen: Framework-Kopplung, angepasste APIs – die\n   Technologieauswahl wurde an ein bestimmtes Ökosystem gebunden\n\nDiese Probleme traten besonders deutlich in einem unserer Unternehmensprojekte\nim Jahr 2019 hervor. Damals wurde ein großes Produkt in mehr als zehn\nunabhängige Geschäftssubsysteme aufgeteilt, die eine Reihe von Basis- und\nGeschäftskomponenten teilen mussten. Die ursprünglich verwendete Lösung zur\nKomponentenfreigabe basierend auf npm-Paketen zeigte in der Praxis ernsthafte\nWartungseffizienzprobleme: Wenn eine freigegebene Komponente aktualisiert wurde,\nmussten alle davon abhängigen Subsysteme einen vollständigen Build- und\nBereitstellungsprozess durchlaufen.\n\n\nTechnische Entwicklung#\n\n\nv1.0: Erkundung von Remote-Komponenten#\n\nUm die Effizienzprobleme bei der Komponentenfreigabe zu lösen, führte Gez v1.0\neinen RemoteView-Komponentenmechanismus basierend auf dem HTTP-Protokoll ein.\nDiese Lösung ermöglichte die dynamische Anforderung von Code zur Laufzeit und\nlöste das Problem zu langer Build-Abhängigkeitsketten. Aufgrund des Mangels an\nstandardisierten Laufzeitkommunikationsmechanismen gab es jedoch weiterhin\nEffizienzengpässe bei der Zustandssynchronisation und Ereignisübertragung\nzwischen den Diensten.\n\n\nv2.0: Versuch mit Module Federation#\n\nIn Version v2.0 haben wir die Module Federation-Technologie von Webpack 5.0\nverwendet. Diese Technologie verbesserte die Zusammenarbeit zwischen den\nDiensten durch einen einheitlichen Modullademechanismus und Laufzeitcontainer\nerheblich. In der großflächigen Praxis brachte die geschlossene Implementierung\nvon Module Federation jedoch neue Herausforderungen mit sich: Es war schwierig,\neine präzise Abhängigkeitsversionsverwaltung zu erreichen, insbesondere bei der\nVereinheitlichung gemeinsamer Abhängigkeiten mehrerer Dienste, was häufig zu\nVersionskonflikten und Laufzeitfehlern führte.\n\n\nDie neue Ära von ESM#\n\nBei der Planung von Version v3.0 haben wir die Entwicklungstrends im\nFrontend-Ökosystem genau beobachtet und festgestellt, dass Fortschritte in den\nnativen Browserfähigkeiten neue Möglichkeiten für die Mikrofrontend-Architektur\neröffnen:\n\n\nStandardisiertes Modulsystem#\n\nMit der umfassenden Unterstützung für ES Modules durch die wichtigsten Browser\nund der Reifung der Import Maps-Spezifikation hat die Frontend-Entwicklung ein\nechtes modulares Zeitalter erreicht. Laut den Statistiken von Can I Use liegt\ndie native Unterstützung für ESM in den wichtigsten Browsern (Chrome >= 89, Edge\n>= 89, Firefox >= 108, Safari >= 16.4) bei 93,5 %, was uns folgende Vorteile\nbietet:\n\n * Standardisiertes Abhängigkeitsmanagement: Import Maps bieten die Fähigkeit,\n   Modulabhängigkeiten auf Browserebene aufzulösen, ohne komplexe\n   Laufzeiteinschleusungen\n * Optimierung der Ressourcenladung: Der native Modulcache-Mechanismus des\n   Browsers verbessert die Ressourcenladeeffizienz erheblich\n * Vereinfachung des Build-Prozesses: Der auf ESM basierende Entwicklungsmodus\n   macht die Build-Prozesse für Entwicklungs- und Produktionsumgebungen\n   konsistenter\n\nGleichzeitig können wir durch die Unterstützung des Kompatibilitätsmodus (Chrome\n>= 87, Edge >= 88, Firefox >= 78, Safari >= 14) die Browserabdeckung auf 96,81 %\nerhöhen, was es uns ermöglicht, hohe Leistung beizubehalten, ohne die\nUnterstützung für ältere Browser zu opfern.\n\n\nDurchbrüche bei Leistung und Isolation#\n\nDas native Modulsystem bringt nicht nur Standardisierung, sondern auch eine\nqualitative Verbesserung von Leistung und Isolation:\n\n * Keine Laufzeitkosten: Keine JavaScript-Sandbox-Proxies und\n   Laufzeiteinschleusungen mehr wie in traditionellen Mikrofrontend-Lösungen\n * Zuverlässige Isolationsmechanismen: Die strikten Modulbereiche von ESM bieten\n   von Natur aus die zuverlässigste Isolationsfähigkeit\n * Präzises Abhängigkeitsmanagement: Statische Importanalysen machen\n   Abhängigkeitsbeziehungen klarer und die Versionskontrolle präziser\n\n\nAuswahl der Build-Tools#\n\nBei der Umsetzung der technischen Lösung war die Auswahl der Build-Tools ein\nentscheidender Punkt. Nach fast einem Jahr technischer Recherche und Praxis hat\nsich unsere Wahl wie folgt entwickelt:\n\n 1. Erkundung von Vite\n    \n    * Vorteile: Auf ESM basierender Entwicklungsserver, bietet ein\n      hervorragendes Entwicklungserlebnis\n    * Herausforderungen: Unterschiede zwischen Entwicklungs- und\n      Produktions-Builds führten zu gewissen Unsicherheiten\n\n 2. Rspack etabliert\n    \n    * Leistungsvorteile: Hochleistungs-Kompilierung basierend auf Rust,\n      verbesserte die Build-Geschwindigkeit erheblich\n    * Ökosystemunterstützung: Hohe Kompatibilität mit dem Webpack-Ökosystem,\n      reduzierte Migrationskosten\n    * ESM-Unterstützung: Durch die Praxis des Rslib-Projekts wurde die\n      Zuverlässigkeit bei ESM-Builds bestätigt\n\nDiese Entscheidung ermöglichte es uns, bei gleichbleibendem Entwicklungserlebnis\neine stabilere Produktionsumgebung zu erhalten. Basierend auf der Kombination\nvon ESM und Rspack haben wir schließlich eine leistungsstarke, wenig invasive\nMikrofrontend-Lösung entwickelt.\n\n\nZukunftsaussichten#\n\nIn den zukünftigen Entwicklungsplänen wird das Gez-Framework sich auf die\nfolgenden drei Richtungen konzentrieren:\n\n\nTiefgehende Optimierung von Import Maps#\n\n * Dynamisches Abhängigkeitsmanagement: Implementierung einer intelligenten\n   Laufzeitabhängigkeitsversionsverwaltung zur Lösung von\n   Abhängigkeitskonflikten zwischen mehreren Anwendungen\n * Vorlade-Strategien: Intelligentes Vorladen basierend auf Routing-Analysen zur\n   Verbesserung der Ressourcenladeeffizienz\n * Build-Optimierung: Automatische Generierung optimaler Import\n   Maps-Konfigurationen zur Reduzierung der manuellen Konfigurationskosten für\n   Entwickler\n\n\nFramework-unabhängiges Routing#\n\n * Einheitliche Routing-Abstraktion: Entwurf einer Framework-unabhängigen\n   Routing-Schnittstelle zur Unterstützung von Vue, React und anderen gängigen\n   Frameworks\n * Mikroanwendungs-Routing: Implementierung von Routing-Interaktionen zwischen\n   Anwendungen zur Konsistenz von URL und Anwendungszustand\n * Routing-Middleware: Bereitstellung eines erweiterbaren Middleware-Mechanismus\n   zur Unterstützung von Berechtigungskontrolle, Seitenübergängen und anderen\n   Funktionen\n\n\nBest Practices für Framework-übergreifende Kommunikation#\n\n * Beispielanwendungen: Bereitstellung vollständiger Beispiele für\n   Framework-übergreifende Kommunikation, die Vue, React, Preact und andere\n   gängige Frameworks abdecken\n * Status-Synchronisation: Leichtgewichtige Statusfreigabelösung basierend auf\n   ESM\n * Event-Bus: Standardisierter Ereigniskommunikationsmechanismus zur\n   Unterstützung entkoppelter Kommunikation zwischen Anwendungen\n\nDurch diese Optimierungen und Erweiterungen streben wir an, Gez zu einer noch\nvollständigeren und benutzerfreundlicheren Mikrofrontend-Lösung zu machen, die\nEntwicklern ein besseres Entwicklungserlebnis und höhere Entwicklungseffizienz\nbietet.","routePath":"/de/blog/birth-of-gez","lang":"de","toc":[{"text":"Projektkontext","id":"projektkontext","depth":2,"charIndex":108},{"text":"Grenzen traditioneller Lösungen","id":"grenzen-traditioneller-lösungen","depth":3,"charIndex":553},{"text":"Technische Entwicklung","id":"technische-entwicklung","depth":2,"charIndex":1998},{"text":"v1.0: Erkundung von Remote-Komponenten","id":"v10-erkundung-von-remote-komponenten","depth":3,"charIndex":2024},{"text":"v2.0: Versuch mit Module Federation","id":"v20-versuch-mit-module-federation","depth":3,"charIndex":2553},{"text":"Die neue Ära von ESM","id":"die-neue-ära-von-esm","depth":2,"charIndex":3184},{"text":"Standardisiertes Modulsystem","id":"standardisiertes-modulsystem","depth":3,"charIndex":3447},{"text":"Durchbrüche bei Leistung und Isolation","id":"durchbrüche-bei-leistung-und-isolation","depth":3,"charIndex":4635},{"text":"Auswahl der Build-Tools","id":"auswahl-der-build-tools","depth":3,"charIndex":5223},{"text":"Zukunftsaussichten","id":"zukunftsaussichten","depth":2,"charIndex":6363},{"text":"Tiefgehende Optimierung von Import Maps","id":"tiefgehende-optimierung-von-import-maps","depth":3,"charIndex":6501},{"text":"Framework-unabhängiges Routing","id":"framework-unabhängiges-routing","depth":3,"charIndex":7018},{"text":"Best Practices für Framework-übergreifende Kommunikation","id":"best-practices-für-framework-übergreifende-kommunikation","depth":3,"charIndex":7532}],"domain":"","frontmatter":{"titleSuffix":"Vom Mikrofrontend-Dilemma zur ESM-Innovation: Der Entwicklungsweg des Gez-Frameworks","description":"Eine tiefgehende Betrachtung des Gez-Frameworks, von den Herausforderungen traditioneller Mikrofrontend-Architekturen bis hin zu innovativen Durchbrüchen basierend auf ESM. Es werden technische Praxiserfahrungen in den Bereichen Leistungsoptimierung, Abhängigkeitsmanagement und Auswahl von Build-Tools geteilt.","head":[["meta",{"property":"keywords","content":"Gez, Mikrofrontend-Framework, ESM, Import Maps, Rspack, Module Federation, Abhängigkeitsmanagement, Leistungsoptimierung, technische Entwicklung, Server-Side Rendering"}]],"sidebar":false},"version":""},{"id":9,"title":"Team Blog","content":"#\n\nWillkommen im technischen Blog des Gez-Teams! Hier teilen wir unsere Erfahrungen\naus der Framework-Entwicklung, technische Innovationen und Best Practices.\n\n\nAktuelle Beiträge#\n\n * 2025-02-25 Von der Komponentenfreigabe zur nativen Modularisierung: Der\n   Entwicklungsweg des Gez Micro-Frontend-Frameworks\n   \n   > Erkunden Sie die Entwicklungsgeschichte des Gez-Frameworks von der\n   > traditionellen Komponentenfreigabe zur nativen Modularisierung basierend\n   > auf ESM. Teilen Sie technische Praxiserfahrungen in den Bereichen\n   > Leistungsoptimierung, Abhängigkeitsmanagement und Auswahl von Build-Tools.","routePath":"/de/blog/","lang":"de","toc":[{"text":"Aktuelle Beiträge","id":"aktuelle-beiträge","depth":2,"charIndex":160}],"domain":"","frontmatter":{"titleSuffix":"Gez Team Blog","description":"Technischer Blog des Gez-Teams, in dem wir Erfahrungen in der Framework-Entwicklung, Best Practices und technische Innovationen teilen.","head":[["meta",{"property":"keywords","content":"Gez, Team Blog, Technische Beiträge, Best Practices, Entwicklungserfahrung"}]],"sidebar":false},"version":""},{"id":10,"title":"Pfadalias","content":"#\n\nPfadalias (Path Alias) ist ein Mechanismus zur Zuordnung von Modulimportpfaden,\nder es Entwicklern ermöglicht, kurze, semantische Bezeichner anstelle\nvollständiger Modulpfade zu verwenden. Im Gez-Framework bietet der\nPfadaliasmechanismus folgende Vorteile:\n\n * Vereinfachung von Importpfaden: Verwendung semantischer Aliase anstelle\n   langer relativer Pfade, um die Lesbarkeit des Codes zu verbessern\n * Vermeidung von tief verschachtelten Pfaden: Beseitigung von\n   Wartungsschwierigkeiten durch mehrstufige Verzeichnisreferenzen (z.B.\n   ../../../../)\n * Typsicherheit: Vollständige Integration in das TypeScript-Typsystem, bietet\n   Code-Vervollständigung und Typprüfung\n * Modulauflösungsoptimierung: Verbesserung der Modulauflösungsleistung durch\n   vordefinierte Pfadzuordnungen\n\n\nStandard-Aliasmechanismus#\n\nGez verwendet einen automatischen Aliasmechanismus basierend auf dem Dienstnamen\n(Service Name). Dieser konfigurationsfreie Ansatz bietet folgende Merkmale:\n\n * Automatische Konfiguration: Basierend auf dem name-Feld in der package.json\n   wird automatisch ein Alias generiert, ohne manuelle Konfiguration\n * Einheitliche Standards: Sicherstellung, dass alle Dienstmodule einheitlichen\n   Namens- und Referenzstandards folgen\n * Typunterstützung: In Kombination mit dem Befehl npm run build:dts werden\n   automatisch Typdeklarationsdateien generiert, um typsichere Verweise zwischen\n   Diensten zu ermöglichen\n * Vorhersagbarkeit: Der Modulreferenzpfad kann anhand des Dienstnamens\n   abgeleitet werden, was die Wartungskosten senkt\n\n\nKonfigurationsanleitung#\n\n\npackage.json Konfiguration#\n\nIn der package.json wird der Dienstname über das name-Feld definiert. Dieser\nName dient als Standardaliaspräfix für den Dienst:\n\n\n\n\ntsconfig.json Konfiguration#\n\nDamit TypeScript die Aliaspfade korrekt auflösen kann, muss die paths-Zuordnung\nin der tsconfig.json konfiguriert werden:\n\n\n\n\nAnwendungsbeispiele#\n\n\nImport von Dienst-internen Modulen#\n\n\n\n\nImport von Modulen anderer Dienste#\n\n\n\nBest Practices\n * Bevorzugen Sie Aliaspfade gegenüber relativen Pfaden\n * Halten Sie Aliaspfade semantisch und konsistent\n * Vermeiden Sie zu viele Verzeichnisebenen in Aliaspfaden\n\n\n\n\nImport über Dienste hinweg#\n\nWenn Modulverknüpfungen (Module Links) konfiguriert sind, können Module anderer\nDienste auf die gleiche Weise importiert werden:\n\n\n\n\nBenutzerdefinierte Aliase#\n\nFür Drittanbieterpakete oder spezielle Szenarien können benutzerdefinierte\nAliase über die Gez-Konfigurationsdatei festgelegt werden:\n\n\n\nHinweise\n 1. Für Geschäftsmodule wird empfohlen, immer den Standard-Aliasmechanismus zu\n    verwenden, um die Konsistenz des Projekts zu gewährleisten\n 2. Benutzerdefinierte Aliase sollten hauptsächlich für spezielle Anforderungen\n    von Drittanbieterpaketen oder zur Optimierung der Entwicklungserfahrung\n    verwendet werden\n 3. Übermäßige Verwendung von benutzerdefinierten Aliasen kann die Wartbarkeit\n    des Codes und die Build-Optimierung beeinträchtigen","routePath":"/de/guide/essentials/alias","lang":"de","toc":[{"text":"Standard-Aliasmechanismus","id":"standard-aliasmechanismus","depth":2,"charIndex":790},{"text":"Konfigurationsanleitung","id":"konfigurationsanleitung","depth":2,"charIndex":1553},{"text":"package.json Konfiguration","id":"packagejson-konfiguration","depth":3,"charIndex":1580},{"text":"tsconfig.json Konfiguration","id":"tsconfigjson-konfiguration","depth":3,"charIndex":1741},{"text":"Anwendungsbeispiele","id":"anwendungsbeispiele","depth":2,"charIndex":1897},{"text":"Import von Dienst-internen Modulen","id":"import-von-dienst-internen-modulen","depth":3,"charIndex":1920},{"text":"Import von Modulen anderer Dienste","id":"import-von-modulen-anderer-dienste","depth":3,"charIndex":1960},{"text":"Import über Dienste hinweg","id":"import-über-dienste-hinweg","depth":3,"charIndex":2184},{"text":"Benutzerdefinierte Aliase","id":"benutzerdefinierte-aliase","depth":3,"charIndex":2346}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework - Leitfaden zur Pfadaliaskonfiguration","description":"Detaillierte Erläuterung des Pfadaliasmechanismus im Gez-Framework, einschließlich der Vereinfachung von Importpfaden, Vermeidung von tief verschachtelten Pfaden, Typsicherheit und Modulauflösungsoptimierung, um die Wartbarkeit des Codes zu verbessern.","head":[["meta",{"property":"keywords","content":"Gez, Pfadalias, Path Alias, TypeScript, Modulimport, Pfadzuordnung, Code-Wartbarkeit"}]]},"version":""},{"id":11,"title":"Basis-Pfad","content":"#\n\nDer Basis-Pfad (Base Path) bezieht sich auf das Präfix des Zugriffspfads für\nstatische Ressourcen (wie JavaScript, CSS, Bilder usw.) in einer Anwendung. In\nGez ist die korrekte Konfiguration des Basis-Pfads für folgende Szenarien\nentscheidend:\n\n * Multi-Umgebungs-Bereitstellung: Unterstützung des Ressourcenzugriffs in\n   verschiedenen Umgebungen wie Entwicklung, Test und Produktion\n * Multi-Regionen-Bereitstellung: Anpassung an die Bereitstellungsanforderungen\n   in verschiedenen Regionen oder Ländern\n * CDN-Verteilung: Globale Verteilung und Beschleunigung statischer Ressourcen\n\n\nStandardpfad-Mechanismus#\n\nGez verwendet einen automatischen Pfadgenerierungsmechanismus basierend auf dem\nDienstnamen. Standardmäßig liest das Framework das name-Feld in der package.json\ndes Projekts, um den Basis-Pfad für statische Ressourcen zu generieren:\n/your-app-name/.\n\n\n\nDieses Design, das Konvention über Konfiguration stellt, bietet folgende\nVorteile:\n\n * Konsistenz: Sicherstellung, dass alle statischen Ressourcen einen\n   einheitlichen Zugriffspfad verwenden\n * Vorhersagbarkeit: Der Ressourcenzugriffspfad kann anhand des name-Felds in\n   der package.json abgeleitet werden\n * Wartbarkeit: Keine zusätzliche Konfiguration erforderlich, was die\n   Wartungskosten senkt\n\n\nDynamische Pfadkonfiguration#\n\nIn realen Projekten müssen wir oft denselben Code in verschiedenen Umgebungen\noder Regionen bereitstellen. Gez bietet Unterstützung für dynamische\nBasis-Pfade, sodass Anwendungen sich an verschiedene Bereitstellungsszenarien\nanpassen können.\n\n\nAnwendungsfälle#\n\nBereitstellung in Unterverzeichnissen#\n\n\n\nBereitstellung unter separaten Domains#\n\n\n\n\nKonfigurationsmethode#\n\nÜber den base-Parameter der gez.render()-Methode können Sie den Basis-Pfad\nbasierend auf dem Anfragekontext dynamisch festlegen:\n\n","routePath":"/de/guide/essentials/base-path","lang":"de","toc":[{"text":"Standardpfad-Mechanismus","id":"standardpfad-mechanismus","depth":2,"charIndex":590},{"text":"Dynamische Pfadkonfiguration","id":"dynamische-pfadkonfiguration","depth":2,"charIndex":1275},{"text":"Anwendungsfälle","id":"anwendungsfälle","depth":3,"charIndex":1550},{"text":"Bereitstellung in Unterverzeichnissen","id":"bereitstellung-in-unterverzeichnissen","depth":4,"charIndex":1568},{"text":"Bereitstellung unter separaten Domains","id":"bereitstellung-unter-separaten-domains","depth":4,"charIndex":1610},{"text":"Konfigurationsmethode","id":"konfigurationsmethode","depth":3,"charIndex":1654}],"domain":"","frontmatter":{"titleSuffix":"Leitfaden zur Konfiguration statischer Ressourcenpfade im Gez-Framework","description":"Detaillierte Anleitung zur Konfiguration von Basis-Pfaden im Gez-Framework, einschließlich Multi-Umgebungs-Bereitstellung, CDN-Verteilung und Ressourcenzugriffspfade, um Entwicklern bei der flexiblen Verwaltung statischer Ressourcen zu helfen.","head":[["meta",{"property":"keywords","content":"Gez, Basis-Pfad, Base Path, CDN, statische Ressourcen, Multi-Umgebungs-Bereitstellung, Ressourcenverwaltung"}]]},"version":""},{"id":12,"title":"Client-Side Rendering","content":"\n${rc.importmap()} // Import-Mapping ${rc.moduleEntry()} // Einstiegsmodul\n${rc.modulePreload()} // Modul vorladen","routePath":"/de/guide/essentials/csr","lang":"de","toc":[{"text":"Anwendungsfälle","id":"anwendungsfälle","depth":2,"charIndex":-1},{"text":"Konfigurationsbeschreibung","id":"konfigurationsbeschreibung","depth":2,"charIndex":-1},{"text":"HTML-Vorlagenkonfiguration","id":"html-vorlagenkonfiguration","depth":3,"charIndex":-1},{"text":"Statische HTML-Generierung","id":"statische-html-generierung","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Client-Side Rendering Implementierungsleitfaden","description":"Detaillierte Erläuterung des Client-Side Rendering-Mechanismus im Gez Framework, einschließlich statischer Builds, Bereitstellungsstrategien und Best Practices, um Entwicklern zu helfen, effizientes Frontend-Rendering in serverlosen Umgebungen zu realisieren.","head":[["meta",{"property":"keywords","content":"Gez, Client-Side Rendering, CSR, Statischer Build, Frontend-Rendering, Serverlose Bereitstellung, Leistungsoptimierung"}]]},"version":""},{"id":13,"title":"Modulverknüpfung","content":"#\n\nDas Gez Framework bietet einen umfassenden Modulverknüpfungsmechanismus zur\nVerwaltung des Code-Sharings und der Abhängigkeiten zwischen Diensten. Dieser\nMechanismus basiert auf der ESM-Spezifikation (ECMAScript Module) und\nunterstützt das Exportieren und Importieren von Modulen auf Quellcodeebene sowie\neine vollständige Abhängigkeitsverwaltung.\n\n\nKernkonzepte#\n\nModulexport#\n\nDer Modulexport ist der Prozess, bei dem spezifische Codeeinheiten (wie\nKomponenten, Utility-Funktionen usw.) eines Dienstes im ESM-Format nach außen\nverfügbar gemacht werden. Es werden zwei Exporttypen unterstützt:\n\n * Quellcodeexport: Direktes Exportieren von Quellcodedateien aus dem Projekt\n * Abhängigkeitsexport: Exportieren von verwendeten Drittanbieter-Abhängigkeiten\n\nModulimport#\n\nDer Modulimport ist der Prozess, bei dem Codeeinheiten, die von anderen Diensten\nexportiert wurden, in einem Dienst referenziert werden. Es werden mehrere\nInstallationsmethoden unterstützt:\n\n * Quellcodeinstallation: Geeignet für Entwicklungsumgebungen, unterstützt\n   Echtzeitänderungen und Hot-Reloading\n * Paketinstallation: Geeignet für Produktionsumgebungen, verwendet direkt die\n   Build-Artefakte\n\n\nVorlademechanismus#\n\nUm die Dienstleistung zu optimieren, implementiert Gez einen intelligenten\nModulvorlademechanismus:\n\n 1. Abhängigkeitsanalyse\n    \n    * Analyse der Abhängigkeiten zwischen Komponenten während des Builds\n    * Identifizierung der Kernmodule auf dem kritischen Pfad\n    * Bestimmung der Ladepriorität der Module\n\n 2. Ladestrategie\n    \n    * Sofortiges Laden: Kernmodule auf dem kritischen Pfad\n    * Verzögertes Laden: Module für nicht kritische Funktionen\n    * Nachfragebasiertes Laden: Bedingt gerenderte Module\n\n 3. Ressourcenoptimierung\n    \n    * Intelligente Code-Splitting-Strategie\n    * Cache-Verwaltung auf Modulebene\n    * Nachfragebasierte Kompilierung und Bundling\n\n\nModulexport#\n\n\nKonfigurationsbeschreibung#\n\nKonfigurieren Sie die zu exportierenden Module in entry.node.ts:\n\n\n\nDie Exportkonfiguration unterstützt zwei Typen:\n\n * root:*: Exportiert Quellcodedateien, der Pfad ist relativ zum\n   Projektstammverzeichnis\n * npm:*: Exportiert Drittanbieter-Abhängigkeiten, direkt durch Angabe des\n   Paketnamens\n\n\nModulimport#\n\n\nKonfigurationsbeschreibung#\n\nKonfigurieren Sie die zu importierenden Module in entry.node.ts:\n\n\n\nKonfigurationsbeschreibung:\n\n 1. imports: Konfiguriert den lokalen Pfad für Remote-Module\n    \n    * Quellcodeinstallation: Verweis auf das Build-Artefaktverzeichnis (dist)\n    * Paketinstallation: Direkter Verweis auf das Paketverzeichnis\n\n 2. externals: Konfiguriert externe Abhängigkeiten\n    \n    * Zum Teilen von Abhängigkeiten aus Remote-Modulen\n    * Vermeidung von doppeltem Bundling gleicher Abhängigkeiten\n    * Unterstützung des Teilens von Abhängigkeiten zwischen mehreren Modulen\n\n\nInstallationsmethoden#\n\nQuellcodeinstallation#\n\nGeeignet für Entwicklungsumgebungen, unterstützt Echtzeitänderungen und\nHot-Reloading.\n\n 1. Workspace-Methode Empfohlen für die Verwendung in Monorepo-Projekten:\n\n\n\n 2. Link-Methode Für lokale Entwicklungs- und Debugging-Zwecke:\n\n\n\nPaketinstallation#\n\nGeeignet für Produktionsumgebungen, verwendet direkt die Build-Artefakte.\n\n 1. NPM Registry Installation über die npm-Registry:\n\n\n\n 2. Statischer Server Installation über das HTTP/HTTPS-Protokoll:\n\n\n\n\nPaketbuild#\n\n\nKonfigurationsbeschreibung#\n\nKonfigurieren Sie die Build-Optionen in entry.node.ts:\n\n\n\n\nBuild-Artefakte#\n\n\n\n\nVeröffentlichungsprozess#\n\n\n\n\nBest Practices#\n\n\nEntwicklungsumgebungskonfiguration#\n\n * Abhängigkeitsverwaltung\n   \n   * Verwenden Sie die Workspace- oder Link-Methode zur Installation von\n     Abhängigkeiten\n   * Verwalten Sie Abhängigkeitsversionen zentral\n   * Vermeiden Sie die doppelte Installation gleicher Abhängigkeiten\n\n * Entwicklungserlebnis\n   \n   * Aktivieren Sie die Hot-Reloading-Funktion\n   * Konfigurieren Sie eine geeignete Vorladestrategie\n   * Optimieren Sie die Build-Geschwindigkeit\n\n\nProduktionsumgebungskonfiguration#\n\n * Bereitstellungsstrategie\n   \n   * Verwenden Sie die NPM Registry oder einen statischen Server\n   * Stellen Sie die Integrität der Build-Artefakte sicher\n   * Implementieren Sie einen Graustufen-Veröffentlichungsmechanismus\n\n * Leistungsoptimierung\n   \n   * Konfigurieren Sie die Ressourcenvorladung angemessen\n   * Optimieren Sie die Modulladereihenfolge\n   * Implementieren Sie eine effektive Cache-Strategie\n\n\nVersionsverwaltung#\n\n * Versionsrichtlinien\n   \n   * Befolgen Sie die semantische Versionsverwaltung\n   * Pflegen Sie detaillierte Änderungsprotokolle\n   * Führen Sie Kompatibilitätstests durch\n\n * Abhängigkeitsaktualisierung\n   \n   * Aktualisieren Sie Abhängigkeiten zeitnah\n   * Führen Sie regelmäßige Sicherheitsaudits durch\n   * Halten Sie Abhängigkeitsversionen konsistent","routePath":"/de/guide/essentials/module-link","lang":"de","toc":[{"text":"Kernkonzepte","id":"kernkonzepte","depth":3,"charIndex":352},{"text":"Modulexport","id":"modulexport","depth":4,"charIndex":367},{"text":"Modulimport","id":"modulimport","depth":4,"charIndex":758},{"text":"Vorlademechanismus","id":"vorlademechanismus","depth":3,"charIndex":1178},{"text":"Modulexport","id":"modulexport-1","depth":2,"charIndex":1880},{"text":"Konfigurationsbeschreibung","id":"konfigurationsbeschreibung","depth":3,"charIndex":1895},{"text":"Modulimport","id":"modulimport-1","depth":2,"charIndex":2225},{"text":"Konfigurationsbeschreibung","id":"konfigurationsbeschreibung-1","depth":3,"charIndex":2240},{"text":"Installationsmethoden","id":"installationsmethoden","depth":3,"charIndex":2832},{"text":"Quellcodeinstallation","id":"quellcodeinstallation","depth":4,"charIndex":2856},{"text":"Paketinstallation","id":"paketinstallation","depth":4,"charIndex":3112},{"text":"Paketbuild","id":"paketbuild","depth":2,"charIndex":3333},{"text":"Konfigurationsbeschreibung","id":"konfigurationsbeschreibung-2","depth":3,"charIndex":3347},{"text":"Build-Artefakte","id":"build-artefakte","depth":3,"charIndex":3435},{"text":"Veröffentlichungsprozess","id":"veröffentlichungsprozess","depth":3,"charIndex":3456},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":3486},{"text":"Entwicklungsumgebungskonfiguration","id":"entwicklungsumgebungskonfiguration","depth":3,"charIndex":3504},{"text":"Produktionsumgebungskonfiguration","id":"produktionsumgebungskonfiguration","depth":3,"charIndex":3963},{"text":"Versionsverwaltung","id":"versionsverwaltung","depth":3,"charIndex":4414}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework - Code-Sharing-Mechanismus zwischen Diensten","description":"Detaillierte Erläuterung des Modulverknüpfungsmechanismus des Gez Frameworks, einschließlich Code-Sharing zwischen Diensten, Abhängigkeitsverwaltung und Implementierung der ESM-Spezifikation, um Entwicklern beim Aufbau effizienter Micro-Frontend-Anwendungen zu helfen.","head":[["meta",{"property":"keywords","content":"Gez, Modulverknüpfung, Module Link, ESM, Code-Sharing, Abhängigkeitsverwaltung, Micro-Frontend"}]]},"version":""},{"id":14,"title":"Renderkontext","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/de/guide/essentials/render-context","lang":"de","toc":[{"text":"Verwendung","id":"verwendung","depth":2,"charIndex":-1},{"text":"Hauptfunktionen","id":"hauptfunktionen","depth":2,"charIndex":-1},{"text":"Abhängigkeitssammlung","id":"abhängigkeitssammlung","depth":3,"charIndex":-1},{"text":"Bedarfsgerechte Sammlung","id":"bedarfsgerechte-sammlung","depth":4,"charIndex":-1},{"text":"Automatisierte Verarbeitung","id":"automatisierte-verarbeitung","depth":4,"charIndex":-1},{"text":"Leistungsoptimierung","id":"leistungsoptimierung","depth":4,"charIndex":-1},{"text":"Ressourceneinbindung","id":"ressourceneinbindung","depth":3,"charIndex":-1},{"text":"Ressourceneinbindungsreihenfolge","id":"ressourceneinbindungsreihenfolge","depth":3,"charIndex":-1},{"text":"Vollständiger Rendering-Prozess","id":"vollständiger-rendering-prozess","depth":2,"charIndex":-1},{"text":"Erweiterte Funktionen","id":"erweiterte-funktionen","depth":2,"charIndex":-1},{"text":"Basis-Pfad-Konfiguration","id":"basis-pfad-konfiguration","depth":3,"charIndex":-1},{"text":"Import-Mapping-Modi","id":"import-mapping-modi","depth":3,"charIndex":-1},{"text":"Einstiegsfunktionskonfiguration","id":"einstiegsfunktionskonfiguration","depth":3,"charIndex":-1},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Server-Side Rendering Kernmechanismus","description":"Detaillierte Erläuterung des RenderContext-Mechanismus im Gez Framework, einschließlich Ressourcenverwaltung, HTML-Generierung und ESM-Modulsystem, um Entwicklern das Verständnis und die Nutzung der Server-Side Rendering-Funktionalität zu erleichtern.","head":[["meta",{"property":"keywords","content":"Gez, Renderkontext, RenderContext, SSR, Server-Side Rendering, ESM, Ressourcenverwaltung"}]]},"version":""},{"id":15,"title":"Rspack","content":"#\n\nGez basiert auf dem Rspack-Build-System und nutzt dessen\nHochleistungs-Build-Fähigkeiten voll aus. Dieses Dokument beschreibt die Rolle\nund die Kernfunktionen von Rspack im Gez-Framework.\n\n\nFunktionen#\n\nRspack ist das zentrale Build-System des Gez-Frameworks und bietet die folgenden\nSchlüsselfunktionen:\n\n * Hochleistungs-Build: Eine in Rust implementierte Build-Engine, die eine\n   extrem schnelle Kompilierungsleistung bietet und die Build-Geschwindigkeit\n   großer Projekte erheblich verbessert.\n * Optimierte Entwicklungserfahrung: Unterstützung für moderne\n   Entwicklungsfunktionen wie Hot Module Replacement (HMR) und inkrementelle\n   Kompilierung, die eine flüssige Entwicklungserfahrung bieten.\n * Multi-Umgebungs-Build: Einheitliche Build-Konfigurationen für Client-,\n   Server- und Node.js-Umgebungen, die den Entwicklungsprozess für mehrere\n   Plattformen vereinfachen.\n * Ressourcenoptimierung: Integrierte Fähigkeiten zur Ressourcenverarbeitung und\n   -optimierung, einschließlich Code-Splitting, Tree Shaking und\n   Ressourcenkompression.\n\n\nAnwendungs-Build#\n\nDas Rspack-Build-System von Gez ist modular aufgebaut und umfasst die folgenden\nKernmodule:\n\n\n@gez/rspack#\n\nDas grundlegende Build-Modul, das die folgenden Kernfähigkeiten bietet:\n\n * Einheitliche Build-Konfiguration: Standardisierte Verwaltung von\n   Build-Konfigurationen mit Unterstützung für Multi-Umgebungs-Konfigurationen.\n * Ressourcenverarbeitung: Integrierte Fähigkeiten zur Verarbeitung von\n   TypeScript, CSS, Bildern und anderen Ressourcen.\n * Build-Optimierung: Funktionen wie Code-Splitting und Tree Shaking zur\n   Leistungsoptimierung.\n * Entwicklungsserver: Integration eines Hochleistungs-Entwicklungsservers mit\n   HMR-Unterstützung.\n\n\n@gez/rspack-vue#\n\nDas spezialisierte Build-Modul für das Vue-Framework, das Folgendes bietet:\n\n * Vue-Komponenten-Kompilierung: Effiziente Kompilierung von Vue\n   2/3-Komponenten.\n * SSR-Optimierung: Spezifische Optimierungen für\n   Server-Side-Rendering-Szenarien.\n * Entwicklungsverbesserungen: Spezielle Funktionserweiterungen für die\n   Vue-Entwicklungsumgebung.\n\n\nBuild-Prozess#\n\nDer Build-Prozess von Gez gliedert sich in die folgenden Phasen:\n\n 1. Konfigurationsinitialisierung\n    \n    * Laden der Projektkonfiguration\n    * Zusammenführen von Standard- und Benutzerkonfigurationen\n    * Anpassung der Konfiguration basierend auf Umgebungsvariablen\n\n 2. Ressourcenkompilierung\n    \n    * Analyse der Quellcode-Abhängigkeiten\n    * Transformation verschiedener Ressourcen (TypeScript, CSS usw.)\n    * Verarbeitung von Modulimporten und -exporten\n\n 3. Optimierungsverarbeitung\n    \n    * Durchführung von Code-Splitting\n    * Anwendung von Tree Shaking\n    * Kompression von Code und Ressourcen\n\n 4. Ausgabegenerierung\n    \n    * Erzeugung der Zieldateien\n    * Ausgabe von Ressourcen-Mappings\n    * Generierung von Build-Berichten\n\n\nBest Practices#\n\n\nOptimierung der Entwicklungsumgebung#\n\n * Inkrementelle Kompilierungskonfiguration: Angemessene Konfiguration der\n   cache-Option, um die Build-Geschwindigkeit durch Caching zu erhöhen.\n * HMR-Optimierung: Gezielte Konfiguration des HMR-Bereichs, um unnötige\n   Modulaktualisierungen zu vermeiden.\n * Ressourcenverarbeitungsoptimierung: Verwendung geeigneter\n   Loader-Konfigurationen, um wiederholte Verarbeitung zu vermeiden.\n\n\nOptimierung der Produktionsumgebung#\n\n * Code-Splitting-Strategie: Angemessene Konfiguration von splitChunks, um das\n   Laden von Ressourcen zu optimieren.\n * Ressourcenkompression: Aktivierung geeigneter Kompressionskonfigurationen, um\n   ein Gleichgewicht zwischen Build-Zeit und Artefaktgröße zu erreichen.\n * Cache-Optimierung: Nutzung von Content-Hashing und\n   Langzeit-Caching-Strategien, um die Ladeleistung zu verbessern.\n\n\nKonfigurationsbeispiel#\n\n\n\nTIP\n\nWeitere detaillierte API-Beschreibungen und Konfigurationsoptionen finden Sie in\nder Rspack API-Dokumentation.","routePath":"/de/guide/essentials/rspack","lang":"de","toc":[{"text":"Funktionen","id":"funktionen","depth":2,"charIndex":192},{"text":"Anwendungs-Build","id":"anwendungs-build","depth":2,"charIndex":1059},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":1172},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":1732},{"text":"Build-Prozess","id":"build-prozess","depth":2,"charIndex":2101},{"text":"Best Practices","id":"best-practices","depth":2,"charIndex":2872},{"text":"Optimierung der Entwicklungsumgebung","id":"optimierung-der-entwicklungsumgebung","depth":3,"charIndex":2890},{"text":"Optimierung der Produktionsumgebung","id":"optimierung-der-produktionsumgebung","depth":3,"charIndex":3320},{"text":"Konfigurationsbeispiel","id":"konfigurationsbeispiel","depth":2,"charIndex":3753}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Hochleistungs-Build-Engine","description":"Eine detaillierte Analyse des Rspack-Build-Systems im Gez-Framework, einschließlich Hochleistungs-Kompilierung, Multi-Umgebungs-Builds, Ressourcenoptimierung und anderen Kernfunktionen, die Entwicklern helfen, effiziente und zuverlässige moderne Webanwendungen zu erstellen.","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Build-System, Hochleistungs-Kompilierung, Hot Module Replacement, Multi-Umgebungs-Build, Tree Shaking, Code-Splitting, SSR, Ressourcenoptimierung, Entwicklungseffizienz, Build-Tool"}]]},"version":""},{"id":16,"title":"Standardrichtlinien","content":"#\n\nGez ist ein modernes SSR-Framework (Server-Side Rendering), das eine\nstandardisierte Projektstruktur und Pfadauflösungsmechanismen verwendet, um\nKonsistenz und Wartbarkeit in Entwicklungs- und Produktionsumgebungen zu\ngewährleisten.\n\n\nProjektstrukturrichtlinien#\n\n\nStandardverzeichnisstruktur#\n\n\n\nErweiterte Informationen\n * gez.name stammt aus dem name-Feld in package.json\n * dist/package.json stammt aus der package.json im Stammverzeichnis\n * Das dist-Verzeichnis wird nur archiviert, wenn packs.enable auf true gesetzt\n   ist\n\n\nRichtlinien für Einstiegsdateien#\n\n\nentry.client.ts#\n\nDie Client-Einstiegsdatei ist verantwortlich für:\n\n * Initialisierung der Anwendung: Konfiguration der grundlegenden Einstellungen\n   der Client-Anwendung\n * Routing-Management: Handhabung von Client-Routing und Navigation\n * Zustandsmanagement: Speicherung und Aktualisierung des Client-Zustands\n * Interaktionsverarbeitung: Verwaltung von Benutzerereignissen und\n   Oberflächeninteraktionen\n\n\nentry.server.ts#\n\nDie Server-Einstiegsdatei ist verantwortlich für:\n\n * Server-Side Rendering (SSR): Ausführung des SSR-Rendering-Prozesses\n * HTML-Generierung: Erstellung der initialen Seitenstruktur\n * Datenvorabruf: Verarbeitung des Server-seitigen Datenabrufs\n * Zustandsinjektion: Übergabe des Server-Zustands an den Client\n * SEO-Optimierung: Sicherstellung der Suchmaschinenoptimierung der Seite\n\n\nentry.node.ts#\n\nDie Node.js-Server-Einstiegsdatei ist verantwortlich für:\n\n * Server-Konfiguration: Festlegung der HTTP-Server-Parameter\n * Routing-Verarbeitung: Verwaltung der Server-seitigen Routing-Regeln\n * Middleware-Integration: Konfiguration der Server-Middleware\n * Umgebungsmanagement: Handhabung von Umgebungsvariablen und Konfigurationen\n * Anfrage-Antwort-Verarbeitung: Verarbeitung von HTTP-Anfragen und -Antworten\n\n\nRichtlinien für Konfigurationsdateien#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/de/guide/essentials/std","lang":"de","toc":[{"text":"Projektstrukturrichtlinien","id":"projektstrukturrichtlinien","depth":2,"charIndex":237},{"text":"Standardverzeichnisstruktur","id":"standardverzeichnisstruktur","depth":3,"charIndex":267},{"text":"Richtlinien für Einstiegsdateien","id":"richtlinien-für-einstiegsdateien","depth":2,"charIndex":535},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":571},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":984},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":1389},{"text":"Richtlinien für Konfigurationsdateien","id":"richtlinien-für-konfigurationsdateien","depth":2,"charIndex":1819},{"text":"package.json","id":"packagejson","depth":3,"charIndex":1860},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":1878}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework - Projektstruktur und Richtlinien","description":"Detaillierte Beschreibung der standardisierten Projektstruktur, Einstiegsdateien und Konfigurationsdateien des Gez Frameworks, um Entwicklern beim Aufbau von standardisierten und wartbaren SSR-Anwendungen zu helfen.","head":[["meta",{"property":"keywords","content":"Gez, Projektstruktur, Einstiegsdateien, Konfigurationsrichtlinien, SSR-Framework, TypeScript, Projektrichtlinien, Entwicklungsstandards"}]]},"version":""},{"id":17,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/de/guide/frameworks/html","lang":"de","toc":[{"text":"Projektstruktur","id":"projektstruktur","depth":2,"charIndex":-1},{"text":"Projektkonfiguration","id":"projektkonfiguration","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Quellcode-Struktur","id":"quellcode-struktur","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Projekt ausführen","id":"projekt-ausführen","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework HTML SSR Anwendungsbeispiel","description":"Erstellen Sie eine HTML SSR-Anwendung mit Gez von Grund auf. Dieses Beispiel zeigt die grundlegende Verwendung des Frameworks, einschließlich Projektinitialisierung, HTML-Konfiguration und Einstiegspunktdateien.","head":[["meta",{"property":"keywords","content":"Gez, HTML, SSR-Anwendung, TypeScript-Konfiguration, Projektinitialisierung, Serverseitiges Rendering, Client-Interaktion"}]]},"version":""},{"id":18,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/de/guide/frameworks/preact-htm","lang":"de","toc":[{"text":"Projektstruktur","id":"projektstruktur","depth":2,"charIndex":-1},{"text":"Projektkonfiguration","id":"projektkonfiguration","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Quellcode-Struktur","id":"quellcode-struktur","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Projekt ausführen","id":"projekt-ausführen","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Preact+HTM SSR Anwendungsbeispiel","description":"Erstellen Sie eine Preact+HTM SSR-Anwendung mit Gez von Grund auf. Dieses Beispiel zeigt die grundlegende Verwendung des Frameworks, einschließlich Projektinitialisierung, Preact-Konfiguration und Einstiegspunktdateien.","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, SSR-Anwendung, TypeScript-Konfiguration, Projektinitialisierung, Serverseitiges Rendering, Client-Interaktion"}]]},"version":""},{"id":19,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/de/guide/frameworks/vue2","lang":"de","toc":[{"text":"Projektstruktur","id":"projektstruktur","depth":2,"charIndex":-1},{"text":"Projektkonfiguration","id":"projektkonfiguration","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Quellcodestruktur","id":"quellcodestruktur","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Projekt ausführen","id":"projekt-ausführen","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Vue2 SSR Anwendungsbeispiel","description":"Erstellen Sie eine Vue2 SSR-Anwendung mit Gez von Grund auf. Dieses Beispiel zeigt die grundlegende Verwendung des Frameworks, einschließlich Projektinitialisierung, Vue2-Konfiguration und Einstiegspunktdateien.","head":[["meta",{"property":"keywords","content":"Gez, Vue2, SSR-Anwendung, TypeScript-Konfiguration, Projektinitialisierung, Serverseitiges Rendering, Client-Interaktion"}]]},"version":""},{"id":20,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/de/guide/frameworks/vue3","lang":"de","toc":[{"text":"Projektstruktur","id":"projektstruktur","depth":2,"charIndex":-1},{"text":"Projektkonfiguration","id":"projektkonfiguration","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"Quellcode-Struktur","id":"quellcode-struktur","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"Projekt ausführen","id":"projekt-ausführen","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Vue3 SSR Anwendungsbeispiel","description":"Erstellen Sie eine Vue3 SSR-Anwendung mit Gez von Grund auf. Dieses Beispiel zeigt die grundlegende Verwendung des Frameworks, einschließlich Projektinitialisierung, Vue3-Konfiguration und Einstiegspunktdateien.","head":[["meta",{"property":"keywords","content":"Gez, Vue3, SSR-Anwendung, TypeScript-Konfiguration, Projektinitialisierung, Serverseitiges Rendering, Client-Interaktion, Composition API"}]]},"version":""},{"id":21,"title":"Umgebungsanforderungen","content":"#\n\nDieses Dokument beschreibt die Umgebungsanforderungen für die Verwendung dieses\nFrameworks, einschließlich der Node.js-Umgebung und der Browserkompatibilität.\n\n\nNode.js-Umgebung#\n\nDas Framework erfordert Node.js Version >= 22.6, hauptsächlich zur Unterstützung\nvon TypeScript-Typimporten (über das --experimental-strip-types-Flag), ohne\nzusätzliche Kompilierungsschritte.\n\n\nBrowserkompatibilität#\n\nDas Framework wird standardmäßig im Kompatibilitätsmodus erstellt, um eine\nbreitere Browserunterstützung zu gewährleisten. Es ist jedoch zu beachten, dass\nfür die vollständige Browserkompatibilität die manuelle Hinzufügung der\nes-module-shims-Abhängigkeit erforderlich ist.\n\n\nKompatibilitätsmodus (Standard)#\n\n * 🌐 Chrome: >= 87\n * 🔷 Edge: >= 88\n * 🦊 Firefox: >= 78\n * 🧭 Safari: >= 14\n\nLaut den Statistiken von Can I Use beträgt die Browserabdeckung im\nKompatibilitätsmodus 96,81%.\n\n\nNative Unterstützung#\n\n * 🌐 Chrome: >= 89\n * 🔷 Edge: >= 89\n * 🦊 Firefox: >= 108\n * 🧭 Safari: >= 16.4\n\nDer native Unterstützungsmodus bietet folgende Vorteile:\n\n * Keine Laufzeitkosten, kein zusätzlicher Modullader erforderlich\n * Native Browseranalyse, schnellere Ausführungsgeschwindigkeit\n * Bessere Code-Splitting- und On-Demand-Loading-Fähigkeiten\n\nLaut den Statistiken von Can I Use beträgt die Browserabdeckung im nativen\nUnterstützungsmodus 93,5%.\n\n\nAktivierung der Kompatibilitätsunterstützung#\n\nWichtiger Hinweis\n\nObwohl das Framework standardmäßig im Kompatibilitätsmodus erstellt wird, ist\nfür die vollständige Unterstützung älterer Browser die manuelle Hinzufügung der\nes-module-shims-Abhängigkeit in Ihrem Projekt erforderlich.\n\nFügen Sie das folgende Skript in Ihre HTML-Datei ein:\n\n\n\nBest Practices\n 1. Empfehlungen für die Produktionsumgebung:\n    * Stellen Sie es-module-shims auf Ihrem eigenen Server bereit\n    * Stellen Sie die Stabilität und Zugriffsgeschwindigkeit der Ressourcen\n      sicher\n    * Vermeiden Sie potenzielle Sicherheitsrisiken\n 2. Leistungsüberlegungen:\n    * Der Kompatibilitätsmodus verursacht geringfügige Leistungseinbußen\n    * Entscheiden Sie basierend auf der Browserverteilung Ihrer Zielgruppe, ob\n      Sie ihn aktivieren möchten","routePath":"/de/guide/start/environment","lang":"de","toc":[{"text":"Node.js-Umgebung","id":"nodejs-umgebung","depth":2,"charIndex":163},{"text":"Browserkompatibilität","id":"browserkompatibilität","depth":2,"charIndex":376},{"text":"Kompatibilitätsmodus (Standard)","id":"kompatibilitätsmodus-standard","depth":3,"charIndex":676},{"text":"Native Unterstützung","id":"native-unterstützung","depth":3,"charIndex":888},{"text":"Aktivierung der Kompatibilitätsunterstützung","id":"aktivierung-der-kompatibilitätsunterstützung","depth":3,"charIndex":1349}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Kompatibilitätsleitfaden","description":"Detaillierte Anforderungen an die Umgebung des Gez-Frameworks, einschließlich Node.js-Versionsanforderungen und Browserkompatibilitätshinweise, um Entwicklern bei der korrekten Konfiguration der Entwicklungsumgebung zu helfen.","head":[["meta",{"property":"keywords","content":"Gez, Node.js, Browserkompatibilität, TypeScript, es-module-shims, Umgebungskonfiguration"}]]},"version":""},{"id":22,"title":"Schnellstart","content":"#\n\n\nProjektinitialisierung#\n\nUm ein neues Gez-Projekt zu erstellen und zu initialisieren, führen Sie die\nfolgenden Schritte aus:\n\n\n\n\nFramework-Version-Auswahl#\n\nDas Gez Framework bietet mehrere Technologie-Stack-Versionen, die jeweils für\nverschiedene Anwendungsszenarien optimiert sind. Wählen Sie die passende Version\nbasierend auf Ihren Projektanforderungen:\n\n\nHTML#\n\nGeeignet für Projekte, die eine minimalistisches Architektur bevorzugen:\n\n * Keine externen Abhängigkeiten, sofort einsatzbereit\n * Native JavaScript-Entwicklungserfahrung\n * Ideal für statische Websites und leichtgewichtige Anwendungen\n * Unterstützung für progressive Funktionserweiterungen\n\nHTML-Version Dokumentation anzeigen\n\n\nVue2#\n\nGeeignet für die Entwicklung von Unternehmensanwendungen:\n\n * Vollständige TypeScript-Unterstützung\n * Umfangreiches Ökosystem von Drittanbieter-Komponenten\n * Ausgereifte Entwicklungstoolchain\n * In Produktionsumgebungen bewährte Stabilität\n\nVue2-Version Dokumentation anzeigen\n\n\nVue3#\n\nGeeignet für die Entwicklung moderner Webanwendungen:\n\n * Proxy-basiertes reaktives System\n * Unterstützung für Composition API\n * Bessere Laufzeitleistung\n * Kleinere Bundle-Größe\n\nVue3-Version Dokumentation anzeigen\n\n\nPreact+HTM#\n\nGeeignet für Projekte, die Leichtgewichtigkeit und hohe Leistung bevorzugen:\n\n * Sehr kleine Laufzeitgröße (3KB)\n * Native JavaScript-Templatesyntax\n * Mit React kompatible API\n * Hervorragende Leistung\n\nPreact+HTM-Version Dokumentation anzeigen\n\n\nKI-unterstützte Entwicklung#\n\nDas Gez Framework bietet KI-unterstützte Entwicklungsfähigkeiten, die die\nEntwicklungseffizienz erheblich steigern können:\n\n 1. Wählen Sie die passende Framework-Version aus der Dokumentation\n 2. Geben Sie den Dokumentationsinhalt an den KI-Assistenten weiter\n 3. Der KI-Assistent generiert automatisch das Projektskelett und die\n    Konfigurationsdateien\n\nTipp\n\nDie KI-unterstützte Entwicklung beschleunigt nicht nur die\nProjektinitialisierung, sondern stellt auch sicher, dass die Projektstruktur den\nBest Practices entspricht.","routePath":"/de/guide/start/getting-started","lang":"de","toc":[{"text":"Projektinitialisierung","id":"projektinitialisierung","depth":2,"charIndex":3},{"text":"Framework-Version-Auswahl","id":"framework-version-auswahl","depth":2,"charIndex":132},{"text":"HTML","id":"html","depth":3,"charIndex":363},{"text":"Vue2","id":"vue2","depth":3,"charIndex":702},{"text":"Vue3","id":"vue3","depth":3,"charIndex":990},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":1217},{"text":"KI-unterstützte Entwicklung","id":"ki-unterstützte-entwicklung","depth":2,"charIndex":1478}],"domain":"","frontmatter":{"titleSuffix":"Gez Framework Schnellstartanleitung","description":"Schnellstartanleitung für das Gez Framework, die Ihnen hilft, ein Projekt von Grund auf aufzubauen, einschließlich Projektinitialisierung, Framework-Version-Auswahl und KI-unterstützter Entwicklung.","head":[["meta",{"name":"keywords","content":"Gez Framework, Schnellstart, Projektinitialisierung, Vue-Entwicklung, HTML-Entwicklung, KI-Unterstützung"}]]},"version":""},{"id":23,"title":"Einführung","content":"#\n\n\nProjektkontext#\n\nGez ist ein modernes Micro-Frontend-Framework basierend auf ECMAScript Modules\n(ESM), das sich auf die Erstellung von hochleistungsfähigen, skalierbaren\nserverseitigen Rendering (SSR)-Anwendungen konzentriert. Als dritte Generation\ndes Genesis-Projekts hat Gez im Laufe der technologischen Entwicklung\nkontinuierlich Innovationen vorangetrieben:\n\n * v1.0: Implementierung des bedarfsgerechten Ladens von Remote-Komponenten\n   basierend auf HTTP-Anfragen\n * v2.0: Anwendungsintegration basierend auf Webpack Module Federation\n * v3.0: Neugestaltung des Modulverknüpfungssystems basierend auf nativen ESM im\n   Browser\n\n\nTechnologischer Hintergrund#\n\nIm Entwicklungsprozess der Micro-Frontend-Architektur weisen traditionelle\nLösungen hauptsächlich die folgenden Einschränkungen auf:\n\n\nHerausforderungen bestehender Lösungen#\n\n * Leistungsengpässe: Laufzeitabhängigkeitsinjektion und\n   JavaScript-Sandbox-Proxies verursachen erhebliche Leistungseinbußen\n * Isolationsmechanismus: Selbst entwickelte Sandbox-Umgebungen können die\n   native Modulisolationsfähigkeit des Browsers nicht erreichen\n * Build-Komplexität: Anpassungen der Build-Tools zur Implementierung der\n   Abhängigkeitsfreigabe erhöhen die Projektwartungskosten\n * Standardabweichung: Spezielle Bereitstellungsstrategien und\n   Laufzeitverarbeitungsmechanismen weichen von modernen\n   Webentwicklungsstandards ab\n * Ökosystembeschränkungen: Framework-Kopplung und benutzerdefinierte APIs\n   schränken die Technologieauswahl ein\n\n\nTechnologische Innovationen#\n\nGez bietet basierend auf modernen Webstandards eine völlig neue Lösung:\n\n * Natives Modulsystem: Nutzung von nativen ESM und Import Maps im Browser zur\n   Abhängigkeitsverwaltung, was eine schnellere Analyse und Ausführung\n   ermöglicht\n * Standardisierter Isolationsmechanismus: Zuverlässige Anwendungsisolation\n   basierend auf dem ECMAScript-Modulbereich\n * Offene Technologie-Stack: Nahtlose Integration beliebiger moderner\n   Frontend-Frameworks\n * Optimierte Entwicklungserfahrung: Intuitive Entwicklungsmuster und\n   vollständige Debugging-Fähigkeiten\n * Extreme Leistungsoptimierung: Null-Laufzeit-Overhead durch native Fähigkeiten\n   in Kombination mit intelligenten Caching-Strategien\n\nTIP\n\nGez konzentriert sich auf die Schaffung einer hochleistungsfähigen, leicht\nerweiterbaren Micro-Frontend-Infrastruktur, die besonders für groß angelegte\nserverseitige Rendering-Anwendungen geeignet ist.\n\n\nTechnische Spezifikationen#\n\n\nUmgebungsabhängigkeiten#\n\nBitte lesen Sie die Dokumentation Umgebungsanforderungen, um detaillierte\nAnforderungen an Browser- und Node.js-Umgebungen zu erfahren.\n\n\nKern-Technologie-Stack#\n\n * Abhängigkeitsverwaltung: Verwendung von Import Maps zur Modulzuordnung, mit\n   es-module-shims für Kompatibilitätsunterstützung\n * Build-System: Basierend auf Rspacks module-import zur Verarbeitung externer\n   Abhängigkeiten\n * Entwicklungstoolchain: Unterstützung von ESM-Hot-Reload und nativer\n   TypeScript-Ausführung\n\n\nFramework-Positionierung#\n\nGez unterscheidet sich von Next.js oder Nuxt.js und konzentriert sich auf die\nBereitstellung von Micro-Frontend-Infrastruktur:\n\n * Modulverknüpfungssystem: Implementierung effizienter und zuverlässiger\n   Modulimporte und -exporte\n * Serverseitiges Rendering: Flexible SSR-Implementierungsmechanismen\n * Typsystemunterstützung: Integration vollständiger TypeScript-Typdefinitionen\n * Framework-Neutralität: Unterstützung der Integration gängiger\n   Frontend-Frameworks\n\n\nArchitekturdesign#\n\n\nZentralisierte Abhängigkeitsverwaltung#\n\n * Einheitliche Abhängigkeitsquelle: Zentralisierte Verwaltung von\n   Drittanbieterabhängigkeiten\n * Automatisierte Verteilung: Globale automatische Synchronisierung von\n   Abhängigkeitsaktualisierungen\n * Versionskonsistenz: Präzise Abhängigkeitsversionskontrolle\n\n\nModulares Design#\n\n * Trennung der Zuständigkeiten: Entkopplung von Geschäftslogik und\n   Infrastruktur\n * Plugin-Mechanismus: Unterstützung flexibler Modulkombinationen und\n   -austausche\n * Standardisierte Schnittstellen: Normierte Kommunikationsprotokolle zwischen\n   Modulen\n\n\nLeistungsoptimierung#\n\n * Null-Overhead-Prinzip: Maximale Nutzung nativer Browserfähigkeiten\n * Intelligentes Caching: Präzise Caching-Strategien basierend auf\n   Inhalts-Hashes\n * Bedarfsgerechtes Laden: Fein abgestimmte Code-Splitting- und\n   Abhängigkeitsverwaltung\n\n\nProjektreife#\n\nGez hat durch fast 5 Jahre iterative Entwicklung (v1.0 bis v3.0) umfassende\nValidierung in Unternehmensumgebungen erhalten. Derzeit unterstützt es Dutzende\nvon Geschäftsprojekten, die stabil laufen, und treibt kontinuierlich die\nModernisierung des Technologie-Stacks voran. Die Stabilität, Zuverlässigkeit und\nLeistungsvorteile des Frameworks wurden in der Praxis umfassend getestet und\nbieten eine solide technische Grundlage für die Entwicklung groß angelegter\nAnwendungen.","routePath":"/de/guide/start/introduction","lang":"de","toc":[{"text":"Projektkontext","id":"projektkontext","depth":2,"charIndex":3},{"text":"Technologischer Hintergrund","id":"technologischer-hintergrund","depth":2,"charIndex":639},{"text":"Herausforderungen bestehender Lösungen","id":"herausforderungen-bestehender-lösungen","depth":3,"charIndex":804},{"text":"Technologische Innovationen","id":"technologische-innovationen","depth":3,"charIndex":1513},{"text":"Technische Spezifikationen","id":"technische-spezifikationen","depth":2,"charIndex":2448},{"text":"Umgebungsabhängigkeiten","id":"umgebungsabhängigkeiten","depth":3,"charIndex":2478},{"text":"Kern-Technologie-Stack","id":"kern-technologie-stack","depth":3,"charIndex":2642},{"text":"Framework-Positionierung","id":"framework-positionierung","depth":2,"charIndex":2993},{"text":"Architekturdesign","id":"architekturdesign","depth":2,"charIndex":3491},{"text":"Zentralisierte Abhängigkeitsverwaltung","id":"zentralisierte-abhängigkeitsverwaltung","depth":3,"charIndex":3512},{"text":"Modulares Design","id":"modulares-design","depth":3,"charIndex":3820},{"text":"Leistungsoptimierung","id":"leistungsoptimierung","depth":3,"charIndex":4101},{"text":"Projektreife","id":"projektreife","depth":2,"charIndex":4372}],"domain":"","frontmatter":{"titleSuffix":"Überblick über das Gez-Framework und technische Innovationen","description":"Erfahren Sie mehr über den Projektkontext, die technologische Entwicklung und die Kernvorteile des Gez-Micro-Frontend-Frameworks. Entdecken Sie moderne serverseitige Rendering-Lösungen basierend auf ESM.","head":[["meta",{"property":"keywords","content":"Gez, Micro-Frontend, ESM, Serverseitiges Rendering, SSR, Technische Innovation, Module Federation"}]]},"version":""}]