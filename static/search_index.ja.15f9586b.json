[{"id":150,"title":"@gez/rspack-vue","content":"#\n\nRspack Vue パッケージは、Vue フレームワークに基づく Rspack アプリケーションを作成および設定するための API を提供します。Vue\nコンポーネントの開発、ビルド、サーバーサイドレンダリングをサポートします。\n\n\nインストール#\n\nパッケージマネージャを使用して @gez/rspack-vue 開発依存関係をインストールします：\n\n\n型エクスポート#\n\n\nBuildTarget#\n\n\n\nビルドターゲット環境の型で、アプリケーションのビルドターゲット環境を定義します。ビルドプロセス中の特定の最適化と機能を設定するために使用されます：\n\n * node: Node.js 環境で実行されるコードをビルド\n * client: ブラウザ環境で実行されるコードをビルド\n * server: サーバー環境で実行されるコードをビルド\n\n\nRspackAppConfigContext#\n\n\n\nRspack アプリケーション設定コンテキストインターフェースで、設定フック関数内でアクセス可能なコンテキスト情報を提供します：\n\n * gez: Gez フレームワークインスタンス\n * buildTarget: 現在のビルドターゲット（client/server/node）\n * config: Rspack 設定オブジェクト\n * options: アプリケーション設定オプション\n\n\nRspackAppOptions#\n\n\n\nRspack アプリケーション設定オプションインターフェース：\n\n * css: CSS 出力方式で、'css'（独立ファイル）または 'style'（インラインスタイル）を選択可能\n * loaders: カスタム loader 設定\n * styleLoader: style-loader 設定オプション\n * cssLoader: css-loader 設定オプション\n * target: ビルドターゲット互換性設定\n * definePlugin: グローバル定数定義\n * config: 設定フック関数\n\n\nRspackHtmlAppOptions#\n\nRspackAppOptions を継承し、HTML アプリケーションの特定のオプションを設定するために使用されます。\n\n\n関数エクスポート#\n\n\ncreateRspackApp#\n\n\n\n標準の Rspack アプリケーションインスタンスを作成します。\n\nパラメータ：\n\n * gez: Gez フレームワークインスタンス\n * options: Rspack アプリケーション設定オプション\n\n戻り値：\n\n * 作成されたアプリケーションインスタンスに解決される Promise を返します\n\n\ncreateRspackHtmlApp#\n\n\n\nHTML タイプの Rspack アプリケーションインスタンスを作成します。\n\nパラメータ：\n\n * gez: Gez フレームワークインスタンス\n * options: HTML アプリケーション設定オプション\n\n戻り値：\n\n * 作成された HTML アプリケーションインスタンスに解決される Promise を返します\n\n\n定数エクスポート#\n\n\nRSPACK_LOADER#\n\n\n\nRspack に組み込まれた loader 識別子のマッピングオブジェクトで、一般的に使用される loader 名の定数を提供します：\n\n * builtinSwcLoader: Rspack に組み込まれた SWC loader で、TypeScript/JavaScript\n   ファイルを処理します\n * lightningcssLoader: Rspack に組み込まれた lightningcss loader で、CSS\n   ファイルの高性能コンパイラを処理します\n * styleLoader: CSS を DOM に注入するための loader\n * cssLoader: CSS ファイルを解析し、CSS モジュール化を処理するための loader\n * lessLoader: Less ファイルを CSS にコンパイルするための loader\n * styleResourcesLoader: グローバルスタイルリソース（変数、mixins など）を自動的にインポートするための loader\n * workerRspackLoader: Web Worker ファイルを処理するための loader\n\nこれらの定数を使用して、設定内で組み込みの loader を参照し、手動で文字列を入力する必要がなくなります：\n\n\n\n注意事項：\n\n * これらの loader は Rspack に組み込まれており、追加のインストールは不要です\n * カスタム loader 設定では、これらの定数を使用してデフォルトの loader 実装を置き換えることができます\n * 一部の loader（例：builtinSwcLoader）には特定の設定オプションがあります。関連する設定ドキュメントを参照してください\n\n\nモジュールエクスポート#\n\n\nrspack#\n\n@rspack/core パッケージのすべての内容を再エクスポートし、Rspack のコア機能を完全に提供します。","routePath":"/ja/api/app/rspack-vue","lang":"ja","toc":[{"text":"インストール","id":"インストール","depth":2,"charIndex":120},{"text":"型エクスポート","id":"型エクスポート","depth":2,"charIndex":181},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":192},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":380},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":604},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":887},{"text":"関数エクスポート","id":"関数エクスポート","depth":2,"charIndex":972},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":984},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1159},{"text":"定数エクスポート","id":"定数エクスポート","depth":2,"charIndex":1348},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":1360},{"text":"モジュールエクスポート","id":"モジュールエクスポート","depth":2,"charIndex":2144},{"text":"rspack","id":"rspack","depth":3,"charIndex":2159}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク Vue ビルドツール","description":"Gez フレームワークの Vue 専用ビルドツールで、Vue 2/3 アプリケーションのビルドを完全にサポートします。コンポーネント開発、SSR レンダリング、パフォーマンス最適化などの機能を提供します。","head":[["meta",{"property":"keywords","content":"Gez, Rspack, Vue, Vue2, Vue3, SSR, ビルドツール, コンポーネント開発, サーバーサイドレンダリング, パフォーマンス最適化"}]]},"version":""},{"id":151,"title":"@gez/rspack","content":"#\n\nRspack パッケージは、Rspack アプリケーションの作成と設定のための API を提供し、標準アプリケーションと HTML\nアプリケーションのビルドと開発をサポートします。\n\n\nインストール#\n\nパッケージマネージャーを使用して @gez/rspack 開発依存関係をインストールします：\n\n\n型エクスポート#\n\n\nBuildTarget#\n\n\n\nビルドターゲット環境の型を定義します。アプリケーションのビルドターゲット環境を指定し、ビルドプロセス中の特定の最適化と機能を設定するために使用されます：\n\n * node: Node.js 環境で実行されるコードをビルド\n * client: ブラウザ環境で実行されるコードをビルド\n * server: サーバー環境で実行されるコードをビルド\n\n\nRspackAppConfigContext#\n\n\n\nRspack アプリケーション設定コンテキストインターフェース。設定フック関数内でアクセス可能なコンテキスト情報を提供します：\n\n * gez: Gez フレームワークインスタンス\n * buildTarget: 現在のビルドターゲット（client/server/node）\n * config: Rspack 設定オブジェクト\n * options: アプリケーション設定オプション\n\n\nRspackAppOptions#\n\n\n\nRspack アプリケーション設定オプションインターフェース：\n\n * css: CSS 出力方式。'css'（独立ファイル）または 'style'（インラインスタイル）を選択可能\n * loaders: カスタム loader 設定\n * styleLoader: style-loader 設定オプション\n * cssLoader: css-loader 設定オプション\n * target: ビルドターゲット互換性設定\n * definePlugin: グローバル定数定義\n * config: 設定フック関数\n\n\nRspackHtmlAppOptions#\n\nRspackAppOptions を継承し、HTML アプリケーションの特定のオプションを設定します。\n\n\n関数エクスポート#\n\n\ncreateRspackApp#\n\n\n\n標準の Rspack アプリケーションインスタンスを作成します。\n\nパラメータ：\n\n * gez: Gez フレームワークインスタンス\n * options: Rspack アプリケーション設定オプション\n\n戻り値：\n\n * 作成されたアプリケーションインスタンスを解決する Promise を返します\n\n\ncreateRspackHtmlApp#\n\n\n\nHTML タイプの Rspack アプリケーションインスタンスを作成します。\n\nパラメータ：\n\n * gez: Gez フレームワークインスタンス\n * options: HTML アプリケーション設定オプション\n\n戻り値：\n\n * 作成された HTML アプリケーションインスタンスを解決する Promise を返します\n\n\n定数エクスポート#\n\n\nRSPACK_LOADER#\n\n\n\nRspack 組み込みの loader 識別子マッピングオブジェクト。一般的に使用される loader 名の定数を提供します：\n\n * builtinSwcLoader: Rspack 組み込みの SWC loader。TypeScript/JavaScript ファイルを処理します\n * lightningcssLoader: Rspack 組み込みの lightningcss loader。CSS ファイルの高性能コンパイラです\n * styleLoader: CSS を DOM に注入するための loader\n * cssLoader: CSS ファイルを解析し、CSS モジュール化を処理する loader\n * lessLoader: Less ファイルを CSS にコンパイルする loader\n * styleResourcesLoader: グローバルスタイルリソース（変数、mixins など）を自動的にインポートする loader\n * workerRspackLoader: Web Worker ファイルを処理する loader\n\nこれらの定数を使用して、設定内で組み込みの loader を参照できます。手動で文字列を入力する必要がありません：\n\n\n\n注意事項：\n\n * これらの loader は Rspack に組み込まれており、追加のインストールは不要です\n * カスタム loader 設定では、これらの定数を使用してデフォルトの loader 実装を置き換えることができます\n * 一部の loader（例：builtinSwcLoader）には特定の設定オプションがあります。関連する設定ドキュメントを参照してください\n\n\nモジュールエクスポート#\n\n\nrspack#\n\n@rspack/core パッケージのすべての内容を再エクスポートし、完全な Rspack コア機能を提供します。","routePath":"/ja/api/app/rspack","lang":"ja","toc":[{"text":"インストール","id":"インストール","depth":2,"charIndex":95},{"text":"型エクスポート","id":"型エクスポート","depth":2,"charIndex":153},{"text":"BuildTarget","id":"buildtarget","depth":3,"charIndex":164},{"text":"RspackAppConfigContext","id":"rspackappconfigcontext","depth":3,"charIndex":355},{"text":"RspackAppOptions","id":"rspackappoptions","depth":3,"charIndex":578},{"text":"RspackHtmlAppOptions","id":"rspackhtmlappoptions","depth":3,"charIndex":860},{"text":"関数エクスポート","id":"関数エクスポート","depth":2,"charIndex":937},{"text":"createRspackApp","id":"createrspackapp","depth":3,"charIndex":949},{"text":"createRspackHtmlApp","id":"createrspackhtmlapp","depth":3,"charIndex":1123},{"text":"定数エクスポート","id":"定数エクスポート","depth":2,"charIndex":1311},{"text":"RSPACK_LOADER","id":"rspack_loader","depth":3,"charIndex":1323},{"text":"モジュールエクスポート","id":"モジュールエクスポート","depth":2,"charIndex":2075},{"text":"rspack","id":"rspack","depth":3,"charIndex":2090}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク Rspack ビルドツール","description":"Gez フレームワークの Rspack ビルドツールは、高性能なアプリケーションビルド機能を提供し、標準アプリケーションと HTML アプリケーションの開発とビルドをサポートします。組み込みのリソースプロセッサと最適化設定を備えています。","head":[["meta",{"property":"keywords","content":"Gez, Rspack, ビルドツール, アプリケーションビルド, HTML アプリケーション, TypeScript, CSS, リソース処理, パフォーマンス最適化"}]]},"version":""},{"id":152,"title":"App","content":"#\n\nApp は Gez\nフレームワークのアプリケーション抽象化で、アプリケーションのライフサイクル管理、静的リソース処理、サーバーサイドレンダリングを統一的に管理するインターフェースを\n提供します。\n\n\n\n\n型定義#\n\n\nApp#\n\n\n\nmiddleware#\n\n * 型: Middleware\n\n静的リソース処理ミドルウェア。\n\n開発環境：\n\n * ソースコードの静的リソースリクエストを処理\n * リアルタイムコンパイルとホットリロードをサポート\n * no-cache キャッシュポリシーを使用\n\n本番環境：\n\n * ビルド後の静的リソースを処理\n * 不変ファイルの長期キャッシュをサポート（.final.xxx）\n * 最適化されたリソースロード戦略\n\n\n\nrender#\n\n * 型: (options?: RenderContextOptions) => Promise\n\nサーバーサイドレンダリング関数。実行環境に応じて異なる実装を提供：\n\n * 本番環境（start）：ビルド後のサーバーエントリーファイル（entry.server）をロードしてレンダリングを実行\n * 開発環境（dev）：ソースコード内のサーバーエントリーファイルをロードしてレンダリングを実行\n\n\n\nbuild#\n\n * 型: () => Promise\n\n本番環境ビルド関数。リソースのバンドルと最適化に使用されます。ビルドが成功すると true を返し、失敗すると false を返します。\n\ndestroy#\n\n * 型: () => Promise\n\nリソースクリーンアップ関数。サーバーのシャットダウン、接続の切断などに使用されます。クリーンアップが成功すると true を返し、失敗すると false\nを返します。","routePath":"/ja/api/core/app","lang":"ja","toc":[{"text":"型定義","id":"型定義","depth":2,"charIndex":104},{"text":"App","id":"app-1","depth":3,"charIndex":-1},{"text":"middleware","id":"middleware","depth":4,"charIndex":119},{"text":"render","id":"render","depth":4,"charIndex":335},{"text":"build","id":"build","depth":4,"charIndex":546},{"text":"destroy","id":"destroy","depth":4,"charIndex":645}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク アプリケーション抽象インターフェース","description":"Gez フレームワークの App インターフェースについて詳しく説明します。アプリケーションのライフサイクル管理、静的リソース処理、サーバーサイドレンダリング機能をカバーし、開発者がアプリケーションのコア機能を理解し使用するのを支援します。","head":[["meta",{"property":"keywords","content":"Gez, App, アプリケーション抽象, ライフサイクル, 静的リソース, サーバーサイドレンダリング, API"}]]},"version":""},{"id":153,"title":"Gez","content":"#\n\n\nはじめに#\n\nGez は Rspack をベースにした高性能な Web\nアプリケーションフレームワークで、アプリケーションライフサイクル管理、静的リソース処理、サーバーサイドレンダリング機能を提供します。\n\n\n型定義#\n\n\nRuntimeTarget#\n\n * 型定義:\n\n\n\nアプリケーションの実行環境タイプ：\n\n * client: ブラウザ環境で実行され、DOM 操作やブラウザ API をサポート\n * server: Node.js 環境で実行され、ファイルシステムやサーバーサイド機能をサポート\n\n\nImportMap#\n\n * 型定義:\n\n\n\nES モジュールのインポートマッピングタイプ。\n\nSpecifierMap#\n\n * 型定義:\n\n\n\nモジュール識別子のマッピングタイプで、モジュールのインポートパスのマッピング関係を定義します。\n\nScopesMap#\n\n * 型定義:\n\n\n\nスコープマッピングタイプで、特定のスコープ下でのモジュールインポートマッピング関係を定義します。\n\n\nCOMMAND#\n\n * 型定義:\n\n\n\nコマンドタイプの列挙型：\n\n * dev: 開発環境コマンドで、開発サーバーを起動し、ホットリロードをサポート\n * build: ビルドコマンドで、本番環境のビルド成果物を生成\n * preview: プレビューコマンドで、ローカルプレビューサーバーを起動\n * start: 起動コマンドで、本番環境サーバーを実行\n\n\nインスタンスオプション#\n\nGez フレームワークのコア設定オプションを定義します。\n\n\n\nroot#\n\n * 型: string\n * デフォルト値: process.cwd()\n\nプロジェクトのルートディレクトリパス。絶対パスまたは相対パスを指定でき、相対パスの場合は現在の作業ディレクトリに基づいて解決されます。\n\nisProd#\n\n * 型: boolean\n * デフォルト値: process.env.NODE_ENV === 'production'\n\n環境識別子。\n\n * true: 本番環境\n * false: 開発環境\n\nbasePathPlaceholder#\n\n * 型: string | false\n * デフォルト値: '[[[___GEZ_DYNAMIC_BASE___]]]'\n\nベースパスのプレースホルダー設定。実行時にリソースのベースパスを動的に置換するために使用されます。false に設定するとこの機能を無効にできます。\n\nmodules#\n\n * 型: ModuleConfig\n\nモジュール設定オプション。プロジェクトのモジュール解決ルールを設定するために使用され、モジュールエイリアスや外部依存関係などの設定を含みます。\n\npacks#\n\n * 型: PackConfig\n\nパッケージ設定オプション。ビルド成果物を標準の npm .tgz 形式のパッケージにパッケージ化するために使用されます。\n\ndevApp#\n\n * 型: (gez: Gez) => Promise\n\n開発環境アプリケーション作成関数。開発環境でのみ使用され、開発サーバーのアプリケーションインスタンスを作成するために使用されます。\n\n\n\nserver#\n\n * 型: (gez: Gez) => Promise\n\nサーバー起動設定関数。HTTP サーバーの設定と起動に使用され、開発環境と本番環境の両方で使用できます。\n\n\n\npostBuild#\n\n * 型: (gez: Gez) => Promise\n\nビルド後処理関数。プロジェクトのビルドが完了した後に実行され、以下の用途に使用できます：\n\n * 追加のリソース処理\n * デプロイ操作\n * 静的ファイルの生成\n * ビルド通知の送信\n\n\nインスタンスプロパティ#\n\n\nname#\n\n * 型: string\n * 読み取り専用: true\n\n現在のモジュールの名前で、モジュール設定から取得されます。\n\n\nvarName#\n\n * 型: string\n * 読み取り専用: true\n\nモジュール名に基づいて生成された有効な JavaScript 変数名。\n\n\nroot#\n\n * 型: string\n * 読み取り専用: true\n\nプロジェクトルートディレクトリの絶対パス。設定された root が相対パスの場合、現在の作業ディレクトリに基づいて解決されます。\n\n\nisProd#\n\n * 型: boolean\n * 読み取り専用: true\n\n現在が本番環境かどうかを判断します。設定オプションの isProd が優先され、設定されていない場合は process.env.NODE_ENV\nに基づいて判断されます。\n\n\nbasePath#\n\n * 型: string\n * 読み取り専用: true\n * 例外: NotReadyError - フレームワークが初期化されていない場合\n\nスラッシュで始まり終わるモジュールのベースパスを取得します。返される形式は /${name}/ で、name はモジュール設定から取得されます。\n\n\nbasePathPlaceholder#\n\n * 型: string\n * 読み取り専用: true\n\n実行時に動的に置換されるベースパスのプレースホルダーを取得します。設定により無効にすることができます。\n\n\nmiddleware#\n\n * 型: Middleware\n * 読み取り専用: true\n\n静的リソース処理ミドルウェアを取得します。環境に応じて異なる実装を提供します：\n\n * 開発環境：ソースコードのリアルタイムコンパイルとホットリロードをサポート\n * 本番環境：静的リソースの長期キャッシュをサポート\n\n\n\n\nrender#\n\n * 型: (options?: RenderContextOptions) => Promise\n * 読み取り専用: true\n\nサーバーサイドレンダリング関数を取得します。環境に応じて異なる実装を提供します：\n\n * 開発環境：ホットリロードとリアルタイムプレビューをサポート\n * 本番環境：最適化されたレンダリングパフォーマンスを提供\n\n\n\n\nCOMMAND#\n\n * 型: typeof COMMAND\n * 読み取り専用: true\n\nコマンド列挙型の定義を取得します。\n\n\nmoduleConfig#\n\n * 型: ParsedModuleConfig\n * 読み取り専用: true\n * 例外: NotReadyError - フレームワークが初期化されていない場合\n\n現在のモジュールの完全な設定情報を取得します。モジュール解決ルールやエイリアス設定などが含まれます。\n\n\npackConfig#\n\n * 型: ParsedPackConfig\n * 読み取り専用: true\n * 例外: NotReadyError - フレームワークが初期化されていない場合\n\n現在のモジュールのパッケージ関連設定を取得します。出力パスや package.json の処理などが含まれます。\n\n\nインスタンスメソッド#\n\n\nconstructor()#\n\n * パラメータ:\n   * options?: GezOptions - フレームワーク設定オプション\n * 戻り値: Gez\n\nGez フレームワークインスタンスを作成します。\n\n\n\n\ninit()#\n\n * パラメータ: command: COMMAND\n * 戻り値: Promise\n * 例外:\n   * Error: 重複初期化時\n   * NotReadyError: 未初期化インスタンスへのアクセス時\n\nGez フレームワークインスタンスを初期化します。以下のコア初期化プロセスを実行します：\n\n 1. プロジェクト設定の解析（package.json、モジュール設定、パッケージ設定など）\n 2. アプリケーションインスタンスの作成（開発環境または本番環境）\n 3. コマンドに応じたライフサイクルメソッドの実行\n\n注意\n * 重複初期化時にはエラーがスローされます\n * 未初期化のインスタンスにアクセスすると NotReadyError がスローされます\n\n\n\n\ndestroy()#\n\n * 戻り値: Promise\n\nGez フレームワークインスタンスを破棄し、リソースのクリーンアップや接続のクローズなどを実行します。主に以下の用途に使用されます：\n\n * 開発サーバーの停止\n * 一時ファイルやキャッシュのクリーンアップ\n * システムリソースの解放\n\n\n\n\nbuild()#\n\n * 戻り値: Promise\n\nアプリケーションのビルドプロセスを実行し、以下の処理を行います：\n\n * ソースコードのコンパイル\n * 本番環境のビルド成果物の生成\n * コードの最適化と圧縮\n * リソースマニフェストの生成\n\n注意\n\nフレームワークインスタンスが初期化されていない状態で呼び出すと NotReadyError がスローされます\n\n\n\n\nserver()#\n\n * 戻り値: Promise\n * 例外: NotReadyError - フレームワークが初期化されていない場合\n\nHTTP サーバーと設定サーバーインスタンスを起動します。以下のライフサイクルで呼び出されます：\n\n * 開発環境（dev）：開発サーバーを起動し、ホットリロードを提供\n * 本番環境（start）：本番サーバーを起動し、本番環境レベルのパフォーマンスを提供\n\n\n\n\npostBuild()#\n\n * 戻り値: Promise\n\nビルド後の処理ロジックを実行し、以下の用途に使用されます：\n\n * 静的 HTML ファイルの生成\n * ビルド成果物の処理\n * デプロイタスクの実行\n * ビルド通知の送信\n\n\n\n\nresolvePath#\n\nプロジェクトパスを解決し、相対パスを絶対パスに変換します。\n\n * パラメータ:\n   \n   * projectPath: ProjectPath - プロジェクトパスタイプ\n   * ...args: string[] - パスセグメント\n\n * 戻り値: string - 解決された絶対パス\n\n * 例:\n\n\n\n\nwriteSync()#\n\nファイル内容を同期書き込みします。\n\n * パラメータ:\n   \n   * filepath: string - ファイルの絶対パス\n   * data: any - 書き込むデータ。文字列、Buffer、またはオブジェクトを指定できます\n\n * 戻り値: boolean - 書き込みが成功したかどうか\n\n * 例:\n\n\n\n\nreadJsonSync()#\n\nJSON ファイルを同期読み取りし、解析します。\n\n * パラメータ:\n   \n   * filename: string - JSON ファイルの絶対パス\n\n * 戻り値: any - 解析された JSON オブジェクト\n\n * 例外: ファイルが存在しないか、JSON 形式が不正な場合に例外がスローされます\n\n * 例:\n\n\n\n\nreadJson()#\n\nJSON ファイルを非同期読み取りし、解析します。\n\n * パラメータ:\n   \n   * filename: string - JSON ファイルの絶対パス\n\n * 戻り値: Promise - 解析された JSON オブジェクト\n\n * 例外: ファイルが存在しないか、JSON 形式が不正な場合に例外がスローされます\n\n * 例:\n\n\n\n\ngetManifestList()#\n\nビルドマニフェストリストを取得します。\n\n * パラメータ:\n   \n   * target: RuntimeTarget - ターゲット環境タイプ\n     * 'client': クライアント環境\n     * 'server': サーバー環境\n\n * 戻り値: Promise - 読み取り専用のビルドマニフェストリスト\n\n * 例外: フレームワークインスタンスが初期化されていない場合に NotReadyError がスローされます\n\nこのメソッドは、指定されたターゲット環境のビルドマニフェストリストを","routePath":"/ja/api/core/gez","lang":"ja","toc":[{"text":"はじめに","id":"はじめに","depth":2,"charIndex":3},{"text":"型定義","id":"型定義","depth":2,"charIndex":108},{"text":"RuntimeTarget","id":"runtimetarget","depth":3,"charIndex":115},{"text":"ImportMap","id":"importmap","depth":3,"charIndex":259},{"text":"SpecifierMap","id":"specifiermap","depth":4,"charIndex":307},{"text":"ScopesMap","id":"scopesmap","depth":4,"charIndex":382},{"text":"COMMAND","id":"command","depth":3,"charIndex":456},{"text":"インスタンスオプション","id":"インスタンスオプション","depth":2,"charIndex":639},{"text":"root","id":"root","depth":4,"charIndex":685},{"text":"isProd","id":"isprod","depth":4,"charIndex":800},{"text":"basePathPlaceholder","id":"basepathplaceholder","depth":4,"charIndex":911},{"text":"modules","id":"modules","depth":4,"charIndex":1073},{"text":"packs","id":"packs","depth":4,"charIndex":1176},{"text":"devApp","id":"devapp","depth":4,"charIndex":1264},{"text":"server","id":"server","depth":4,"charIndex":1371},{"text":"postBuild","id":"postbuild","depth":4,"charIndex":1465},{"text":"インスタンスプロパティ","id":"インスタンスプロパティ","depth":2,"charIndex":1602},{"text":"name","id":"name","depth":3,"charIndex":1617},{"text":"varName","id":"varname","depth":3,"charIndex":1686},{"text":"root","id":"root-1","depth":3,"charIndex":1764},{"text":"isProd","id":"isprod-1","depth":3,"charIndex":1868},{"text":"basePath","id":"basepath","depth":3,"charIndex":1996},{"text":"basePathPlaceholder","id":"basepathplaceholder-1","depth":3,"charIndex":2155},{"text":"middleware","id":"middleware","depth":3,"charIndex":2261},{"text":"render","id":"render","depth":3,"charIndex":2421},{"text":"COMMAND","id":"command-1","depth":3,"charIndex":2607},{"text":"moduleConfig","id":"moduleconfig","depth":3,"charIndex":2675},{"text":"packConfig","id":"packconfig","depth":3,"charIndex":2828},{"text":"インスタンスメソッド","id":"インスタンスメソッド","depth":2,"charIndex":2983},{"text":"constructor()","id":"constructor","depth":3,"charIndex":2997},{"text":"init()","id":"init","depth":3,"charIndex":3108},{"text":"destroy()","id":"destroy","depth":3,"charIndex":3458},{"text":"build()","id":"build","depth":3,"charIndex":3611},{"text":"server()","id":"server-1","depth":3,"charIndex":-1},{"text":"postBuild()","id":"postbuild-1","depth":3,"charIndex":-1},{"text":"resolvePath","id":"resolvepath","depth":3,"charIndex":4130},{"text":"writeSync()","id":"writesync","depth":3,"charIndex":4305},{"text":"readJsonSync()","id":"readjsonsync","depth":3,"charIndex":4483},{"text":"readJson()","id":"readjson","depth":3,"charIndex":4668},{"text":"getManifestList()","id":"getmanifestlist","depth":3,"charIndex":4854}],"domain":"","frontmatter":{"titleSuffix":"フレームワークコアクラス API リファレンス","description":"Gez フレームワークのコアクラス API について詳しく説明します。アプリケーションライフサイクル管理、静的リソース処理、サーバーサイドレンダリング機能など、フレームワークのコア機能を深く理解するためのガイドです。","head":[["meta",{"property":"keywords","content":"Gez, API, ライフサイクル管理, 静的リソース, サーバーサイドレンダリング, Rspack, Web アプリケーションフレームワーク"}]]},"version":""},{"id":154,"title":"ManifestJson","content":"#\n\nmanifest.json は、Gez\nフレームワークのビルドプロセス中に生成されるマニフェストファイルで、サービスのビルド成果物情報を記録します。ビルド成果物、エクスポートファイル、リソースサイズ統\n計を管理するための統一されたインターフェースを提供します。\n\n\n\n\n型定義#\n\n\nManifestJson#\n\n\n\nname#\n\n * 型: string\n\nサービス名。GezOptions.name 設定から取得されます。\n\nexports#\n\n * 型: Record\n\n外部にエクスポートするファイルのマッピング関係。key はソースファイルのパス、value はビルド後のファイルパスです。\n\nbuildFiles#\n\n * 型: string[]\n\nビルド成果物の完全なファイルリスト。生成されたすべてのファイルパスを含みます。\n\nchunks#\n\n * 型: Record\n\nソースファイルとコンパイル成果物の対応関係。key はソースファイルのパス、value はコンパイル情報です。\n\n\nManifestJsonChunks#\n\n\n\njs#\n\n * 型: string\n\n現在のソースファイルがコンパイルされた後の JS ファイルのパス。\n\ncss#\n\n * 型: string[]\n\n現在のソースファイルに関連する CSS ファイルのパスリスト。\n\nresources#\n\n * 型: string[]\n\n現在のソースファイルに関連するその他のリソースファイルのパスリスト。\n\nsizes#\n\n * 型: ManifestJsonChunkSizes\n\nビルド成果物のサイズ統計情報。\n\n\nManifestJsonChunkSizes#\n\n\n\njs#\n\n * 型: number\n\nJS ファイルのサイズ（バイト単位）。\n\ncss#\n\n * 型: number\n\nCSS ファイルのサイズ（バイト単位）。\n\nresource#\n\n * 型: number\n\nリソースファイルのサイズ（バイト単位）。","routePath":"/ja/api/core/manifest-json","lang":"ja","toc":[{"text":"型定義","id":"型定義","depth":2,"charIndex":137},{"text":"ManifestJson","id":"manifestjson-1","depth":3,"charIndex":-1},{"text":"name","id":"name","depth":4,"charIndex":161},{"text":"exports","id":"exports","depth":4,"charIndex":217},{"text":"buildFiles","id":"buildfiles","depth":4,"charIndex":304},{"text":"chunks","id":"chunks","depth":4,"charIndex":374},{"text":"ManifestJsonChunks","id":"manifestjsonchunks","depth":3,"charIndex":455},{"text":"js","id":"js","depth":4,"charIndex":478},{"text":"css","id":"css","depth":4,"charIndex":532},{"text":"resources","id":"resources","depth":4,"charIndex":587},{"text":"sizes","id":"sizes","depth":4,"charIndex":651},{"text":"ManifestJsonChunkSizes","id":"manifestjsonchunksizes","depth":3,"charIndex":707},{"text":"js","id":"js-1","depth":4,"charIndex":734},{"text":"css","id":"css-1","depth":4,"charIndex":774},{"text":"resource","id":"resource","depth":4,"charIndex":816}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク ビルドマニフェストファイルリファレンス","description":"Gez フレームワークのビルドマニフェストファイル（manifest.json）の構造について詳しく説明します。ビルド成果物の管理、エクスポートファイルのマッピング、リソース統計機能などを含み、開発者がビルドシステムを理解し使用するのに役立ちます。","head":[["meta",{"property":"keywords","content":"Gez, ManifestJson, ビルドマニフェスト, リソース管理, ビルド成果物, ファイルマッピング, API"}]]},"version":""},{"id":155,"title":"ModuleConfig","content":"#\n\nModuleConfig は、Gez\nフレームワークのモジュール設定機能を提供し、モジュールのインポート/エクスポートルール、エイリアス設定、外部依存関係などを定義するために使用されます。\n\n\n型定義#\n\n\nPathType#\n\n * 型定義:\n\n\n\nモジュールパスタイプの列挙型：\n\n * npm: node_modules 内の依存関係を表します\n * root: プロジェクトルートディレクトリ内のファイルを表します\n\n\nModuleConfig#\n\n * 型定義:\n\n\n\nモジュール設定インターフェース。サービスのエクスポート、インポート、外部依存関係の設定を定義するために使用されます。\n\nexports#\n\nエクスポート設定リスト。サービス内の特定のコードユニット（コンポーネント、ユーティリティ関数など）を ESM 形式で外部に公開します。\n\n以下の2種類をサポートします：\n\n * root:*: ソースコードファイルをエクスポートします。例：'root:src/components/button.vue'\n * npm:*: サードパーティの依存関係をエクスポートします。例：'npm:vue'\n\nimports#\n\nインポート設定マップ。リモートモジュールとそのローカルパスを設定します。\n\nインストール方法によって設定が異なります：\n\n * ソースコードインストール（Workspace、Git）：dist ディレクトリを指す必要があります\n * パッケージインストール（Link、静的サーバー、プライベートミラー、File）：パッケージディレクトリを直接指します\n\nexternals#\n\n外部依存関係マップ。使用する外部依存関係を設定します。通常はリモートモジュール内の依存関係を使用します。\n\n例：\n\n\n\n\nParsedModuleConfig#\n\n * 型定義:\n\n\n\n解析されたモジュール設定。元のモジュール設定を標準化された内部形式に変換します：\n\nname#\n\n現在のサービスの名前\n\n * モジュールを識別し、インポートパスを生成するために使用されます\n\nroot#\n\n現在のサービスのルートディレクトリパス\n\n * 相対パスを解決し、ビルド成果物を保存するために使用されます\n\nexports#\n\nエクスポート設定リスト\n\n * name: 元のエクスポートパス。例：'npm:vue' または 'root:src/components'\n * type: パスタイプ（npm または root）\n * importName: インポート名。形式：'${serviceName}/${type}/${path}'\n * exportName: エクスポートパス。サービスルートディレクトリからの相対パス\n * exportPath: 実際のファイルパス\n * externalName: 外部依存関係名。他のサービスがこのモジュールをインポートする際の識別子として使用されます\n\nimports#\n\nインポート設定リスト\n\n * name: 外部サービスの名前\n * localPath: ローカルストレージパス。外部モジュールのビルド成果物を保存するために使用されます\n\nexternals#\n\n外部依存関係マップ\n\n * モジュールのインポートパスを実際のモジュール位置にマッピングします\n * match: インポートステートメントをマッチングするための正規表現\n * import: 実際のモジュールパス","routePath":"/ja/api/core/module-config","lang":"ja","toc":[{"text":"型定義","id":"型定義","depth":2,"charIndex":99},{"text":"PathType","id":"pathtype","depth":3,"charIndex":106},{"text":"ModuleConfig","id":"moduleconfig-1","depth":3,"charIndex":-1},{"text":"exports","id":"exports","depth":4,"charIndex":302},{"text":"imports","id":"imports","depth":4,"charIndex":511},{"text":"externals","id":"externals","depth":4,"charIndex":698},{"text":"ParsedModuleConfig","id":"parsedmoduleconfig","depth":3,"charIndex":771},{"text":"name","id":"name","depth":4,"charIndex":845},{"text":"root","id":"root","depth":4,"charIndex":900},{"text":"exports","id":"exports-1","depth":4,"charIndex":962},{"text":"imports","id":"imports-1","depth":4,"charIndex":1263},{"text":"externals","id":"externals-1","depth":4,"charIndex":1360}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワークモジュール設定 API リファレンス","description":"Gez フレームワークの ModuleConfig 設定インターフェースについて詳しく説明します。モジュールのインポート/エクスポートルール、エイリアス設定、外部依存関係管理などを含め、開発者がフレームワークのモジュールシステムを深く理解するのに役立ちます。","head":[["meta",{"property":"keywords","content":"Gez, ModuleConfig, モジュール設定, モジュールインポート/エクスポート, 外部依存関係, エイリアス設定, 依存関係管理, Webアプリケーションフレームワーク"}]]},"version":""},{"id":156,"title":"PackConfig","content":"#\n\nPackConfig は、サービスのビルド成果物を標準的な npm .tgz 形式のパッケージにパッケージングするための設定インターフェースです。\n\n * 標準化: npm 標準の .tgz パッケージ形式を使用\n * 完全性: モジュールのソースコード、型宣言、設定ファイルなど、必要なすべてのファイルを含む\n * 互換性: npm エコシステムと完全に互換性があり、標準的なパッケージ管理ワークフローをサポート\n\n\n型定義#\n\n\n\n\nPackConfig#\n\nenable#\n\nパッケージング機能を有効にするかどうか。有効にすると、ビルド成果物が標準的な npm .tgz 形式のパッケージにパッケージングされます。\n\n * 型: boolean\n * デフォルト値: false\n\noutputs#\n\n出力するパッケージファイルのパスを指定します。以下の設定方法をサポートします：\n\n * string: 単一の出力パス、例: 'dist/versions/my-app.tgz'\n * string[]: 複数の出力パス、複数のバージョンを同時に生成する場合に使用\n * boolean: true の場合、デフォルトのパス 'dist/client/versions/latest.tgz' を使用\n\npackageJson#\n\npackage.json の内容をカスタマイズするコールバック関数。パッケージング前に呼び出され、package.json\nの内容をカスタマイズするために使用されます。\n\n * パラメータ:\n   * gez: Gez - Gez インスタンス\n   * pkg: any - 元の package.json の内容\n * 戻り値: Promise - 変更後の package.json の内容\n\n一般的な用途:\n\n * パッケージ名とバージョン番号の変更\n * 依存関係の追加または更新\n * カスタムフィールドの追加\n * 公開関連情報の設定\n\n例:\n\n\n\nonBefore#\n\nパッケージング前の準備作業を行うコールバック関数。\n\n * パラメータ:\n   * gez: Gez - Gez インスタンス\n   * pkg: Record - package.json の内容\n * 戻り値: Promise\n\n一般的な用途:\n\n * 追加ファイルの追加（README、LICENSE など）\n * テストまたはビルド検証の実行\n * ドキュメントまたはメタデータの生成\n * 一時ファイルのクリーンアップ\n\n例:\n\n\n\nonAfter#\n\nパッケージング完了後の処理を行うコールバック関数。.tgz ファイルが生成された後に呼び出され、パッケージング成果物を処理するために使用されます。\n\n * パラメータ:\n   * gez: Gez - Gez インスタンス\n   * pkg: Record - package.json の内容\n   * file: Buffer - パッケージング後のファイル内容\n * 戻り値: Promise\n\n一般的な用途:\n\n * npm レジストリ（公開またはプライベート）への公開\n * 静的リソースサーバーへのアップロード\n * バージョン管理の実行\n * CI/CD プロセスのトリガー\n\n例:\n\n\n\n\n使用例#\n\n","routePath":"/ja/api/core/pack-config","lang":"ja","toc":[{"text":"型定義","id":"型定義","depth":2,"charIndex":212},{"text":"PackConfig","id":"packconfig-1","depth":3,"charIndex":-1},{"text":"enable","id":"enable","depth":4,"charIndex":234},{"text":"outputs","id":"outputs","depth":4,"charIndex":346},{"text":"packageJson","id":"packagejson","depth":4,"charIndex":558},{"text":"onBefore","id":"onbefore","depth":4,"charIndex":854},{"text":"onAfter","id":"onafter","depth":4,"charIndex":1087},{"text":"使用例","id":"使用例","depth":2,"charIndex":1400}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク パッケージング設定 API リファレンス","description":"Gez フレームワークの PackConfig 設定インターフェースについて詳しく説明します。パッケージングルール、出力設定、ライフサイクルフックを含み、開発者が標準化されたビルドプロセスを実現するのに役立ちます。","head":[["meta",{"property":"keywords","content":"Gez, PackConfig, パッケージング, ビルド設定, ライフサイクルフック, パッケージング設定, Web アプリケーションフレームワーク"}]]},"version":""},{"id":157,"title":"RenderContext","content":"Hello World\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()} ${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ja/api/core/render-context","lang":"ja","toc":[{"text":"型定義","id":"型定義","depth":2,"charIndex":-1},{"text":"ServerRenderHandle","id":"serverrenderhandle","depth":3,"charIndex":-1},{"text":"RenderFiles","id":"renderfiles","depth":3,"charIndex":-1},{"text":"ImportmapMode","id":"importmapmode","depth":3,"charIndex":-1},{"text":"インスタンスオプション","id":"インスタンスオプション","depth":2,"charIndex":-1},{"text":"base","id":"base","depth":4,"charIndex":-1},{"text":"entryName","id":"entryname","depth":4,"charIndex":-1},{"text":"params","id":"params","depth":4,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-1","depth":4,"charIndex":-1},{"text":"インスタンスプロパティ","id":"インスタンスプロパティ","depth":2,"charIndex":-1},{"text":"gez","id":"gez","depth":3,"charIndex":-1},{"text":"redirect","id":"redirect","depth":3,"charIndex":-1},{"text":"status","id":"status","depth":3,"charIndex":-1},{"text":"html","id":"html","depth":3,"charIndex":-1},{"text":"base","id":"base-1","depth":3,"charIndex":-1},{"text":"entryName","id":"entryname-1","depth":3,"charIndex":-1},{"text":"params","id":"params-1","depth":3,"charIndex":-1},{"text":"importMetaSet","id":"importmetaset","depth":3,"charIndex":-1},{"text":"files","id":"files","depth":3,"charIndex":-1},{"text":"importmapMode","id":"importmapmode-2","depth":3,"charIndex":-1},{"text":"インスタンスメソッド","id":"インスタンスメソッド","depth":2,"charIndex":-1},{"text":"serialize()","id":"serialize","depth":3,"charIndex":-1},{"text":"state()","id":"state","depth":3,"charIndex":-1},{"text":"commit()","id":"commit","depth":3,"charIndex":-1},{"text":"preload()","id":"preload","depth":3,"charIndex":-1},{"text":"css()","id":"css","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク レンダリングコンテキスト API リファレンス","description":"Gez フレームワークの RenderContext コアクラスの詳細説明。レンダリング制御、リソース管理、状態同期、ルーティング制御などの機能を提供し、開発者が効率的なサーバーサイドレンダリングを実現するのを支援します。","head":[["meta",{"property":"keywords","content":"Gez, RenderContext, SSR, サーバーサイドレンダリング, レンダリングコンテキスト, 状態同期, リソース管理, Web アプリケーションフレームワーク"}]]},"version":""},{"id":158,"title":"コンポーネント共有からネイティブモジュール化へ：Gezマイクロフロントエンドフレームワークの進化の道","content":"#\n\n\nプロジェクト背景#\n\n過去数年間、マイクロフロントエンドアーキテクチャは正しい道を模索してきました。しかし、私たちが目にしてきたのは、理想的なマイクロフロントエンドの世界を模倣するた\nめの複雑な技術的解決策でした。これらの解決策は、重いパフォーマンス負荷をもたらし、シンプルな開発を複雑にし、標準的なプロセスを難解にしました。\n\n\n従来の解決策の限界#\n\nマイクロフロントエンドアーキテクチャの実践において、従来の解決策の多くの制限を痛感しました：\n\n * パフォーマンスの低下：ランタイムでの依存関係注入、JSサンドボックスのプロキシ、すべての操作が貴重なパフォーマンスを消耗します\n * 脆弱な隔離：手動で作成されたサンドボックス環境は、ブラウザのネイティブな隔離能力には到底及びません\n * ビルドの複雑さ：依存関係を処理するために、ビルドツールを魔改造しなければならず、シンプルなプロジェクトが保守困難になります\n * カスタマイズされたルール：特殊なデプロイ戦略、ランタイム処理により、すべてのステップが現代の開発標準プロセスから逸脱します\n * エコシステムの制限：フレームワークの結合、カスタムAPIにより、技術選定が特定のエコシステムに縛られます\n\nこれらの問題は、2019年のある企業向けプロジェクトで特に顕著でした。当時、大規模な製品が十数個の独立した業務サブシステムに分割され、これらのサブシステムは共通\nの基本コンポーネントと業務コンポーネントを共有する必要がありました。最初に採用されたnpmパッケージベースのコンポーネント共有ソリューションは、共有コンポーネン\nトが更新された際に、そのコンポーネントに依存するすべてのサブシステムが完全なビルドとデプロイプロセスを経なければならないという深刻な保守効率の問題を露呈しました\n。\n\n\n技術的進化#\n\n\nv1.0：リモートコンポーネントの探求#\n\nコンポーネント共有の効率問題を解決するため、Gez\nv1.0ではHTTPプロトコルに基づくRemoteViewコンポーネントメカニズムを導入しました。このソリューションは、ランタイムでの動的リクエストにより、サー\nビス間のコードをオンデマンドで組み立てることで、ビルド依存チェーンの長さの問題を解決しました。しかし、標準化されたランタイム通信メカニズムが欠如していたため、サ\nービス間の状態同期とイベント伝達には依然として効率のボトルネックが存在しました。\n\n\nv2.0：モジュールフェデレーションの試み#\n\nv2.0バージョンでは、Webpack 5.0のモジュールフェデレーション（Module\nFederation）技術を採用しました。この技術は、統一されたモジュールロードメカニズムとランタイムコンテナにより、サービス間の協調効率を大幅に向上させました\n。しかし、大規模な実践において、モジュールフェデレーションの閉鎖的な実装メカニズムは新たな課題をもたらしました：正確な依存関係バージョン管理が難しく、特に複数の\nサービスの共有依存関係を統一する際に、バージョン衝突やランタイム例外が頻繁に発生しました。\n\n\nESM新時代の到来#\n\nv3.0バージョンの計画において、私たちはフロントエンドエコシステムの発展トレンドを深く観察し、ブラウザのネイティブ能力の進化がマイクロフロントエンドアーキテク\nチャに新たな可能性をもたらしていることを発見しました：\n\n\n標準化されたモジュールシステム#\n\n主要なブラウザがES Modulesを全面的にサポートし、Import\nMaps仕様が成熟するにつれ、フロントエンド開発は真のモジュール化時代を迎えました。Can I Useの統計データによると、現在の主要ブラウザ（Chrome\n>= 89、Edge >= 89、Firefox >= 108、Safari >=\n16.4）のESMネイティブサポート率は93.5%に達しており、これにより以下の利点が得られます：\n\n * 依存関係管理の標準化：Import Mapsは、ブラウザレベルでモジュール依存関係を解決する能力を提供し、複雑なランタイム注入を必要としません\n * リソースロードの最適化：ブラウザのネイティブなモジュールキャッシュメカニズムにより、リソースロード効率が大幅に向上します\n * ビルドプロセスの簡素化：ESMベースの開発モードにより、開発環境と本番環境のビルドプロセスがより一貫性を持ちます\n\n同時に、互換モードのサポート（Chrome >= 87、Edge >= 88、Firefox >= 78、Safari >=\n14）により、ブラウザカバレッジを96.81%までさらに向上させることができ、高性能を維持しながらも旧版ブラウザのサポートを犠牲にしません。\n\n\nパフォーマンスと隔離のブレークスルー#\n\nネイティブモジュールシステムがもたらすのは標準化だけでなく、パフォーマンスと隔離性の質的向上です：\n\n * ゼロランタイムオーバーヘッド：従来のマイクロフロントエンドソリューションにおけるJavaScriptサンドボックスプロキシとランタイム注入に別れを告げます\n * 信頼性の高い隔離メカニズム：ESMの厳格なモジュールスコープは、最も信頼性の高い隔離能力を自然に提供します\n * 正確な依存関係管理：静的インポート分析により、依存関係がより明確になり、バージョンコントロールがより正確になります\n\n\nビルドツールの選択#\n\n技術ソリューションの実装において、ビルドツールの選択は重要な決定ポイントです。約1年間の技術調査と実践を経て、私たちの選択は以下のように進化しました：\n\n 1. Viteの探求\n    \n    * 利点：ESMベースの開発サーバーにより、極めて優れた開発体験を提供します\n    * 課題：開発環境と本番環境のビルドの差異により、一定の不確実性が生じます\n\n 2. Rspackの確立\n    \n    * パフォーマンスの利点：Rustベースの高性能コンパイルにより、ビルド速度が大幅に向上します\n    * エコシステムのサポート：Webpackエコシステムとの高い互換性により、移行コストが低減されます\n    * ESMサポート：Rslibプロジェクトの実践を通じて、ESMビルドにおける信頼性が検証されました\n\nこの決定により、開発体験を維持しながら、より安定した本番環境サポートを得ることができました。ESMとRspackの組み合わせに基づき、最終的に高性能で低侵入性の\nマイクロフロントエンドソリューションを構築しました。\n\n\n将来の展望#\n\n今後の発展計画において、Gezフレームワークは以下の3つの方向に重点を置きます：\n\n\nImport Mapsの深度最適化#\n\n * 動的依存関係管理：ランタイムでの依存関係バージョンのインテリジェントなスケジューリングを実現し、複数アプリケーション間の依存関係衝突を解決します\n * プリロード戦略：ルート分析に基づくインテリジェントなプリロードにより、リソースロード効率を向上させます\n * ビルド最適化：最適なImport Maps設定を自動生成し、開発者の手動設定コストを削減します\n\n\nフレームワークに依存しないルーティングソリューション#\n\n * 統一ルーティング抽象化：フレームワークに依存しないルーティングインターフェースを設計し、Vue、Reactなどの主要フレームワークをサポートします\n * マイクロアプリケーションルーティング：アプリケーション間のルーティング連動を実現し、URLとアプリケーション状態の一貫性を維持します\n * ルーティングミドルウェア：拡張可能なミドルウェアメカニズムを提供し、権限制御、ページ遷移などの機能をサポートします\n\n\nクロスフレームワーク通信のベストプラクティス#\n\n * サンプルアプリケーション：Vue、React、Preactなどの主要フレームワークをカバーする完全なクロスフレームワーク通信サンプルを提供します\n * 状態同期：ESMベースの軽量な状態共有ソリューションを実装します\n * イベントバス：標準化されたイベント通信メカニズムにより、アプリケーション間の疎結合通信をサポートします\n\nこれらの最適化と拡張を通じて、Gezがより完成度が高く、使いやすいマイクロフロントエンドソリューションとなり、開発者により優れた開発体験と高い開発効率を提供する\nことを期待しています。","routePath":"/ja/blog/birth-of-gez","lang":"ja","toc":[{"text":"プロジェクト背景","id":"プロジェクト背景","depth":2,"charIndex":3},{"text":"従来の解決策の限界","id":"従来の解決策の限界","depth":3,"charIndex":169},{"text":"技術的進化","id":"技術的進化","depth":2,"charIndex":783},{"text":"v1.0：リモートコンポーネントの探求","id":"v10リモートコンポーネントの探求","depth":3,"charIndex":792},{"text":"v2.0：モジュールフェデレーションの試み","id":"v20モジュールフェデレーションの試み","depth":3,"charIndex":1045},{"text":"ESM新時代の到来","id":"esm新時代の到来","depth":2,"charIndex":1324},{"text":"標準化されたモジュールシステム","id":"標準化されたモジュールシステム","depth":3,"charIndex":1447},{"text":"パフォーマンスと隔離のブレークスルー","id":"パフォーマンスと隔離のブレークスルー","depth":3,"charIndex":2009},{"text":"ビルドツールの選択","id":"ビルドツールの選択","depth":3,"charIndex":2282},{"text":"将来の展望","id":"将来の展望","depth":2,"charIndex":2766},{"text":"Import Mapsの深度最適化","id":"import-mapsの深度最適化","depth":3,"charIndex":2817},{"text":"フレームワークに依存しないルーティングソリューション","id":"フレームワークに依存しないルーティングソリューション","depth":3,"charIndex":3021},{"text":"クロスフレームワーク通信のベストプラクティス","id":"クロスフレームワーク通信のベストプラクティス","depth":3,"charIndex":3260}],"domain":"","frontmatter":{"titleSuffix":"マイクロフロントエンドの課題からESM革新へ：Gezフレームワークの進化の道","description":"Gezフレームワークが従来のマイクロフロントエンドアーキテクチャの課題からESMベースの革新へと進化した過程を深く探り、パフォーマンス最適化、依存関係管理、ビルドツール選定などの技術的実践経験を共有します。","head":[["meta",{"property":"keywords","content":"Gez, マイクロフロントエンドフレームワーク, ESM, Import Maps, Rspack, モジュールフェデレーション, 依存関係管理, パフォーマンス最適化, 技術進化, サーバーサイドレンダリング"}]],"sidebar":false},"version":""},{"id":159,"title":"チームブログ","content":"#\n\nGez チームの技術ブログへようこそ！ここでは、フレームワーク開発プロセスにおける経験、技術革新、ベストプラクティスを共有します。\n\n\n最新記事#\n\n * 2025-02-25 コンポーネント共有からネイティブモジュール化へ：Gez マイクロフロントエンドフレームワークの進化の軌跡\n   \n   > Gez フレームワークが従来のコンポーネント共有から ESM\n   > ベースのネイティブモジュール化へと進化した過程を探り、パフォーマンス最適化、依存関係管理、ビルドツール選定などの技術的実践経験を共有します。","routePath":"/ja/blog/","lang":"ja","toc":[{"text":"最新記事","id":"最新記事","depth":2,"charIndex":70}],"domain":"","frontmatter":{"titleSuffix":"Gez チームブログ","description":"Gez チームの技術ブログ。フレームワーク開発の経験、ベストプラクティス、技術革新を共有します。","head":[["meta",{"property":"keywords","content":"Gez, チームブログ, 技術共有, ベストプラクティス, 開発経験"}]],"sidebar":false},"version":""},{"id":160,"title":"パスエイリアス","content":"#\n\nパスエイリアス（Path\nAlias）は、モジュールインポートパスをマッピングするメカニズムで、開発者が完全なモジュールパスの代わりに短くて意味のある識別子を使用できるようにします。Ge\nz では、パスエイリアスメカニズムには以下の利点があります：\n\n * インポートパスの簡略化：冗長な相対パスの代わりに意味のあるエイリアスを使用し、コードの可読性を向上させます\n * 深いネストの回避：../../../../ のような多階層ディレクトリ参照による保守の困難さを解消します\n * 型安全性：TypeScript の型システムと完全に統合され、コード補完と型チェックを提供します\n * モジュール解決の最適化：事前定義されたパスマッピングにより、モジュール解決のパフォーマンスを向上させます\n\n\nデフォルトのエイリアスメカニズム#\n\nGez はサービス名（Service Name）に基づく自動エイリアスメカニズムを採用しており、この設定より優れた設計には以下の特徴があります：\n\n * 自動設定：package.json の name フィールドに基づいてエイリアスを自動生成し、手動設定は不要です\n * 統一された規約：すべてのサービスモジュールが一貫した命名と参照規約に従うことを保証します\n * 型サポート：npm run build:dts コマンドと連携し、型宣言ファイルを自動生成し、サービス間の型推論を実現します\n * 予測可能性：サービス名からモジュールの参照パスを推測できるため、保守コストを低減します\n\n\n設定説明#\n\n\npackage.json の設定#\n\npackage.json では、name フィールドでサービスの名前を定義します。この名前はサービスのデフォルトのエイリアスプレフィックスとして使用されます：\n\n\n\n\ntsconfig.json の設定#\n\nTypeScript がエイリアスパスを正しく解決できるようにするため、tsconfig.json で paths マッピングを設定する必要があります：\n\n\n\n\n使用例#\n\n\nサービス内部モジュールのインポート#\n\n\n\n\n他のサービスモジュールのインポート#\n\n\n\nベストプラクティス\n * 相対パスではなくエイリアスパスを優先して使用します\n * エイリアスパスの意味と一貫性を保ちます\n * エイリアスパスで過剰なディレクトリ階層を使用しないようにします\n\n\n\n\nサービス間のインポート#\n\nモジュールリンク（Module Link）を設定すると、他のサービスのモジュールを同じ方法でインポートできます：\n\n\n\n\nカスタムエイリアス#\n\nサードパーティパッケージや特殊なシナリオでは、Gez 設定ファイルでカスタムエイリアスを設定できます：\n\n\n\n注意事項\n 1. ビジネスモジュールでは、プロジェクトの一貫性を保つために常にデフォルトのエイリアスメカニズムを使用することを推奨します\n 2. カスタムエイリアスは、主にサードパーティパッケージの特殊なニーズや開発体験の最適化に使用します\n 3. カスタムエイリアスの過剰使用は、コードの保守性やビルドの最適化に影響を与える可能性があります","routePath":"/ja/guide/essentials/alias","lang":"ja","toc":[{"text":"デフォルトのエイリアスメカニズム","id":"デフォルトのエイリアスメカニズム","depth":2,"charIndex":351},{"text":"設定説明","id":"設定説明","depth":2,"charIndex":667},{"text":"package.json の設定","id":"packagejson-の設定","depth":3,"charIndex":675},{"text":"tsconfig.json の設定","id":"tsconfigjson-の設定","depth":3,"charIndex":778},{"text":"使用例","id":"使用例","depth":2,"charIndex":879},{"text":"サービス内部モジュールのインポート","id":"サービス内部モジュールのインポート","depth":3,"charIndex":886},{"text":"他のサービスモジュールのインポート","id":"他のサービスモジュールのインポート","depth":3,"charIndex":909},{"text":"サービス間のインポート","id":"サービス間のインポート","depth":3,"charIndex":1032},{"text":"カスタムエイリアス","id":"カスタムエイリアス","depth":3,"charIndex":1107}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク モジュールインポートパスマッピングガイド","description":"Gez フレームワークのパスエイリアスメカニズムについて詳しく説明します。インポートパスの簡略化、深いネストの回避、型安全性、モジュール解決の最適化などの機能を紹介し、開発者がコードの保守性を向上させるのに役立ちます。","head":[["meta",{"property":"keywords","content":"Gez, パスエイリアス, Path Alias, TypeScript, モジュールインポート, パスマッピング, コード保守性"}]]},"version":""},{"id":161,"title":"ベースパス","content":"#\n\nベースパス（Base Path）とは、アプリケーション内の静的リソース（JavaScript、CSS、画像など）のアクセスパスのプレフィックスを指します。Gez\nでは、以下のシナリオにおいてベースパスの適切な設定が重要です：\n\n * マルチ環境展開：開発環境、テスト環境、本番環境など、異なる環境でのリソースアクセスをサポート\n * マルチリージョン展開：異なる地域や国のクラスタ展開ニーズに対応\n * CDN配信：静的リソースのグローバル配信と高速化を実現\n\n\nデフォルトパスメカニズム#\n\nGez は、サービス名に基づいた自動パス生成メカニズムを採用しています。デフォルトでは、フレームワークはプロジェクトの package.json 内の name\nフィールドを読み取り、静的リソースのベースパスを生成します：/your-app-name/。\n\n\n\nこの設定より設計の利点は以下の通りです：\n\n * 一貫性：すべての静的リソースが統一されたアクセスパスを使用することを保証\n * 予測可能性：package.json の name フィールドを通じてリソースのアクセスパスを推測可能\n * 保守性：追加の設定が不要で、保守コストを低減\n\n\n動的パス設定#\n\n実際のプロジェクトでは、同じコードを異なる環境や地域に展開する必要がよくあります。Gez\nは動的ベースパスのサポートを提供しており、アプリケーションが異なる展開シナリオに適応できるようにします。\n\n\n使用シナリオ#\n\nサブディレクトリ展開#\n\n\n\n独立ドメイン展開#\n\n\n\n\n設定方法#\n\ngez.render() メソッドの base パラメータを使用して、リクエストコンテキストに基づいてベースパスを動的に設定できます：\n\n","routePath":"/ja/guide/essentials/base-path","lang":"ja","toc":[{"text":"デフォルトパスメカニズム","id":"デフォルトパスメカニズム","depth":2,"charIndex":234},{"text":"動的パス設定","id":"動的パス設定","depth":2,"charIndex":525},{"text":"使用シナリオ","id":"使用シナリオ","depth":3,"charIndex":634},{"text":"サブディレクトリ展開","id":"サブディレクトリ展開","depth":4,"charIndex":643},{"text":"独立ドメイン展開","id":"独立ドメイン展開","depth":4,"charIndex":658},{"text":"設定方法","id":"設定方法","depth":3,"charIndex":672}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク静的リソースパス設定ガイド","description":"Gez フレームワークのベースパス設定について詳しく説明します。マルチ環境展開、CDN配信、リソースアクセスパス設定などを含め、開発者が柔軟な静的リソース管理を実現するための手助けをします。","head":[["meta",{"property":"keywords","content":"Gez, ベースパス, Base Path, CDN, 静的リソース, マルチ環境展開, リソース管理"}]]},"version":""},{"id":162,"title":"クライアントサイドレンダリング","content":"\n${rc.importmap()} // インポートマップ ${rc.moduleEntry()} // エントリーモジュール\n${rc.modulePreload()} // モジュールのプリロード","routePath":"/ja/guide/essentials/csr","lang":"ja","toc":[{"text":"使用シナリオ","id":"使用シナリオ","depth":2,"charIndex":-1},{"text":"設定説明","id":"設定説明","depth":2,"charIndex":-1},{"text":"HTML テンプレート設定","id":"html-テンプレート設定","depth":3,"charIndex":-1},{"text":"静的 HTML 生成","id":"静的-html-生成","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワークのクライアントサイドレンダリング実装ガイド","description":"Gez フレームワークのクライアントサイドレンダリングメカニズムについて詳しく説明します。静的ビルド、デプロイ戦略、ベストプラクティスを含め、サーバーレス環境で効率的なフロントエンドレンダリングを実現するための開発者向けガイドです。","head":[["meta",{"property":"keywords","content":"Gez, クライアントサイドレンダリング, CSR, 静的ビルド, フロントエンドレンダリング, サーバーレスデプロイ, パフォーマンス最適化"}]]},"version":""},{"id":163,"title":"モジュールリンク","content":"#\n\nGez フレームワークは、サービス間のコード共有と依存関係を管理するための完全なモジュールリンクメカニズムを提供します。このメカニズムは\nESM（ECMAScript\nModule）仕様に基づいて実装されており、ソースコードレベルのモジュールエクスポートとインポート、および完全な依存関係管理機能をサポートしています。\n\n\nコアコンセプト#\n\nモジュールエクスポート#\n\nモジュールエクスポートは、サービス内の特定のコードユニット（コンポーネント、ユーティリティ関数など）を ESM\n形式で外部に公開するプロセスです。以下の2種類のエクスポートタイプをサポートします：\n\n * ソースコードエクスポート：プロジェクト内のソースコードファイルを直接エクスポート\n * 依存関係エクスポート：プロジェクトで使用するサードパーティの依存パッケージをエクスポート\n\nモジュールインポート#\n\nモジュールインポートは、他のサービスがエクスポートしたコードユニットをサービス内で参照するプロセスです。以下の複数のインストール方法をサポートします：\n\n * ソースコードインストール：開発環境に適しており、リアルタイムの変更とホットリロードをサポート\n * パッケージインストール：本番環境に適しており、ビルド成果物を直接使用\n\n\nプリロードメカニズム#\n\nサービスのパフォーマンスを最適化するため、Gez はインテリジェントなモジュールプリロードメカニズムを実装しています：\n\n 1. 依存関係分析\n    \n    * ビルド時にコンポーネント間の依存関係を分析\n    * クリティカルパス上のコアモジュールを識別\n    * モジュールのロード優先順位を決定\n\n 2. ロード戦略\n    \n    * 即時ロード：クリティカルパス上のコアモジュール\n    * 遅延ロード：非クリティカルな機能モジュール\n    * オンデマンドロード：条件付きレンダリングのモジュール\n\n 3. リソース最適化\n    \n    * インテリジェントなコード分割戦略\n    * モジュールレベルのキャッシュ管理\n    * オンデマンドでのコンパイルとバンドル\n\n\nモジュールエクスポート#\n\n\n設定説明#\n\nentry.node.ts でエクスポートするモジュールを設定します：\n\n\n\nエクスポート設定は以下の2種類をサポートします：\n\n * root:*：ソースコードファイルをエクスポート、パスはプロジェクトルートディレクトリからの相対パス\n * npm:*：サードパーティの依存関係をエクスポート、パッケージ名を直接指定\n\n\nモジュールインポート#\n\n\n設定説明#\n\nentry.node.ts でインポートするモジュールを設定します：\n\n\n\n設定項目の説明：\n\n 1. imports：リモートモジュールのローカルパスを設定\n    \n    * ソースコードインストール：ビルド成果物ディレクトリ（dist）を指定\n    * パッケージインストール：パッケージディレクトリを直接指定\n\n 2. externals：外部依存関係を設定\n    \n    * リモートモジュール内の依存関係を共有\n    * 同じ依存関係の重複バンドルを回避\n    * 複数のモジュール間での依存関係共有をサポート\n\n\nインストール方法#\n\nソースコードインストール#\n\n開発環境に適しており、リアルタイムの変更とホットリロードをサポートします。\n\n 1. Workspace 方式 Monorepo プロジェクトでの使用を推奨：\n\n\n\n 2. Link 方式 ローカル開発デバッグに使用：\n\n\n\nパッケージインストール#\n\n本番環境に適しており、ビルド成果物を直接使用します。\n\n 1. NPM Registry npm registry 経由でインストール：\n\n\n\n 2. 静的サーバー HTTP/HTTPS プロトコル経由でインストール：\n\n\n\n\nパッケージビルド#\n\n\n設定説明#\n\nentry.node.ts でビルドオプションを設定します：\n\n\n\n\nビルド成果物#\n\n\n\n\nリリースプロセス#\n\n\n\n\nベストプラクティス#\n\n\n開発環境設定#\n\n * 依存関係管理\n   \n   * Workspace または Link 方式で依存関係をインストール\n   * 依存関係のバージョンを統一管理\n   * 同じ依存関係の重複インストールを回避\n\n * 開発体験\n   \n   * ホットリロード機能を有効化\n   * 適切なプリロード戦略を設定\n   * ビルド速度を最適化\n\n\n本番環境設定#\n\n * デプロイ戦略\n   \n   * NPM Registry または静的サーバーを使用\n   * ビルド成果物の完全性を確保\n   * グレーリリースメカニズムを実施\n\n * パフォーマンス最適化\n   \n   * リソースプリロードを適切に設定\n   * モジュールロード順序を最適化\n   * 効果的なキャッシュ戦略を実施\n\n\nバージョン管理#\n\n * バージョン規約\n   \n   * セマンティックバージョニングに従う\n   * 詳細な更新履歴を維持\n   * バージョン互換性テストを実施\n\n * 依存関係更新\n   \n   * 依存パッケージを適時更新\n   * 定期的にセキュリティ監査を実施\n   * 依存関係のバージョン一貫性を維持\n\n","routePath":"/ja/guide/essentials/module-link","lang":"ja","toc":[{"text":"コアコンセプト","id":"コアコンセプト","depth":3,"charIndex":164},{"text":"モジュールエクスポート","id":"モジュールエクスポート","depth":4,"charIndex":174},{"text":"モジュールインポート","id":"モジュールインポート","depth":4,"charIndex":381},{"text":"プリロードメカニズム","id":"プリロードメカニズム","depth":3,"charIndex":561},{"text":"モジュールエクスポート","id":"モジュールエクスポート-1","depth":2,"charIndex":927},{"text":"設定説明","id":"設定説明","depth":3,"charIndex":942},{"text":"モジュールインポート","id":"モジュールインポート-1","depth":2,"charIndex":1111},{"text":"設定説明","id":"設定説明-1","depth":3,"charIndex":1125},{"text":"インストール方法","id":"インストール方法","depth":3,"charIndex":1402},{"text":"ソースコードインストール","id":"ソースコードインストール","depth":4,"charIndex":1413},{"text":"パッケージインストール","id":"パッケージインストール","depth":4,"charIndex":1541},{"text":"パッケージビルド","id":"パッケージビルド","depth":2,"charIndex":1669},{"text":"設定説明","id":"設定説明-2","depth":3,"charIndex":1681},{"text":"ビルド成果物","id":"ビルド成果物","depth":3,"charIndex":1723},{"text":"リリースプロセス","id":"リリースプロセス","depth":3,"charIndex":1735},{"text":"ベストプラクティス","id":"ベストプラクティス","depth":2,"charIndex":1749},{"text":"開発環境設定","id":"開発環境設定","depth":3,"charIndex":1762},{"text":"本番環境設定","id":"本番環境設定","depth":3,"charIndex":1937},{"text":"バージョン管理","id":"バージョン管理","depth":3,"charIndex":2113}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワークのサービス間コード共有メカニズム","description":"Gez フレームワークのモジュールリンクメカニズムについて詳しく説明します。サービス間のコード共有、依存関係管理、ESM 仕様の実装などを含み、開発者が効率的なマイクロフロントエンドアプリケーションを構築するのに役立ちます。","head":[["meta",{"property":"keywords","content":"Gez, モジュールリンク, Module Link, ESM, コード共有, 依存関係管理, マイクロフロントエンド"}]]},"version":""},{"id":164,"title":"レンダリングコンテキスト","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ja/guide/essentials/render-context","lang":"ja","toc":[{"text":"使用方法","id":"使用方法","depth":2,"charIndex":-1},{"text":"主な機能","id":"主な機能","depth":2,"charIndex":-1},{"text":"依存関係収集","id":"依存関係収集","depth":3,"charIndex":-1},{"text":"オンデマンド収集","id":"オンデマンド収集","depth":4,"charIndex":-1},{"text":"自動化処理","id":"自動化処理","depth":4,"charIndex":-1},{"text":"パフォーマンス最適化","id":"パフォーマンス最適化","depth":4,"charIndex":-1},{"text":"リソース注入","id":"リソース注入","depth":3,"charIndex":-1},{"text":"リソース注入順序","id":"リソース注入順序","depth":3,"charIndex":-1},{"text":"完全なレンダリングプロセス","id":"完全なレンダリングプロセス","depth":2,"charIndex":-1},{"text":"高度な機能","id":"高度な機能","depth":2,"charIndex":-1},{"text":"ベースパス設定","id":"ベースパス設定","depth":3,"charIndex":-1},{"text":"インポートマッピングモード","id":"インポートマッピングモード","depth":3,"charIndex":-1},{"text":"エントリー関数設定","id":"エントリー関数設定","depth":3,"charIndex":-1},{"text":"ベストプラクティス","id":"ベストプラクティス","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワークのサーバーサイドレンダリングコアメカニズム","description":"Gez フレームワークのレンダリングコンテキスト（RenderContext）メカニズムについて詳しく説明します。リソース管理、HTML生成、ESMモジュールシステムを含め、開発者がサーバーサイドレンダリング機能を理解し使用するのに役立ちます。","head":[["meta",{"property":"keywords","content":"Gez, レンダリングコンテキスト, RenderContext, SSR, サーバーサイドレンダリング, ESM, リソース管理"}]]},"version":""},{"id":165,"title":"Rspack","content":"#\n\nGez は Rspack ビルドシステムを基盤として構築されており、Rspack の高性能なビルド能力を最大限に活用しています。このドキュメントでは、Gez\nフレームワークにおける Rspack の位置付けとコア機能について説明します。\n\n\n特徴#\n\nRspack は Gez フレームワークのコアビルドシステムであり、以下の主要な特徴を提供します：\n\n * 高性能ビルド：Rust で実装されたビルドエンジンにより、高速なコンパイル性能を実現し、大規模プロジェクトのビルド速度を大幅に向上させます\n * 開発体験の最適化：ホットリロード（HMR）やインクリメンタルコンパイルなどのモダンな開発機能をサポートし、スムーズな開発体験を提供します\n * マルチ環境ビルド：クライアント（client）、サーバー（server）、Node.js（node）環境を統一したビルド設定でサポートし、マルチプラットフ\n   ォーム開発のプロセスを簡素化します\n * リソース最適化：コード分割、Tree Shaking、リソース圧縮などの機能をサポートし、リソース処理と最適化の能力を内蔵しています\n\n\nアプリケーションのビルド#\n\nGez の Rspack ビルドシステムはモジュール化設計を採用しており、以下のコアモジュールで構成されています：\n\n\n@gez/rspack#\n\n基礎ビルドモジュールで、以下のコア機能を提供します：\n\n * 統一ビルド設定：標準化されたビルド設定管理を提供し、マルチ環境設定をサポートします\n * リソース処理：TypeScript、CSS、画像などのリソース処理能力を内蔵しています\n * ビルド最適化：コード分割、Tree Shaking などのパフォーマンス最適化機能を提供します\n * 開発サーバー：高性能な開発サーバーを統合し、HMR をサポートします\n\n\n@gez/rspack-vue#\n\nVue フレームワーク専用のビルドモジュールで、以下の機能を提供します：\n\n * Vue コンポーネントのコンパイル：Vue 2/3 コンポーネントの効率的なコンパイルをサポートします\n * SSR 最適化：サーバーサイドレンダリング（SSR）シナリオ向けの特定の最適化を提供します\n * 開発機能の強化：Vue 開発環境向けの特定の機能強化を提供します\n\n\nビルドプロセス#\n\nGez のビルドプロセスは、主に以下の段階に分かれています：\n\n 1. 設定の初期化\n    \n    * プロジェクト設定の読み込み\n    * デフォルト設定とユーザー設定のマージ\n    * 環境変数に基づく設定の調整\n\n 2. リソースのコンパイル\n    \n    * ソースコードの依存関係の解析\n    * TypeScript、CSS などのリソースの変換\n    * モジュールのインポート/エクスポートの処理\n\n 3. 最適化処理\n    \n    * コード分割の実行\n    * Tree Shaking の適用\n    * コードとリソースの圧縮\n\n 4. 出力の生成\n    \n    * ターゲットファイルの生成\n    * リソースマップの出力\n    * ビルドレポートの生成\n\n\nベストプラクティス#\n\n\n開発環境の最適化#\n\n * インクリメンタルコンパイルの設定：cache オプションを適切に設定し、キャッシュを活用してビルド速度を向上させます\n * HMR の最適化：ホットリロードの範囲を適切に設定し、不要なモジュールの更新を避けます\n * リソース処理の最適化：適切な loader 設定を使用し、重複処理を回避します\n\n\n本番環境の最適化#\n\n * コード分割戦略：splitChunks を適切に設定し、リソースのロードを最適化します\n * リソース圧縮：適切な圧縮設定を有効にし、ビルド時間と成果物のサイズのバランスを取ります\n * キャッシュの最適化：コンテンツハッシュと長期キャッシュ戦略を活用し、ロードパフォーマンスを向上させます\n\n\n設定例#\n\n\n\nTIP\n\nより詳細な API 説明と設定オプションについては、Rspack API ドキュメントを参照してください。","routePath":"/ja/guide/essentials/rspack","lang":"ja","toc":[{"text":"特徴","id":"特徴","depth":2,"charIndex":123},{"text":"アプリケーションのビルド","id":"アプリケーションのビルド","depth":2,"charIndex":498},{"text":"@gez/rspack","id":"gezrspack","depth":3,"charIndex":573},{"text":"@gez/rspack-vue","id":"gezrspack-vue","depth":3,"charIndex":798},{"text":"ビルドプロセス","id":"ビルドプロセス","depth":2,"charIndex":996},{"text":"ベストプラクティス","id":"ベストプラクティス","depth":2,"charIndex":1364},{"text":"開発環境の最適化","id":"開発環境の最適化","depth":3,"charIndex":1377},{"text":"本番環境の最適化","id":"本番環境の最適化","depth":3,"charIndex":1542},{"text":"設定例","id":"設定例","depth":2,"charIndex":1704}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワークの高性能ビルドエンジン","description":"Gez フレームワークの Rspack ビルドシステムについて詳しく解説します。高性能コンパイル、マルチ環境ビルド、リソース最適化などのコア機能を紹介し、開発者が効率的で信頼性の高いモダンな Web アプリケーションを構築するのを支援します。","head":[["meta",{"property":"keywords","content":"Gez, Rspack, ビルドシステム, 高性能コンパイル, ホットリロード, マルチ環境ビルド, Tree Shaking, コード分割, SSR, リソース最適化, 開発効率, ビルドツール"}]]},"version":""},{"id":166,"title":"標準規約","content":"#\n\nGez はモダンな SSR フレームワークで、標準化されたプロジェクト構造とパス解決メカニズムを採用しており、開発環境と本番環境での一貫性と保守性を確保します。\n\n\nプロジェクト構造規約#\n\n\n標準ディレクトリ構造#\n\n\n\n拡張知識\n * gez.name は package.json の name フィールドから取得されます\n * dist/package.json はルートディレクトリの package.json から生成されます\n * packs.enable を true に設定すると、dist ディレクトリがアーカイブされます\n\n\nエントリーファイル規約#\n\n\nentry.client.ts#\n\nクライアントサイドのエントリーファイルは以下の役割を担います：\n\n * アプリケーションの初期化：クライアントアプリケーションの基本設定を構成\n * ルーティング管理：クライアントサイドのルーティングとナビゲーションを処理\n * 状態管理：クライアントサイドの状態の保存と更新を実装\n * インタラクション処理：ユーザーイベントとUIインタラクションを管理\n\n\nentry.server.ts#\n\nサーバーサイドのエントリーファイルは以下の役割を担います：\n\n * サーバーサイドレンダリング：SSR レンダリングプロセスを実行\n * HTML 生成：初期ページ構造を構築\n * データプリフェッチ：サーバーサイドのデータ取得を処理\n * 状態注入：サーバーサイドの状態をクライアントに渡す\n * SEO 最適化：ページの検索エンジン最適化を確保\n\n\nentry.node.ts#\n\nNode.js サーバーのエントリーファイルは以下の役割を担います：\n\n * サーバー設定：HTTP サーバーのパラメータを設定\n * ルーティング処理：サーバーサイドのルーティングルールを管理\n * ミドルウェア統合：サーバーミドルウェアを構成\n * 環境管理：環境変数と設定を処理\n * リクエスト応答：HTTP リクエストとレスポンスを処理\n\n\n設定ファイル規約#\n\n\npackage.json#\n\n\n\n\ntsconfig.json#\n\n","routePath":"/ja/guide/essentials/std","lang":"ja","toc":[{"text":"プロジェクト構造規約","id":"プロジェクト構造規約","depth":2,"charIndex":85},{"text":"標準ディレクトリ構造","id":"標準ディレクトリ構造","depth":3,"charIndex":99},{"text":"エントリーファイル規約","id":"エントリーファイル規約","depth":2,"charIndex":276},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":291},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":490},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":685},{"text":"設定ファイル規約","id":"設定ファイル規約","depth":2,"charIndex":877},{"text":"package.json","id":"packagejson","depth":3,"charIndex":889},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":907}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク プロジェクト構造と規約ガイド","description":"Gez フレームワークの標準プロジェクト構造、エントリーファイル規約、設定ファイル規約について詳しく説明し、開発者が規範的で保守可能な SSR アプリケーションを構築するのを支援します。","head":[["meta",{"property":"keywords","content":"Gez, プロジェクト構造, エントリーファイル, 設定規約, SSRフレームワーク, TypeScript, プロジェクト規約, 開発標準"}]]},"version":""},{"id":167,"title":"HTML","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ja/guide/frameworks/html","lang":"ja","toc":[{"text":"プロジェクト構造","id":"プロジェクト構造","depth":2,"charIndex":-1},{"text":"プロジェクト設定","id":"プロジェクト設定","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"ソースコード構造","id":"ソースコード構造","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"プロジェクトの実行","id":"プロジェクトの実行","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク HTML SSR アプリケーション例","description":"Gez を使用した HTML SSR アプリケーションをゼロから構築する方法を紹介します。プロジェクトの初期化、HTML 設定、エントリーファイルの設定など、フレームワークの基本的な使い方を実例で示します。","head":[["meta",{"property":"keywords","content":"Gez, HTML, SSRアプリケーション, TypeScript設定, プロジェクト初期化, サーバーサイドレンダリング, クライアントサイドインタラクション"}]]},"version":""},{"id":168,"title":"Preact+HTM","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ja/guide/frameworks/preact-htm","lang":"ja","toc":[{"text":"プロジェクト構造","id":"プロジェクト構造","depth":2,"charIndex":-1},{"text":"プロジェクト設定","id":"プロジェクト設定","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"ソースコード構造","id":"ソースコード構造","depth":2,"charIndex":-1},{"text":"app.ts","id":"appts","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"プロジェクトの実行","id":"プロジェクトの実行","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク Preact+HTM SSR アプリケーション例","description":"Gez を使用した Preact+HTM SSR アプリケーションをゼロから構築する方法を紹介します。プロジェクトの初期化、Preact の設定、エントリーファイルの設定など、フレームワークの基本的な使い方を実例を通して説明します。","head":[["meta",{"property":"keywords","content":"Gez, Preact, HTM, SSRアプリケーション, TypeScript設定, プロジェクト初期化, サーバーサイドレンダリング, クライアントサイドインタラクション"}]]},"version":""},{"id":169,"title":"Vue2","content":"${html} ${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ja/guide/frameworks/vue2","lang":"ja","toc":[{"text":"プロジェクト構造","id":"プロジェクト構造","depth":2,"charIndex":-1},{"text":"プロジェクト設定","id":"プロジェクト設定","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"ソースコード構造","id":"ソースコード構造","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"プロジェクトの実行","id":"プロジェクトの実行","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク Vue2 SSR アプリケーション例","description":"Gez を使用した Vue2 SSR アプリケーションをゼロから構築する方法を紹介します。プロジェクトの初期化、Vue2 の設定、エントリーファイルの設定など、フレームワークの基本的な使い方を実例を通して説明します。","head":[["meta",{"property":"keywords","content":"Gez, Vue2, SSRアプリケーション, TypeScript設定, プロジェクト初期化, サーバーサイドレンダリング, クライアントサイドインタラクション"}]]},"version":""},{"id":170,"title":"Vue3","content":"${html}\n${rc.importmap()} ${rc.moduleEntry()} ${rc.modulePreload()}","routePath":"/ja/guide/frameworks/vue3","lang":"ja","toc":[{"text":"プロジェクト構造","id":"プロジェクト構造","depth":2,"charIndex":-1},{"text":"プロジェクト設定","id":"プロジェクト設定","depth":2,"charIndex":-1},{"text":"package.json","id":"packagejson","depth":3,"charIndex":-1},{"text":"tsconfig.json","id":"tsconfigjson","depth":3,"charIndex":-1},{"text":"ソースコード構造","id":"ソースコード構造","depth":2,"charIndex":-1},{"text":"app.vue","id":"appvue","depth":3,"charIndex":-1},{"text":"create-app.ts","id":"create-appts","depth":3,"charIndex":-1},{"text":"entry.client.ts","id":"entryclientts","depth":3,"charIndex":-1},{"text":"entry.node.ts","id":"entrynodets","depth":3,"charIndex":-1},{"text":"entry.server.ts","id":"entryserverts","depth":3,"charIndex":-1},{"text":"プロジェクトの実行","id":"プロジェクトの実行","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク Vue3 SSR アプリケーション例","description":"Gez をベースにした Vue3 SSR アプリケーションをゼロから構築する方法を紹介します。プロジェクトの初期化、Vue3 の設定、エントリーファイルの設定など、フレームワークの基本的な使い方を実例を通して解説します。","head":[["meta",{"property":"keywords","content":"Gez, Vue3, SSRアプリケーション, TypeScript設定, プロジェクト初期化, サーバーサイドレンダリング, クライアントサイドインタラクション, コンポジションAPI"}]]},"version":""},{"id":171,"title":"環境要件","content":"#\n\nこのドキュメントでは、本フレームワークを使用するために必要な環境要件について説明します。Node.js 環境とブラウザ互換性について解説します。\n\n\nNode.js 環境#\n\nフレームワークは Node.js バージョン >= 22.6 を必要とします。これは主に TypeScript\nの型インポート（--experimental-strip-types フラグを使用）をサポートするためで、追加のコンパイル手順は不要です。\n\n\nブラウザ互換性#\n\nフレームワークはデフォルトで互換モードでビルドされ、より広範なブラウザをサポートします。ただし、完全なブラウザ互換性を実現するには、手動で\nes-module-shims 依存関係を追加する必要があります。\n\n\n互換モード（デフォルト）#\n\n * 🌐 Chrome：>= 87\n * 🔷 Edge：>= 88\n * 🦊 Firefox：>= 78\n * 🧭 Safari：>= 14\n\nCan I Use の統計データによると、互換モードでのブラウザカバレッジは 96.81% です。\n\n\nネイティブサポートモード#\n\n * 🌐 Chrome：>= 89\n * 🔷 Edge：>= 89\n * 🦊 Firefox：>= 108\n * 🧭 Safari：>= 16.4\n\nネイティブサポートモードには以下の利点があります：\n\n * ランタイムオーバーヘッドがゼロで、追加のモジュールローダーが不要\n * ブラウザがネイティブで解析するため、実行速度が速い\n * コード分割とオンデマンドロードの能力が向上\n\nCan I Use の統計データによると、互換モードでのブラウザカバレッジは 93.5% です。\n\n\n互換サポートの有効化#\n\n重要\n\nフレームワークはデフォルトで互換モードでビルドされますが、古いブラウザの完全なサポートを実現するには、プロジェクトに es-module-shims\n依存関係を追加する必要があります。\n\nHTML ファイルに以下のスクリプトを追加してください：\n\n\n\nベストプラクティス\n 1. 本番環境での推奨事項：\n    * es-module-shims を自社サーバーにデプロイする\n    * リソースのロードの安定性とアクセス速度を確保する\n    * 潜在的なセキュリティリスクを回避する\n 2. パフォーマンスの考慮事項：\n    * 互換モードではわずかなパフォーマンスオーバーヘッドが発生する\n    * ターゲットユーザーのブラウザ分布に基づいて有効化するかどうかを決定する","routePath":"/ja/guide/start/environment","lang":"ja","toc":[{"text":"Node.js 環境","id":"nodejs-環境","depth":2,"charIndex":77},{"text":"ブラウザ互換性","id":"ブラウザ互換性","depth":2,"charIndex":218},{"text":"互換モード（デフォルト）","id":"互換モードデフォルト","depth":3,"charIndex":334},{"text":"ネイティブサポートモード","id":"ネイティブサポートモード","depth":3,"charIndex":477},{"text":"互換サポートの有効化","id":"互換サポートの有効化","depth":3,"charIndex":740}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク互換性ガイド","description":"Gez フレームワークの環境要件について詳しく説明します。Node.js のバージョン要件やブラウザ互換性について解説し、開発者が正しく開発環境を設定できるよう支援します。","head":[["meta",{"property":"keywords","content":"Gez, Node.js, ブラウザ互換性, TypeScript, es-module-shims, 環境設定"}]]},"version":""},{"id":172,"title":"クイックスタート","content":"#\n\n\nプロジェクトの初期化#\n\n新しい Gez プロジェクトを作成して初期化するには、以下の手順に従ってください：\n\n\n\n\nフレームワークバージョンの選択#\n\nGez\nフレームワークは、さまざまな技術スタックのバージョンを提供しており、それぞれが異なるアプリケーションシナリオに最適化されています。プロジェクトの要件に応じて適切\nなバージョンを選択してください：\n\n\nHTML#\n\n極限までシンプルなアーキテクチャを求めるプロジェクトに適しています：\n\n * 外部依存関係なし、すぐに使用可能\n * ネイティブ JavaScript 開発体験\n * 静的サイトや軽量アプリケーションの構築に適しています\n * プログレッシブな機能拡張をサポート\n\nHTML バージョンの詳細ドキュメントを確認する\n\n\nVue2#\n\nエンタープライズレベルのアプリケーション開発に適しています：\n\n * 完全な TypeScript サポート\n * 豊富なサードパーティコンポーネントエコシステム\n * 成熟した開発ツールチェーン\n * 本番環境での検証済みの安定性\n\nVue2 バージョンの詳細ドキュメントを確認する\n\n\nVue3#\n\nモダンな Web アプリケーション開発に適しています：\n\n * Proxy ベースのリアクティブシステム\n * コンポジション API のサポート\n * より優れたランタイムパフォーマンス\n * より小さなバンドルサイズ\n\nVue3 バージョンの詳細ドキュメントを確認する\n\n\nPreact+HTM#\n\n軽量で高性能を求めるプロジェクトに適しています：\n\n * 極小のランタイムサイズ（3KB）\n * ネイティブ JavaScript テンプレート構文\n * React 互換の API\n * 優れたパフォーマンス\n\nPreact+HTM バージョンの詳細ドキュメントを確認する\n\n\nAI 支援開発#\n\nGez フレームワークは、開発効率を大幅に向上させる AI 支援開発機能を提供しています：\n\n 1. 適切なフレームワークバージョンのドキュメントを選択\n 2. ドキュメントの内容を AI アシスタントに提供\n 3. AI が自動的にプロジェクトの骨組みと設定ファイルを生成\n\nヒント\n\nAI 支援開発は、プロジェクトの初期化速度を向上させるだけでなく、プロジェクト構造がベストプラクティスに準拠していることを保証します。","routePath":"/ja/guide/start/getting-started","lang":"ja","toc":[{"text":"プロジェクトの初期化","id":"プロジェクトの初期化","depth":2,"charIndex":3},{"text":"フレームワークバージョンの選択","id":"フレームワークバージョンの選択","depth":2,"charIndex":62},{"text":"HTML","id":"html","depth":3,"charIndex":184},{"text":"Vue2","id":"vue2","depth":3,"charIndex":351},{"text":"Vue3","id":"vue3","depth":3,"charIndex":503},{"text":"Preact+HTM","id":"preacthtm","depth":3,"charIndex":649},{"text":"AI 支援開発","id":"ai-支援開発","depth":2,"charIndex":802}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク クイックスタートガイド","description":"Gez フレームワークのクイックスタートガイド。プロジェクトの初期化、フレームワークバージョンの選択、AI支援開発などを含む、ゼロからのプロジェクト構築をサポートします。","head":[["meta",{"name":"keywords","content":"Gezフレームワーク, クイックスタート, プロジェクト初期化, Vue開発, HTML開発, AI支援"}]]},"version":""},{"id":173,"title":"イントロダクション","content":"#\n\n\nプロジェクト背景#\n\nGez は ECMAScript Modules (ESM)\nを基盤としたモダンなマイクロフロントエンドフレームワークで、高性能で拡張性の高いサーバーサイドレンダリング（SSR）アプリケーションの構築に焦点を当てています。\nGenesis プロジェクトの第三世代製品として、Gez は技術進化の過程で絶えず革新を続けています：\n\n * v1.0：HTTP リクエストを利用したリモートコンポーネントのオンデマンドロードを実現\n * v2.0：Webpack Module Federation を基盤としたアプリケーション統合を実現\n * v3.0：ブラウザのネイティブ ESM を基盤に再設計されたモジュールリンクシステム\n\n\n技術背景#\n\nマイクロフロントエンドアーキテクチャの発展において、従来のソリューションには以下のような課題がありました：\n\n\n既存ソリューションの課題#\n\n * パフォーマンスのボトルネック：ランタイム依存性注入と JavaScript サンドボックスプロキシによる顕著なパフォーマンスオーバーヘッド\n * 隔離メカニズム：独自開発のサンドボックス環境ではブラウザのネイティブなモジュール隔離能力に及ばない\n * ビルドの複雑さ：依存関係の共有を実現するためのビルドツールの改造により、プロジェクトのメンテナンスコストが増加\n * 標準からの逸脱：特殊なデプロイ戦略とランタイム処理メカニズムが、モダンな Web 開発標準から外れている\n * エコシステムの制限：フレームワークの結合とカスタム API により、技術スタックの選択が制限される\n\n\n技術革新#\n\nGez はモダンな Web 標準に基づき、新たなソリューションを提供します：\n\n * ネイティブモジュールシステム：ブラウザのネイティブ ESM と Import Maps を利用した依存関係管理により、より高速な解析と実行を実現\n * 標準的な隔離メカニズム：ECMAScript モジュールスコープに基づいた信頼性の高いアプリケーション隔離\n * オープンな技術スタック：任意のモダンなフロントエンドフレームワークのシームレスな統合をサポート\n * 開発体験の最適化：直感的な開発モードと完全なデバッグ能力を提供\n * 究極のパフォーマンス最適化：ネイティブ能力を活用したゼロランタイムオーバーヘッドとインテリジェントなキャッシュ戦略\n\nTIP\n\nGez\nは高性能で拡張性の高いマイクロフロントエンドインフラストラクチャの構築に注力しており、特に大規模なサーバーサイドレンダリングアプリケーションに適しています。\n\n\n技術仕様#\n\n\n環境依存#\n\n詳細なブラウザと Node.js の環境要件については、環境要件ドキュメントを参照してください。\n\n\nコア技術スタック#\n\n * 依存関係管理：Import Maps を利用したモジュールマッピングと、es-module-shims による互換性サポート\n * ビルドシステム：Rspack の module-import を基盤とした外部依存関係の処理\n * 開発ツールチェーン：ESM ホットリロードと TypeScript ネイティブ実行をサポート\n\n\nフレームワークの位置付け#\n\nGez は Next.js や Nuxt.js とは異なり、マイクロフロントエンドインフラストラクチャの提供に焦点を当てています：\n\n * モジュールリンクシステム：効率的で信頼性の高いモジュールのインポートとエクスポートを実現\n * サーバーサイドレンダリング：柔軟な SSR 実装メカニズムを提供\n * 型システムサポート：完全な TypeScript 型定義を統合\n * フレームワーク中立性：主要なフロントエンドフレームワークの統合をサポート\n\n\nアーキテクチャ設計#\n\n\n集中型依存関係管理#\n\n * 統一された依存関係ソース：集中化されたサードパーティ依存関係管理\n * 自動化された配布：依存関係更新のグローバルな自動同期\n * バージョン一貫性：正確な依存関係バージョン管理\n\n\nモジュール設計#\n\n * 責務分離：ビジネスロジックとインフラストラクチャの分離\n * プラグインメカニズム：モジュールの柔軟な組み合わせと置換をサポート\n * 標準化されたインターフェース：モジュール間の通信プロトコルの標準化\n\n\nパフォーマンス最適化#\n\n * ゼロオーバーヘッド原則：ブラウザのネイティブ能力を最大限に活用\n * インテリジェントキャッシュ：コンテンツハッシュに基づいた正確なキャッシュ戦略\n * オンデマンドロード：細分化されたコード分割と依存関係管理\n\n\nプロジェクトの成熟度#\n\nGez は約 5 年間のイテレーション（v1.0 から\nv3.0）を経て、エンタープライズ環境で全面的に検証されています。現在、数十のビジネスプロジェクトを安定して支えており、技術スタックのモダン化を推進し続けていま\nす。フレームワークの安定性、信頼性、パフォーマンスの優位性は実践で十分に検証されており、大規模アプリケーション開発に信頼できる技術基盤を提供しています。","routePath":"/ja/guide/start/introduction","lang":"ja","toc":[{"text":"プロジェクト背景","id":"プロジェクト背景","depth":2,"charIndex":3},{"text":"技術背景","id":"技術背景","depth":2,"charIndex":329},{"text":"既存ソリューションの課題","id":"既存ソリューションの課題","depth":3,"charIndex":392},{"text":"技術革新","id":"技術革新","depth":3,"charIndex":703},{"text":"技術仕様","id":"技術仕様","depth":2,"charIndex":1121},{"text":"環境依存","id":"環境依存","depth":3,"charIndex":1129},{"text":"コア技術スタック","id":"コア技術スタック","depth":3,"charIndex":1187},{"text":"フレームワークの位置付け","id":"フレームワークの位置付け","depth":2,"charIndex":1366},{"text":"アーキテクチャ設計","id":"アーキテクチャ設計","depth":2,"charIndex":1609},{"text":"集中型依存関係管理","id":"集中型依存関係管理","depth":3,"charIndex":1622},{"text":"モジュール設計","id":"モジュール設計","depth":3,"charIndex":1729},{"text":"パフォーマンス最適化","id":"パフォーマンス最適化","depth":3,"charIndex":1846},{"text":"プロジェクトの成熟度","id":"プロジェクトの成熟度","depth":2,"charIndex":1970}],"domain":"","frontmatter":{"titleSuffix":"Gez フレームワーク概要と技術革新","description":"Gez マイクロフロントエンドフレームワークのプロジェクト背景、技術進化、コアメリットを深く理解し、ESM ベースのモダンなサーバーサイドレンダリング（SSR）ソリューションを探求します。","head":[["meta",{"property":"keywords","content":"Gez, マイクロフロントエンド, ESM, サーバーサイドレンダリング, SSR, 技術革新, モジュールフェデレーション"}]]},"version":""}]