---
titleSuffix: "마이크로 프론트엔드의 어려움에서 ESM 혁신까지: Gez 프레임워크의 진화 과정"
description: Gez 프레임워크가 전통적인 마이크로 프론트엔드 아키텍처의 어려움에서 ESM 기반의 혁신적인 돌파구를 찾아가는 과정을 깊이 있게 탐구하며, 성능 최적화, 의존성 관리, 빌드 도구 선택 등의 기술적 실천 경험을 공유합니다.
head:
  - - meta
    - property: keywords
      content: Gez, 마이크로 프론트엔드 프레임워크, ESM, Import Maps, Rspack, 모듈 연합, 의존성 관리, 성능 최적화, 기술 진화, 서버 사이드 렌더링
sidebar: false
---

# 컴포넌트 공유에서 네이티브 모듈화까지: Gez 마이크로 프론트엔드 프레임워크의 진화 과정

## 프로젝트 배경

지난 몇 년 동안, 마이크로 프론트엔드 아키텍처는 올바른 길을 찾기 위해 노력해 왔습니다. 그러나 우리가 본 것은 다양한 복잡한 기술적 해결책들이었으며, 이들은 이상적인 마이크로 프론트엔드 세계를 모방하기 위해 여러 겹의 포장과 인위적인 격리를 사용했습니다. 이러한 해결책들은 심각한 성능 부담을 가져왔고, 간단한 개발을 복잡하게 만들며, 표준적인 프로세스를 난해하게 만들었습니다.

### 전통적인 해결책의 한계

마이크로 프론트엔드 아키텍처를 실천하는 과정에서, 우리는 전통적인 해결책의 여러 제한 사항을 깊이 깨달았습니다:

- **성능 손실**: 런타임에 의존성 주입, JS 샌드박스 프록시, 모든 작업이 소중한 성능을 소모합니다.
- **취약한 격리**: 인위적으로 만든 샌드박스 환경은 브라우저의 네이티브 격리 능력에 도달할 수 없습니다.
- **빌드 복잡성**: 의존성 관계를 처리하기 위해 빌드 도구를 수정해야 하며, 간단한 프로젝트를 유지하기 어렵게 만듭니다.
- **맞춤형 규칙**: 특별한 배포 전략, 런타임 처리, 모든 단계가 현대 개발의 표준 프로세스에서 벗어납니다.
- **생태계 제한**: 프레임워크 결합, 맞춤형 API, 기술 선택이 특정 생태계에 묶이게 됩니다.

이러한 문제들은 2019년의 한 기업급 프로젝트에서 특히 두드러졌습니다. 당시, 대형 제품이 독립적인 비즈니스 하위 시스템으로 분할되었으며, 이러한 하위 시스템들은 기본 컴포넌트와 비즈니스 컴포넌트를 공유해야 했습니다. 초기에 npm 패키지 기반의 컴포넌트 공유 해결책을 사용했지만, 실제로는 심각한 유지 보수 효율성 문제가 드러났습니다: 공유 컴포넌트가 업데이트될 때, 해당 컴포넌트에 의존하는 모든 하위 시스템은 완전한 빌드와 배포 프로세스를 거쳐야 했습니다.

## 기술 진화

### v1.0: 원격 컴포넌트 탐구

컴포넌트 공유의 효율성 문제를 해결하기 위해, Gez v1.0은 HTTP 프로토콜 기반의 RemoteView 컴포넌트 메커니즘을 도입했습니다. 이 해결책은 런타임에 동적으로 요청하는 방식으로 서비스 간의 코드를 필요에 따라 조립할 수 있게 하여, 빌드 의존성 체인이 너무 길어지는 문제를 해결했습니다. 그러나 표준화된 런타임 통신 메커니즘이 부족하여, 서비스 간의 상태 동기화와 이벤트 전달은 여전히 효율성 문제가 있었습니다.

### v2.0: 모듈 연합 시도

v2.0 버전에서, 우리는 [Webpack 5.0](https://webpack.js.org/)의 [모듈 연합(Module Federation)](https://webpack.js.org/concepts/module-federation/) 기술을 사용했습니다. 이 기술은 통일된 모듈 로딩 메커니즘과 런타임 컨테이너를 통해 서비스 간의 협업 효율성을 크게 향상시켰습니다. 그러나 대규모 실천에서, 모듈 연합의 폐쇄형 구현 메커니즘은 새로운 도전을 가져왔습니다: 정확한 의존성 버전 관리가 어려웠으며, 특히 여러 서비스의 공유 의존성을 통일할 때, 버전 충돌과 런타임 예외가 자주 발생했습니다.

## ESM 신시대를 맞이하며

v3.0 버전을 계획할 때, 우리는 프론트엔드 생태계의 발전 추세를 깊이 관찰했으며, 브라우저의 네이티브 능력의 발전이 마이크로 프론트엔드 아키텍처에 새로운 가능성을 가져왔음을 발견했습니다:

### 표준화된 모듈 시스템

주요 브라우저들이 [ES Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)를 전면적으로 지원하고, [Import Maps](https://github.com/WICG/import-maps) 규격이 성숙해짐에 따라, 프론트엔드 개발은 진정한 모듈화 시대를 맞이했습니다. [Can I Use](https://caniuse.com/?search=importmap)의 통계에 따르면, 현재 주요 브라우저(Chrome >= 89, Edge >= 89, Firefox >= 108, Safari >= 16.4)의 ESM 네이티브 지원률은 93.5%에 달하며, 이는 우리에게 다음과 같은 이점을 제공합니다:

- **의존성 관리 표준화**: Import Maps는 브라우저 수준에서 모듈 의존성을 해결할 수 있는 능력을 제공하며, 복잡한 런타임 주입이 필요 없습니다.
- **리소스 로딩 최적화**: 브라우저의 네이티브 모듈 캐싱 메커니즘은 리소스 로딩 효율성을 크게 향상시킵니다.
- **빌드 프로세스 단순화**: ESM 기반의 개발 모드는 개발 환경과 프로덕션 환경의 빌드 프로세스를 더욱 일관되게 만듭니다.

동시에, 호환 모드 지원(Chrome >= 87, Edge >= 88, Firefox >= 78, Safari >= 14)을 통해, 우리는 브라우저 커버리지를 96.81%까지 더욱 향상시킬 수 있으며, 이는 고성능을 유지하면서도 구형 브라우저에 대한 지원을 희생하지 않을 수 있게 합니다.

### 성능과 격리의 돌파

네이티브 모듈 시스템이 가져온 것은 표준화뿐만 아니라, 성능과 격리성의 질적인 향상입니다:

- **런타임 오버헤드 제로**: 전통적인 마이크로 프론트엔드 해결책의 JavaScript 샌드박스 프록시와 런타임 주입을 더 이상 사용하지 않습니다.
- **신뢰할 수 있는 격리 메커니즘**: ESM의 엄격한 모듈 스코프는 가장 신뢰할 수 있는 격리 능력을 제공합니다.
- **정확한 의존성 관리**: 정적 임포트 분석은 의존성 관계를 더욱 명확하게 만들며, 버전 제어를 더욱 정확하게 만듭니다.

### 빌드 도구 선택

기술 해결책의 실천 과정에서, 빌드 도구 선택은 중요한 결정점입니다. 거의 1년간의 기술 조사와 실천을 통해, 우리의 선택은 다음과 같은 진화를 거쳤습니다:

1. **Vite 탐구**
   - 장점: ESM 기반의 개발 서버, 최고의 개발 경험 제공
   - 도전: 개발 환경과 프로덕션 환경의 빌드 차이로 인해 일부 불확실성이 발생

2. **[Rspack](https://www.rspack.dev/) 확정**
   - 성능 장점: [Rust](https://www.rust-lang.org/) 기반의 고성능 컴파일, 빌드 속도 크게 향상
   - 생태계 지원: Webpack 생태계와의 높은 호환성, 마이그레이션 비용 감소
   - ESM 지원: Rslib 프로젝트의 실천을 통해, ESM 빌드 측면에서의 신뢰성 검증

이 결정은 우리가 개발 경험을 유지하면서도 더 안정적인 프로덕션 환경 지원을 얻을 수 있게 했습니다. ESM과 Rspack의 조합을 통해, 우리는 고성능, 낮은 침입성의 마이크로 프론트엔드 해결책을 최종적으로 구축했습니다.

## 미래 전망

미래의 발전 계획에서, Gez 프레임워크는 다음 세 가지 방향에 중점을 둘 것입니다:

### Import Maps 심화 최적화

- **동적 의존성 관리**: 런타임 의존성 버전의 지능형 스케줄링 구현, 다중 애플리케이션 간의 의존성 충돌 해결
- **프리로딩 전략**: 라우팅 분석 기반의 지능형 프리로딩, 리소스 로딩 효율성 향상
- **빌드 최적화**: 최적의 Import Maps 설정 자동 생성, 개발자의 수동 설정 비용 감소

### 프레임워크 독립적인 라우팅 해결책

- **통일된 라우팅 추상화**: Vue, React 등 주요 프레임워크를 지원하는 프레임워크 독립적인 라우팅 인터페이스 설계
- **마이크로 애플리케이션 라우팅**: 애플리케이션 간의 라우팅 연동 구현, URL과 애플리케이션 상태의 일관성 유지
- **라우팅 미들웨어**: 확장 가능한 미들웨어 메커니즘 제공, 권한 제어, 페이지 전환 등의 기능 지원

### 프레임워크 간 통신 최적의 실천

- **예제 애플리케이션**: Vue, React, Preact 등 주요 프레임워크를 포함한 완전한 프레임워크 간 통신 예제 제공
- **상태 동기화**: ESM 기반의 경량 상태 공유 해결책 구현
- **이벤트 버스**: 표준화된 이벤트 통신 메커니즘, 애플리케이션 간의 분리된 통신 지원

이러한 최적화와 확장을 통해, 우리는 Gez를 더욱 완벽하고 사용하기 쉬운 마이크로 프론트엔드 해결책으로 만들고자 하며, 개발자들에게 더 나은 개발 경험과 더 높은 개발 효율성을 제공하고자 합니다.