---
titleSuffix: Gez फ्रेमवर्क मॉड्यूल आयात पथ मैपिंग गाइड
description: Gez फ्रेमवर्क के पथ उपनाम (Path Alias) तंत्र के बारे में विस्तृत जानकारी, जिसमें आयात पथ को सरल बनाना, गहरे नेस्टिंग से बचना, प्रकार सुरक्षा और मॉड्यूल रिज़ॉल्यूशन ऑप्टिमाइज़ेशन जैसी विशेषताएं शामिल हैं, जो डेवलपर्स को कोड की रखरखाव क्षमता बढ़ाने में मदद करती हैं।
head:
  - - meta
    - property: keywords
      content: Gez, पथ उपनाम, Path Alias, TypeScript, मॉड्यूल आयात, पथ मैपिंग, कोड रखरखाव क्षमता
---

# पथ उपनाम (Path Alias)

पथ उपनाम (Path Alias) एक मॉड्यूल आयात पथ मैपिंग तंत्र है, जो डेवलपर्स को पूर्ण मॉड्यूल पथ के बजाय संक्षिप्त और अर्थपूर्ण पहचानकर्ता (identifier) का उपयोग करने की अनुमति देता है। Gez में, पथ उपनाम तंत्र के निम्नलिखित लाभ हैं:

- **आयात पथ को सरल बनाना**: लंबे रिलेटिव पथ के बजाय अर्थपूर्ण उपनाम का उपयोग करके कोड की पठनीयता बढ़ाना
- **गहरे नेस्टिंग से बचना**: बहुस्तरीय डायरेक्टरी संदर्भ (जैसे `../../../../`) से होने वाली रखरखाव कठिनाइयों को दूर करना
- **प्रकार सुरक्षा**: TypeScript के प्रकार प्रणाली के साथ पूर्ण एकीकरण, कोड पूर्णता और प्रकार जांच प्रदान करना
- **मॉड्यूल रिज़ॉल्यूशन ऑप्टिमाइज़ेशन**: पूर्वनिर्धारित पथ मैपिंग के माध्यम से मॉड्यूल रिज़ॉल्यूशन प्रदर्शन को बढ़ाना

## डिफ़ॉल्ट उपनाम तंत्र

Gez सेवा नाम (Service Name) पर आधारित स्वचालित उपनाम तंत्र का उपयोग करता है, जो कॉन्फ़िगरेशन पर सम्मेलन (convention over configuration) को प्राथमिकता देता है। इसके निम्नलिखित विशेषताएं हैं:

- **स्वचालित कॉन्फ़िगरेशन**: `package.json` में `name` फ़ील्ड के आधार पर स्वचालित रूप से उपनाम उत्पन्न करना, मैन्युअल कॉन्फ़िगरेशन की आवश्यकता नहीं
- **एकीकृत मानक**: सभी सेवा मॉड्यूल को एक समान नामकरण और संदर्भ मानक का पालन करना सुनिश्चित करना
- **प्रकार समर्थन**: `npm run build:dts` कमांड के साथ, स्वचालित रूप से प्रकार घोषणा फ़ाइलें उत्पन्न करना, जो क्रॉस-सेवा प्रकार अनुमान (type inference) को सक्षम करता है
- **पूर्वानुमेयता**: सेवा नाम के माध्यम से मॉड्यूल संदर्भ पथ का अनुमान लगाना, रखरखाव लागत को कम करना

## कॉन्फ़िगरेशन विवरण

### package.json कॉन्फ़िगरेशन

`package.json` में, `name` फ़ील्ड के माध्यम से सेवा का नाम परिभाषित करें, यह नाम सेवा के डिफ़ॉल्ट उपनाम उपसर्ग (prefix) के रूप में कार्य करेगा:

```json title="package.json"
{
    "name": "your-app-name"
}
```

### tsconfig.json कॉन्फ़िगरेशन

TypeScript को उपनाम पथ को सही ढंग से रिज़ॉल्व करने के लिए, `tsconfig.json` में `paths` मैपिंग को कॉन्फ़िगर करना आवश्यक है:

```json title="tsconfig.json"
{
    "compilerOptions": {
        "paths": {
            "your-app-name/src/*": [
                "./src/*"
            ],
            "your-app-name/*": [
                "./*"
            ]
        }
    }
}
```

## उपयोग उदाहरण

### सेवा आंतरिक मॉड्यूल आयात करना

```ts
// उपनाम का उपयोग करके आयात
import { MyComponent } from 'your-app-name/src/components';

// समकक्ष रिलेटिव पथ आयात
import { MyComponent } from '../components';
```

### अन्य सेवा मॉड्यूल आयात करना

```ts
// अन्य सेवा के घटक आयात करना
import { SharedComponent } from 'other-service/src/components';

// अन्य सेवा के उपयोगिता फ़ंक्शन आयात करना
import { utils } from 'other-service/src/utils';
```

::: tip सर्वोत्तम अभ्यास
- रिलेटिव पथ के बजाय उपनाम पथ का प्राथमिकता से उपयोग करें
- उपनाम पथ को अर्थपूर्ण और सुसंगत रखें
- उपनाम पथ में बहुत अधिक डायरेक्टरी स्तरों का उपयोग करने से बचें

:::

``` ts
// घटक आयात करना
import { Button } from 'your-app-name/src/components';
import { Layout } from 'your-app-name/src/components/layout';

// उपयोगिता फ़ंक्शन आयात करना
import { formatDate } from 'your-app-name/src/utils';
import { request } from 'your-app-name/src/utils/request';

// प्रकार परिभाषाएं आयात करना
import type { UserInfo } from 'your-app-name/src/types';
```

### क्रॉस-सेवा आयात

जब मॉड्यूल लिंक (Module Link) कॉन्फ़िगर किया जाता है, तो अन्य सेवा के मॉड्यूल को उसी तरह आयात किया जा सकता है:

```ts
// रिमोट सेवा के घटक आयात करना
import { Header } from 'remote-service/src/components';

// रिमोट सेवा के उपयोगिता फ़ंक्शन आयात करना
import { logger } from 'remote-service/src/utils';
```

### कस्टम उपनाम

थर्ड-पार्टी पैकेज या विशेष परिदृश्यों के लिए, Gez कॉन्फ़िगरेशन फ़ाइल के माध्यम से कस्टम उपनाम परिभाषित किए जा सकते हैं:

```ts title="src/entry.node.ts"
export default {
    async devApp(gez) {
        return import('@gez/rspack').then((m) =>
            m.createApp(gez, (buildContext) => {
                buildContext.config.resolve = {
                    ...buildContext.config.resolve,
                    alias: {
                        ...buildContext.config.resolve?.alias,
                        // Vue के लिए विशिष्ट बिल्ड संस्करण कॉन्फ़िगर करना
                        'vue$': 'vue/dist/vue.esm.js',
                        // सामान्य डायरेक्टरी के लिए संक्षिप्त उपनाम कॉन्फ़िगर करना
                        '@': './src',
                        '@components': './src/components'
                    }
                }
            })
        );
    }
} satisfies GezOptions;
```

::: warning ध्यान देने योग्य बातें
1. व्यावसायिक मॉड्यूल के लिए, परियोजना की सुसंगतता बनाए रखने के लिए डिफ़ॉल्ट उपनाम तंत्र का उपयोग करने की सिफारिश की जाती है
2. कस्टम उपनाम मुख्य रूप से थर्ड-पार्टी पैकेज की विशेष आवश्यकताओं को संभालने या विकास अनुभव को अनुकूलित करने के लिए उपयोग किए जाते हैं
3. कस्टम उपनाम का अत्यधिक उपयोग कोड की रखरखाव क्षमता और बिल्ड ऑप्टिमाइज़ेशन को प्रभावित कर सकता है

:::