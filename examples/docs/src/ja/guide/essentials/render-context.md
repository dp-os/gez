---
titleSuffix: Gez フレームワークのサーバーサイドレンダリングコアメカニズム
description: Gez フレームワークのレンダリングコンテキスト（RenderContext）メカニズムについて詳しく説明します。リソース管理、HTML生成、ESMモジュールシステムを含め、開発者がサーバーサイドレンダリング機能を理解し使用するのに役立ちます。
head:
  - - meta
    - property: keywords
      content: Gez, レンダリングコンテキスト, RenderContext, SSR, サーバーサイドレンダリング, ESM, リソース管理
---

# レンダリングコンテキスト

RenderContext は Gez フレームワークのコアクラスで、主にサーバーサイドレンダリング（SSR）プロセス中のリソース管理と HTML 生成を担当します。以下のコア特徴を持っています：

1. **ESM ベースのモジュールシステム**
   - 現代的な ECMAScript Modules 標準を採用
   - ネイティブのモジュールインポート/エクスポートをサポート
   - より良いコード分割とオンデマンドロードを実現

2. **インテリジェントな依存関係収集**
   - 実際のレンダリングパスに基づいて動的に依存関係を収集
   - 不要なリソースロードを回避
   - 非同期コンポーネントと動的インポートをサポート

3. **正確なリソース注入**
   - リソースロード順序を厳密に制御
   - 初回ロードパフォーマンスを最適化
   - クライアントサイドのアクティベーション（Hydration）の信頼性を確保

4. **柔軟な設定メカニズム**
   - 動的なベースパス設定をサポート
   - 複数のインポートマッピングモードを提供
   - 異なるデプロイシナリオに対応

## 使用方法

Gez フレームワークでは、開発者は通常 RenderContext インスタンスを直接作成する必要はなく、`gez.render()` メソッドを通じてインスタンスを取得します：

```ts title="src/entry.node.ts"
async server(gez) {
    const server = http.createServer((req, res) => {
        // 静的ファイル処理
        gez.middleware(req, res, async () => {
            // gez.render() を通じて RenderContext インスタンスを取得
            const rc = await gez.render({
                params: {
                    url: req.url
                }
            });
            // HTML コンテンツをレスポンス
            res.end(rc.html);
        });
    });
}
```

## 主な機能

### 依存関係収集

RenderContext はインテリジェントな依存関係収集メカニズムを実装しており、実際にレンダリングされるコンポーネントに基づいて動的に依存関係を収集します：

#### オンデマンド収集
- コンポーネントの実際のレンダリングプロセス中に自動的にモジュール依存関係を追跡・記録
- 現在のページレンダリングで実際に使用される CSS、JavaScript などのリソースのみを収集
- `importMetaSet` を通じて各コンポーネントのモジュール依存関係を正確に記録
- 非同期コンポーネントと動的インポートの依存関係収集をサポート

#### 自動化処理
- 開発者が手動で依存関係収集プロセスを管理する必要はありません
- フレームワークがコンポーネントレンダリング時に自動的に依存関係情報を収集
- `commit()` メソッドを通じて収集されたすべてのリソースを一括処理
- 循環依存と重複依存の問題を自動的に処理

#### パフォーマンス最適化
- 未使用のモジュールのロードを回避し、初回ロード時間を大幅に短縮
- リソースロード順序を正確に制御し、ページレンダリングパフォーマンスを最適化
- 最適なインポートマッピング（Import Map）を自動生成
- リソースのプリロードとオンデマンドロード戦略をサポート

### リソース注入

RenderContext は、異なるタイプのリソースを注入するための複数のメソッドを提供し、各メソッドはリソースロードパフォーマンスを最適化するために設計されています：

- `preload()`：CSS と JS リソースをプリロードし、優先度設定をサポート
- `css()`：初回表示用のスタイルシートを注入し、クリティカル CSS の抽出をサポート
- `importmap()`：モジュールインポートマッピングを注入し、動的パス解決をサポート
- `moduleEntry()`：クライアントサイドのエントリーモジュールを注入し、マルチエントリー設定をサポート
- `modulePreload()`：モジュール依存関係をプリロードし、オンデマンドロード戦略をサポート

### リソース注入順序

RenderContext はリソース注入順序を厳密に制御し、この順序設計はブラウザの動作原理とパフォーマンス最適化を考慮しています：

1. head 部分：
   - `preload()`：CSS と JS リソースをプリロードし、ブラウザがこれらのリソースを早期に発見してロードを開始できるようにします
   - `css()`：初回表示用のスタイルシートを注入し、ページのスタイルがコンテンツレンダリング時に準備されていることを確認します

2. body 部分：
   - `importmap()`：モジュールインポートマッピングを注入し、ESM モジュールのパス解決ルールを定義します
   - `moduleEntry()`：クライアントサイドのエントリーモジュールを注入し、importmap の後に実行する必要があります
   - `modulePreload()`：モジュール依存関係をプリロードし、importmap の後に実行する必要があります

## 完全なレンダリングプロセス

典型的な RenderContext の使用プロセスは以下の通りです：

```ts title="src/entry.server.ts"
export default async (rc: RenderContext) => {
    // 1. ページコンテンツをレンダリングし、依存関係を収集
    const app = createApp();
    const html = await renderToString(app, {
       importMetaSet: rc.importMetaSet
    });

    // 2. 依存関係収集をコミット
    await rc.commit();
    
    // 3. 完全な HTML を生成
    rc.html = `
        <!DOCTYPE html>
        <html>
        <head>
            ${rc.preload()}
            ${rc.css()}
        </head>
        <body>
            ${html}
            ${rc.importmap()}
            ${rc.moduleEntry()}
            ${rc.modulePreload()}
        </body>
        </html>
    `;
};
```

## 高度な機能

### ベースパス設定

RenderContext は柔軟な動的ベースパス設定メカニズムを提供し、実行時に静的リソースのベースパスを動的に設定できます：

```ts title="src/entry.node.ts"
const rc = await gez.render({
    base: '/gez',  // ベースパスを設定
    params: {
        url: req.url
    }
});
```

このメカニズムは以下のシナリオに特に適しています：

1. **多言語サイトデプロイ**
   ```
   メインドメイン.com      → デフォルト言語
   メインドメイン.com/cn/  → 中国語サイト
   メインドメイン.com/en/  → 英語サイト
   ```

2. **マイクロフロントエンドアプリケーション**
   - サブアプリケーションを異なるパス下で柔軟にデプロイ
   - 異なるメインアプリケーションへの統合が容易

### インポートマッピングモード

RenderContext は2つのインポートマッピング（Import Map）モードを提供します：

1. **Inline モード**（デフォルト）
   - インポートマッピングを直接 HTML にインライン化
   - 小規模アプリケーションに適し、追加のネットワークリクエストを削減
   - ページロード時に即時利用可能

2. **JS モード**
   - 外部 JavaScript ファイルを通じてインポートマッピングをロード
   - 大規模アプリケーションに適し、ブラウザのキャッシュメカニズムを利用
   - マッピング内容の動的更新をサポート

設定を通じて適切なモードを選択できます：

```ts title="src/entry.node.ts"
const rc = await gez.render({
    importmapMode: 'js',  // 'inline' | 'js'
    params: {
        url: req.url
    }
});
```

### エントリー関数設定

RenderContext は `entryName` 設定を通じてサーバーサイドレンダリングのエントリー関数を指定できます：

```ts title="src/entry.node.ts"
const rc = await gez.render({
    entryName: 'mobile',  // モバイルエントリー関数を使用
    params: {
        url: req.url
    }
});
```

このメカニズムは以下のシナリオに特に適しています：

1. **マルチテンプレートレンダリング**
   ```ts title="src/entry.server.ts"
   // モバイルエントリー関数
   export const mobile = async (rc: RenderContext) => {
       // モバイル固有のレンダリングロジック
   };

   // デスクトップエントリー関数
   export const desktop = async (rc: RenderContext) => {
       // デスクトップ固有のレンダリングロジック
   };
   ```

2. **A/B テスト**
   - 同一ページで異なるレンダリングロジックを使用
   - ユーザーエクスペリエンス実験を容易に実施
   - 異なるレンダリング戦略を柔軟に切り替え

3. **特殊なレンダリング要件**
   - 特定のページでカスタムレンダリングプロセスを使用
   - 異なるシナリオのパフォーマンス最適化要件に対応
   - より細かいレンダリング制御を実現

## ベストプラクティス

1. **RenderContext インスタンスの取得**
   - 常に `gez.render()` メソッドを通じてインスタンスを取得
   - 必要に応じて適切なパラメータを渡す
   - 手動でのインスタンス作成を避ける

2. **依存関係収集**
   - すべてのモジュールが正しく `importMetaSet.add(import.meta)` を呼び出すことを確認
   - レンダリング完了後すぐに `commit()` メソッドを呼び出す
   - 非同期コンポーネントと動的インポートを適切に使用して初回ロードを最適化

3. **リソース注入**
   - リソース注入順序を厳密に遵守
   - body 内に CSS を注入しない
   - importmap が moduleEntry の前に実行されることを確認

4. **パフォーマンス最適化**
   - preload を使用して重要なリソースをプリロード
   - modulePreload を適切に使用してモジュールロードを最適化
   - 不要なリソースロードを避ける
   - ブラウザのキャッシュメカニズムを利用してロードパフォーマンスを最適化