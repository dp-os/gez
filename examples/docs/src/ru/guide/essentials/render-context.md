---
titleSuffix: Основные механизмы серверного рендеринга в Gez
description: Подробное описание механизма контекста рендеринга (RenderContext) в Gez, включая управление ресурсами, генерацию HTML и систему модулей ESM, чтобы помочь разработчикам понять и использовать функции серверного рендеринга.
head:
  - - meta
    - property: keywords
      content: Gez, контекст рендеринга, RenderContext, SSR, серверный рендеринг, ESM, управление ресурсами
---

# Контекст рендеринга

RenderContext — это основной класс в Gez, который отвечает за управление ресурсами и генерацию HTML в процессе серверного рендеринга (SSR). Он обладает следующими ключевыми особенностями:

1. **Система модулей на основе ESM**
   - Использует современный стандарт ECMAScript Modules
   - Поддерживает нативный импорт и экспорт модулей
   - Обеспечивает лучшее разделение кода и загрузку по требованию

2. **Интеллектуальный сбор зависимостей**
   - Динамически собирает зависимости на основе фактического пути рендеринга
   - Избегает загрузки ненужных ресурсов
   - Поддерживает асинхронные компоненты и динамический импорт

3. **Точное внедрение ресурсов**
   - Строго контролирует порядок загрузки ресурсов
   - Оптимизирует производительность загрузки первой страницы
   - Обеспечивает надежность гидратации (Hydration) на стороне клиента

4. **Гибкий механизм конфигурации**
   - Поддерживает динамическую настройку базового пути
   - Предоставляет различные режимы отображения импорта
   - Адаптируется к различным сценариям развертывания

## Использование

В Gez разработчикам обычно не нужно создавать экземпляр RenderContext вручную. Вместо этого они могут получить экземпляр через метод `gez.render()`:

```ts title="src/entry.node.ts"
async server(gez) {
    const server = http.createServer((req, res) => {
        // Обработка статических файлов
        gez.middleware(req, res, async () => {
            // Получение экземпляра RenderContext через gez.render()
            const rc = await gez.render({
                params: {
                    url: req.url
                }
            });
            // Отправка HTML-контента
            res.end(rc.html);
        });
    });
}
```

## Основные функции

### Сбор зависимостей

RenderContext реализует интеллектуальный механизм сбора зависимостей, который динамически собирает зависимости на основе фактически рендерящихся компонентов, а не просто предварительно загружает все возможные ресурсы:

#### Сбор по требованию
- Автоматически отслеживает и записывает зависимости модулей в процессе рендеринга компонентов
- Собирает только те ресурсы (CSS, JavaScript и т.д.), которые действительно используются на текущей странице
- Использует `importMetaSet` для точной записи зависимостей каждого компонента
- Поддерживает сбор зависимостей для асинхронных компонентов и динамического импорта

#### Автоматическая обработка
- Разработчикам не нужно вручную управлять процессом сбора зависимостей
- Фреймворк автоматически собирает информацию о зависимостях во время рендеринга компонентов
- Все собранные ресурсы обрабатываются через метод `commit()`
- Автоматически решает проблемы циклических и повторяющихся зависимостей

#### Оптимизация производительности
- Избегает загрузки неиспользуемых модулей, значительно сокращая время загрузки первой страницы
- Точный контроль порядка загрузки ресурсов для оптимизации производительности рендеринга
- Автоматически генерирует оптимальные карты импорта (Import Map)
- Поддерживает стратегии предварительной загрузки и загрузки по требованию

### Внедрение ресурсов

RenderContext предоставляет несколько методов для внедрения различных типов ресурсов, каждый из которых разработан для оптимизации производительности загрузки:

- `preload()`: Предварительная загрузка ресурсов CSS и JS с поддержкой настройки приоритетов
- `css()`: Внедрение стилей для первой страницы с поддержкой извлечения критического CSS
- `importmap()`: Внедрение карты импорта модулей с поддержкой динамического разрешения путей
- `moduleEntry()`: Внедрение клиентского входного модуля с поддержкой конфигурации нескольких входных точек
- `modulePreload()`: Предварительная загрузка зависимостей модулей с поддержкой стратегии загрузки по требованию

### Порядок внедрения ресурсов

RenderContext строго контролирует порядок внедрения ресурсов, что основано на принципах работы браузера и оптимизации производительности:

1. Часть head:
   - `preload()`: Предварительная загрузка ресурсов CSS и JS, чтобы браузер мог начать их загрузку как можно раньше
   - `css()`: Внедрение стилей для первой страницы, чтобы стили были готовы к моменту рендеринга контента

2. Часть body:
   - `importmap()`: Внедрение карты импорта модулей для определения правил разрешения путей ESM-модулей
   - `moduleEntry()`: Внедрение клиентского входного модуля, который должен выполняться после importmap
   - `modulePreload()`: Предварительная загрузка зависимостей модулей, которая должна выполняться после importmap

## Полный процесс рендеринга

Типичный процесс использования RenderContext выглядит следующим образом:

```ts title="src/entry.server.ts"
export default async (rc: RenderContext) => {
    // 1. Рендеринг содержимого страницы и сбор зависимостей
    const app = createApp();
    const html = await renderToString(app, {
       importMetaSet: rc.importMetaSet
    });

    // 2. Фиксация собранных зависимостей
    await rc.commit();
    
    // 3. Генерация полного HTML
    rc.html = `
        <!DOCTYPE html>
        <html>
        <head>
            ${rc.preload()}
            ${rc.css()}
        </head>
        <body>
            ${html}
            ${rc.importmap()}
            ${rc.moduleEntry()}
            ${rc.modulePreload()}
        </body>
        </html>
    `;
};
```

## Расширенные возможности

### Настройка базового пути

RenderContext предоставляет гибкий механизм динамической настройки базового пути, который позволяет задавать базовый путь для статических ресурсов во время выполнения:

```ts title="src/entry.node.ts"
const rc = await gez.render({
    base: '/gez',  // Установка базового пути
    params: {
        url: req.url
    }
});
```

Этот механизм особенно полезен в следующих сценариях:

1. **Развертывание многоязычных сайтов**
   ```
   основной-домен.com      → язык по умолчанию
   основной-домен.com/cn/  → китайская версия
   основной-домен.com/en/  → английская версия
   ```

2. **Микрофронтенд-приложения**
   - Поддержка гибкого развертывания подприложений по разным путям
   - Упрощает интеграцию в различные основные приложения

### Режимы отображения импорта

RenderContext предоставляет два режима отображения импорта (Import Map):

1. **Inline-режим** (по умолчанию)
   - Встраивает карту импорта непосредственно в HTML
   - Подходит для небольших приложений, уменьшая количество дополнительных сетевых запросов
   - Карта импорта доступна сразу при загрузке страницы

2. **JS-режим**
   - Загружает карту импорта через внешний JavaScript-файл
   - Подходит для крупных приложений, позволяя использовать кэширование браузера
   - Поддерживает динамическое обновление содержимого карты

Выбор режима можно настроить следующим образом:

```ts title="src/entry.node.ts"
const rc = await gez.render({
    importmapMode: 'js',  // 'inline' | 'js'
    params: {
        url: req.url
    }
});
```

### Настройка входной функции

RenderContext поддерживает настройку входной функции для серверного рендеринга через параметр `entryName`:

```ts title="src/entry.node.ts"
const rc = await gez.render({
    entryName: 'mobile',  // Указание входной функции для мобильной версии
    params: {
        url: req.url
    }
});
```

Этот механизм особенно полезен в следующих сценариях:

1. **Рендеринг нескольких шаблонов**
   ```ts title="src/entry.server.ts"
   // Входная функция для мобильной версии
   export const mobile = async (rc: RenderContext) => {
       // Логика рендеринга для мобильной версии
   };

   // Входная функция для десктопной версии
   export const desktop = async (rc: RenderContext) => {
       // Логика рендеринга для десктопной версии
   };
   ```

2. **A/B-тестирование**
   - Поддержка использования разных логик рендеринга для одной страницы
   - Упрощает проведение экспериментов с пользовательским опытом
   - Гибкое переключение между различными стратегиями рендеринга

3. **Специальные требования к рендерингу**
   - Поддержка использования пользовательских процессов рендеринга для определенных страниц
   - Адаптация к различным сценариям оптимизации производительности
   - Обеспечивает более точный контроль над процессом рендеринга

## Рекомендации

1. **Получение экземпляра RenderContext**
   - Всегда используйте метод `gez.render()` для получения экземпляра
   - Передавайте необходимые параметры в зависимости от требований
   - Избегайте ручного создания экземпляров

2. **Сбор зависимостей**
   - Убедитесь, что все модули правильно вызывают `importMetaSet.add(import.meta)`
   - Вызывайте метод `commit()` сразу после завершения рендеринга
   - Используйте асинхронные компоненты и динамический импорт для оптимизации загрузки первой страницы

3. **Внедрение ресурсов**
   - Строго соблюдайте порядок внедрения ресурсов
   - Не внедряйте CSS в body
   - Убедитесь, что importmap выполняется перед moduleEntry

4. **Оптимизация производительности**
   - Используйте preload для предварительной загрузки ключевых ресурсов
   - Рационально используйте modulePreload для оптимизации загрузки модулей
   - Избегайте загрузки ненужных ресурсов
   - Используйте механизмы кэширования браузера для оптимизации производительности загрузки