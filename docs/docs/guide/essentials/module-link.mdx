# 模块链接
一个大型项目，总是会拆分成组件库、工具库、业务模块等。它们总是会写在不同的地方，以独立的仓库、monorepo 包等形式存在，但是最终都需要系统的主程序链接这些模块。Gez 的核心功能就是帮你把这些不同地方的模块，快速的链接到一起。实现一个服务发布，其它服务同时更新。

:::tip
Gez 默认是支持 SSR 的，你也可以把它当成 CSR 来使用。
:::

## 设计理念
- 我们应该设计一个基础服务，由基础服务提供所有的第三方依赖。
- 由基础服务统一维护第三方依赖更新，一次发布，所有业务系统生效。
- 业务服务仅构建业务代码，所有的第三方依赖，应指向到基础服务中。

:::tip
由于第三方依赖，都被指向到了基础服务，不再需要重复打包，这会让 Rspack 的编译速度，再提升一个台阶。
:::

## 构建
传统的 SSR 程序在构建目标为 `node` 时，会将 `node_modules` 的模块设置为外部依赖，但是 Gez 会把全部代码都打包成 ESM 模块来进行链接。所以在使用一些第三方依赖的时候，尽可能的选择支持 ESM 的包，不然你可能会遇到一些问题。
构建完成后，通常你可以看到这样的文件输出。
```
- dist/                            # 构建输出目录
  - client/                        # 客户端构建输出
    - chunks/                      # 当前服务抽离的公共代码
        - [name].[contenthash].js
    - npm/                         # 对外导出的 node_modules 包
        - [name].[contenthash].js
    - src/                         # 对外导出的 src 目录下的文件
        - [name].[contenthash].js
    - versions/                    # 执行 gez release 命令，会将 client 和 server 的代码打包到这里
        - [contenthash].zip        # 压缩文件
        - [contenthash].json       # 当前压缩的版本号
        - latest.json              # 最新的版本号
    - entry.[contenthash].js       # 入口文件
    - importmap.js                 # 不可缓存文件，执行后往 globalThis 注入 __importmap__ 
    - importmap.[contenthash].js   # 可缓存文件，执行后往 globalThis 注入 __importmap__ 
    - package.json                 # 声明模块的基本导出信息
- server/                          # 服务端构建输出
    - ...                          # 除了缺少 versions 目录，其它和 client 目录一致
```
:::tip
使用 `[contenthash]` 可以让我们生成基于内容哈希的文件名，这样我们的静态资产文件就可以放心的设置为强缓存了。    
:::

## 客户端链接
在服务渲染时注入所有服务的 `/[服务名]/importmap.[contenthash].js` 文件，将模块的哈希映射信息写入到 `globalThis.__importmap__` 对象中，最终将该变量值写入到 `<script type="importmap"></script>` 标签中。

### src/entry.server.ts
```ts
import type { ServerContext } from '@gez/core';

export default async (ctx: ServerContext, params: { url: string }) => {
    const script = await ctx.getInjectScript();
    ctx.html = `
<!DOCTYPE html>
<html>
<head>
    <title>Gez</title>
</head>
<body>
    ${script}
</body>
</html>
`;
};
```

:::tip 
在 `package.json` 中有一个 `hash` 字段，等同于 `importmap.[contenthash].js` 文件的哈希值。如果你只想做客户端渲染，可以编写一个脚本，读取每个服务的 `dist/client/package.json` 来生成一个静态的 `index.html`。可以参考一下 [ServerContext](https://github.com/dp-os/gez/blob/master/packages/core/src/core/server-context.ts) 的实现。
:::

## 服务端链接
### src/entry.node.ts
在开发阶段时，我们可以设置一个远程的依赖地址。程序会根据你配置的本地路径，计算出一个所有服务可以共同访问的 `node_modules` 路径，并自动创建软链接。   


```ts
export default {
    name: 'ssr-module-auth',
    modules: {
        imports: {
            'ssr-dep': ['root:../ssr-dep/dist', 'https://<hostname>/ssr-dep/versions/latest.json']
        }
    }
} satisfies GezOptions;
```
:::warning
在生产环境中，你应该使用本地链接，而不是远程链接，这样能提高应用程序的启动速度。如果你使用 Docker，可以通过使用[持久卷](https://docs.docker.com/engine/storage/volumes/)，将不同服务的产物组织到一个目录中。
:::
### package.json
配置 `postinstall` 钩子执行 `gez install` 命令。在安装开发依赖时，就会将远程依赖下载到你配置的 `'root:../ssr-dep/dist'` 目录中。
```ts
"scripts": {
    "postinstall": "gez install"
}
```

:::warning
这个需要在构建时，提供对应的版本才能下载。更多请查看 [gez release](./command.mdx#gez-release) 命令说明。
:::

## 示例

### ssr-dep
基础服务，提供了所有的第三方依赖。
```ts
// src/entry.node.ts
export default {
    name: 'ssr-dep',
    modules: {
        exports: [
            // 其它服务使用：import Layout from 'ssr-dep/src/components/layout.vue' 
            'root:src/components/layout.vue',
            // 其它服务可以将 vue 的外部依赖设置为 ssr-dep/npm/vue 来达到依赖共享
            'npm:vue',
            'npm:vue-router'
        ]
    }
} satisfies GezOptions;
```
:::tip
1、在一个服务中，对外导出的模块，总是使用 `npm:包名` 这样的格式，然后在其它服务使用 `导出的服务名/npm/导出的包名`。    
2、以往我们会针对业务来封装一些组件、工具函数，常常会使用 monorepo 的形式组织，如果不想对外，还需要搭建自己的 npm 私有镜像源。
3、现在你可以直接在基础服务中封装好库对外导出。
:::

#### 多版本依赖共存
在 `package.json` 中配置别名。
```json
{
    "dependencies": {
        "query-string5": "npm:query-string@^5.1.1",
        "query-string6": "npm:query-string@^6.11.1"
    }
}
```
然后就可以对外导出配置 `npm:query-string5` 和 `npm:query-string6` 包。在对应的服务将 `query-string` 模块链接到你需要的版本。
```ts
// src/entry.node.ts
export default {
    name: 'ssr-dep',
    modules: {
        exports: [
            // ...
            'npm:query-string5',
            'npm:query-string6'
        ]
    }
} satisfies GezOptions;
```
### ssr-module-auth
对外提供本服务的路由配置文件，并且将 `vue` 和 `vue-router` 模块指向到 `ssr-dep` 导出的模块
```ts
// src/entry.node.ts
export default {
    name: 'ssr-module-auth',
    modules: {
        // 其它服务使用：import routes from 'ssr-module-auth/src/routes
        exports: ['root:src/routes.ts'],
        imports: {
            'ssr-dep': 'root:../ssr-dep/dist'
        },
        externals: {
            vue: 'ssr-dep/npm/vue',
            'vue-router': 'ssr-dep/npm/vue-router'
        }
    }
} satisfies GezOptions;
```
### ssr-main
在聚合服务，可以使用
- `import Layout from 'ssr-dep/src/components/layout.vue'`
    - 来调用基础服务的公共布局组件
- `import routes from 'ssr-module-auth/src/routes`
    - 来注册来自其它服务的路由配置
- `import Vue from 'vue'`
    - 构建工具会替换为 `import Vue from 'ssr-dep/npm/vue'`
    - 其它依赖举一反三
```ts
// src/entry.node.ts
export default {
    name: 'ssr-main',
    modules: {
        imports: {
            'ssr-dep': 'root:../ssr-dep/dist',
            'ssr-module-auth': 'root:../ssr-module-auth/dist'
        },
        externals: {
            vue: 'ssr-dep/npm/vue',
            'vue-router': 'ssr-dep/npm/vue-router'
        }
    }
} satisfies GezOptions;
```